
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=1 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_3A0000.hex --list=basic816_3A0000.lst --labels=basic816_3A0000.lbl src\basic816.s
; Wed May 12 18:36:35 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=1					C256_SKU=1
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$3ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.3a0000	5c 19 89 3a	jmp $3a8919	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.3a0004	5c 2b 6f 3a	jmp $3a6f2b	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.3a0008	5c c5 26 3a	jmp $3a26c5	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.3a000c	5c 49 02 3a	jmp $3a0249	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.3a0010	5c 58 00 3a	jmp $3a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.3a0014	5c b8 00 3a	jmp $3a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.3a0018	5c 63 03 3a	jmp $3a0363	PRINTC          JML IPRINTC             ; Print the character in A to the console
.3a001c	5c ed 01 3a	jmp $3a01ed	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.3a0020	5c 08 02 3a	jmp $3a0208	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.3a0024	5c 0f 02 3a	jmp $3a020f	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.3a0028					OBUFF_PUTC
.3a0028	0b		phd		                PHD
.3a0029	08		php		                PHP
.3a002a	08		php		            PHP
.3a002b	c2 20		rep #$20	            REP #$20
.3a002d	48		pha		            PHA
.3a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0031	5b		tcd		            TCD
.3a0032	68		pla		            PLA
.3a0033	28		plp		            PLP
.3a0034	e2 20		sep #$20	            SEP #$20
.3a0036	85 b5		sta $08b5	                STA SAVE_A
.3a0038	c2 20		rep #$20	            REP #$20
.3a003a	a5 a6		lda $08a6	                LDA OBUFFER
.3a003c	d0 06		bne $3a0044	                BNE has_buffer
.3a003e	e2 20		sep #$20	            SEP #$20
.3a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.3a0042	f0 11		beq $3a0055	                BEQ done
.3a0044					has_buffer
.3a0044	c2 10		rep #$10	            REP #$10
.3a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.3a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.3a004a	f0 09		beq $3a0055	                BEQ done            ; If not, exit silently
.3a004c	e2 20		sep #$20	            SEP #$20
.3a004e	a5 b5		lda $08b5	                LDA SAVE_A
.3a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.3a0052	c8		iny		                INY                 ; Increment the index
.3a0053	84 ab		sty $08ab	                STY OBUFFIDX
.3a0055	28		plp		done            PLP
.3a0056	2b		pld		                PLD
.3a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE

;******  Return to file: src\C256/keyboard.s

.3a0058					IINPUTLINE
.3a0058	08		php		                PHP
.3a0059	c2 10		rep #$10	            REP #$10
.3a005b	e2 20		sep #$20	            SEP #$20
.3a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.3a005f	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a0062	a2 00 00	ldx #$0000	                LDX #0
.3a0065	a9 00		lda #$00	                LDA #0
.3a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.3a006b	e8		inx		                INX
.3a006c	e0 00 01	cpx #$0100	                CPX #$100
.3a006f	d0 f6		bne $3a0067	                BNE zero_loop
.3a0071	a2 00 00	ldx #$0000	                LDX #0
.3a0074					getchar
.3a0074	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.3a0079	d0 03		bne $3a007e	                BNE not_cr
.3a007b	4c b1 00	jmp $3a00b1	                JMP endofline       ; Yes: we're done
.3a007e					not_cr
.3a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.3a0080	d0 1a		bne $3a009c	                BNE not_bs
.3a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.3a0085	f0 ed		beq $3a0074	                BEQ getchar         ; yes: ignore the backspace
.3a0087	da		phx		                PHX                 ; Save the cursor position
.3a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.3a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.3a0090	f0 06		beq $3a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.3a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.3a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.3a0096	d0 f0		bne $3a0088	                BNE clr_loop
.3a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.3a0099	ca		dex		                DEX                 ; No: move the cursor left
.3a009a	80 0e		bra $3a00aa	                BRA print_bs        ; And print the backspace
.3a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.3a009e	90 d4		bcc $3a0074	                BLT getchar         ; Yes: ignore it
.3a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.3a00a4	e8		inx		                INX                 ; Move the cursor forward
.3a00a5					echo
.3a00a5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00a8	80 ca		bra $3a0074	                BRA getchar         ; And get another...
.3a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.3a00ac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00af	80 c3		bra $3a0074	                BRA getchar         ; And get another...
.3a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.3a00b3	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a00b6	28		plp		                PLP
.3a00b7	60		rts		            RTS
.3a00b8					IGETKEY
.3a00b8	da		phx		                PHX
.3a00b9	5a		phy		                PHY
.3a00ba	8b		phb		                PHB
.3a00bb	0b		phd		                PHD
.3a00bc	08		php		                PHP
.3a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.3a00c1	28		plp		                PLP
.3a00c2	2b		pld		                PLD
.3a00c3	ab		plb		                PLB
.3a00c4	7a		ply		                PLY
.3a00c5	fa		plx		                PLX
.3a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.3a00c7					SEND_ANSI
.3a00c7	08		php		                PHP
.3a00c8	e2 30		sep #$30	            SEP #$30
.3a00ca	48		pha		                PHA
.3a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.3a00cd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.3a00d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d5	68		pla		                PLA                     ; Print the command code
.3a00d6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d9	28		plp		                PLP
.3a00da	60		rts		            RTS
.3a00db					GETKEYE
.3a00db	0b		phd		                PHD
.3a00dc	8b		phb		                PHB
.3a00dd	08		php		                PHP
.3a00de	08		php		            PHP
.3a00df	e2 20		sep #$20	            SEP #$20
.3a00e1	48		pha		            PHA
.3a00e2	a9 00		lda #$00	            LDA #0
.3a00e4	48		pha		            PHA
.3a00e5	ab		plb		            PLB
.3a00e6	68		pla		            PLA
.3a00e7	28		plp		            PLP
.3a00e8	08		php		            PHP
.3a00e9	c2 20		rep #$20	            REP #$20
.3a00eb	48		pha		            PHA
.3a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a00ef	5b		tcd		            TCD
.3a00f0	68		pla		            PLA
.3a00f1	28		plp		            PLP
.3a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.3a00f2	c2 20		rep #$20	            REP #$20
.3a00f4	3b		tsc		            TSC
.3a00f5	38		sec		            SEC
.3a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a00f9	1b		tcs		            TCS
.3a00fa	e2 20		sep #$20	            SEP #$20
.3a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.3a00fe	83 02		sta $02,s	                STA l_state
.3a0100	83 03		sta $03,s	                STA l_code
.3a0102	83 04		sta $04,s	                STA l_modifiers
.3a0104					loop
.3a0104	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.3a0109	f0 f9		beq $3a0104	                BEQ loop                ; Yes: keep waiting
.3a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.3a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.3a010f	d0 35		bne $3a0146	                BNE chk_st_esc
.3a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.3a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.3a0115	d0 0a		bne $3a0121	                BNE not_bs
.3a0117	20 18 00	jsr $3a0018	            JSR PRINTC
.3a011a	a9 50		lda #$50	                LDA #'P'
.3a011c	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a011f	80 e3		bra $3a0104	                BRA loop                ; And keep waiting for a keypress
.3a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.3a0123	f0 0a		beq $3a012f	                BEQ send                ; Yes: print and return it
.3a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.3a0127	d0 06		bne $3a012f	                BNE send                ; No: just print it out
.3a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.3a012b	83 02		sta $02,s	                STA l_state
.3a012d	80 d5		bra $3a0104	                BRA loop                ; And get the next character in the sequence
.3a012f					send
.3a012f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.3a0134	85 0c		sta $080c	                STA SCRATCH
.3a0136	c2 20		rep #$20	            REP #$20
.3a0138	3b		tsc		            TSC
.3a0139	18		clc		            CLC
.3a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a013d	1b		tcs		            TCS
.3a013e	e2 20		sep #$20	            SEP #$20
.3a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.3a0142	28		plp		                PLP
.3a0143	2b		pld		                PLD
.3a0144	ab		plb		                PLB
.3a0145	60		rts		            RTS
.3a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.3a0148	d0 10		bne $3a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.3a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.3a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.3a014e	f0 03		beq $3a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.3a0150	82 a9 ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.3a0155	83 02		sta $02,s	                STA l_state
.3a0157	82 aa ff	brl $3a0104	                BRL loop
.3a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.3a015c	d0 29		bne $3a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.3a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.3a0162	90 0c		bcc $3a0170	                BLT not_letter
.3a0164	c9 45		cmp #$45	                CMP #'D'+1
.3a0166	b0 08		bcs $3a0170	                BGE not_letter
.3a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.3a016a	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a016d	82 8c ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.3a0172	90 10		bcc $3a0184	                BLT not_csi_digit
.3a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0176	b0 0c		bcs $3a0184	                BGE not_csi_digit       ; No: handle it being invalid
.3a0178	38		sec		                SEC                     ; Yes: convert to a value
.3a0179	e9 30		sbc #$30	                SBC #'0'
.3a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.3a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.3a017f	83 02		sta $02,s	                STA l_state
.3a0181	82 80 ff	brl $3a0104	                BRL loop
.3a0184	82 75 ff	brl $3a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.3a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the  state?
.3a0189	d0 a7		bne $3a0132	                BNE done
.3a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.3a018f	90 1b		bcc $3a01ac	                BLT not_digits_2
.3a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0193	b0 17		bcs $3a01ac	                BGE not_digits_2
.3a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.3a0197	0a		asl a		                ASL A
.3a0198	85 0c		sta $080c	                STA SCRATCH
.3a019a	0a		asl a		                ASL A                   ; Multiply l_code by 8
.3a019b	0a		asl a		                ASL A
.3a019c	18		clc		                CLC
.3a019d	65 0c		adc $080c	                ADC SCRATCH             ; Add to get l_code * 10
.3a019f	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.3a01a1	38		sec		                SEC
.3a01a2	e9 30		sbc #$30	                SBC #'0'
.3a01a4	18		clc		                CLC                     ; And add to l_code
.3a01a5	65 0c		adc $080c	                ADC SCRATCH
.3a01a7	83 03		sta $03,s	                STA l_code
.3a01a9	82 58 ff	brl $3a0104	                BRL loop                ; And keep processing the sequence
.3a01ac					not_digits_2
.3a01ac	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.3a01ae	f0 03		beq $3a01b3	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.3a01b0	82 49 ff	brl $3a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.3a01b3	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.3a01b5	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.3a01b7	f0 07		beq $3a01c0	                BEQ do_ins              ; Yes: process the insert
.3a01b9	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.3a01bb	f0 07		beq $3a01c4	                BEQ do_del              ; Yes: process the delete
.3a01bd	82 3c ff	brl $3a00fc	                BRL get_reset           ; Code is not one we handle, just return
.3a01c0	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.3a01c2	80 02		bra $3a01c6	                BRA snd_ansi
.3a01c4	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.3a01c6					snd_ansi
.3a01c6	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a01c9	82 30 ff	brl $3a00fc	                BRL get_reset           ; Reset and keep getting characters

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.3a01cc					ENSURETEXT
.3a01cc	08		php		            PHP
.3a01cd	e2 20		sep #$20	            SEP #$20
.3a01cf	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.3a01d3	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.3a01d5	f0 08		beq $3a01df	            BEQ textonly                        ; If not, make sure text is enabled
.3a01d7					overlay
.3a01d7	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.3a01d9	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a01dd	80 0c		bra $3a01eb	            BRA done
.3a01df					textonly
.3a01df	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.3a01e1	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a01e5	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.3a01e7	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a01eb	28		plp		done        PLP
.3a01ec	60		rts		            RTS
.3a01ed					ISHOWCURSOR
.3a01ed	08		php		            PHP
.3a01ee	e2 20		sep #$20	            SEP #$20
.3a01f0	c9 00		cmp #$00	            CMP #0
.3a01f2	f0 08		beq $3a01fc	            BEQ hide
.3a01f4	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a01f8	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.3a01fa	80 06		bra $3a0202	            BRA setit
.3a01fc	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0200	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.3a0202	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.3a0206	28		plp		            PLP
.3a0207	60		rts		            RTS
.3a0208					ICURSORXY
.3a0208	08		php		            PHP
.3a0209	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a020d	28		plp		            PLP
.3a020e	60		rts		            RTS
.3a020f					ICLSCREEN
.3a020f	48		pha		            PHA
.3a0210	da		phx		            PHX
.3a0211	5a		phy		            PHY
.3a0212	0b		phd		            PHD
.3a0213	08		php		            PHP
.3a0214	e2 20		sep #$20	            SEP #$20
.3a0216	c2 10		rep #$10	            REP #$10
.3a0218	a2 00 00	ldx #$0000	            LDX #0
.3a021b	a9 20		lda #$20	loop        LDA #$20
.3a021d	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.3a0221	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.3a0225	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.3a0229	e8		inx		            INX                         ; Move to the next character cell
.3a022a	e0 00 20	cpx #$2000	            CPX #$2000
.3a022d	d0 ec		bne $3a021b	            BNE loop
.3a022f	08		php		            PHP
.3a0230	c2 20		rep #$20	            REP #$20
.3a0232	48		pha		            PHA
.3a0233	a9 00 00	lda #$0000	            LDA #0
.3a0236	5b		tcd		            TCD
.3a0237	68		pla		            PLA
.3a0238	28		plp		            PLP
.3a0239	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.3a023c	a0 00 00	ldy #$0000	            LDY #0
.3a023f	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a0243	28		plp		            PLP
.3a0244	2b		pld		            PLD
.3a0245	7a		ply		            PLY
.3a0246	fa		plx		            PLX
.3a0247	68		pla		            PLA
.3a0248	60		rts		            RTS
.3a0249					ISCRCPYLINE
.3a0249	da		phx		            PHX
.3a024a	5a		phy		            PHY
.3a024b	0b		phd		            PHD
.3a024c	08		php		            PHP
.3a024d	08		php		            PHP
.3a024e	c2 20		rep #$20	            REP #$20
.3a0250	48		pha		            PHA
.3a0251	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0254	5b		tcd		            TCD
.3a0255	68		pla		            PLA
.3a0256	28		plp		            PLP
.3a0257	c2 30		rep #$30	            REP #$30
.3a0259	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.3a025d	85 08		sta $0808	            STA INDEX
.3a025f	e2 20		sep #$20	            SEP #$20
.3a0261	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.3a0265	c2 20		rep #$20	            REP #$20
.3a0267	29 ff 00	and #$00ff	            AND #$00FF
.3a026a	85 0a		sta $080a	            STA INDEX+2
.3a026c	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.3a0270	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.3a0274	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.3a0278	3a		dec a		            DEC A
.3a0279	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.3a027d	18		clc		            CLC                     ; And add it to INDEX
.3a027e	a5 08		lda $0808	            LDA INDEX
.3a0280	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.3a0284	85 08		sta $0808	            STA INDEX
.3a0286	a5 0a		lda $080a	            LDA INDEX+2
.3a0288	69 00 00	adc #$0000	            ADC #0
.3a028b	85 0a		sta $080a	            STA INDEX+2
.3a028d	e2 20		sep #$20	            SEP #$20
.3a028f	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.3a0293	85 8f		sta $088f	            STA MCOUNT
.3a0295	a0 00 00	ldy #$0000	            LDY #0
.3a0298	a2 00 00	ldx #$0000	            LDX #0
.3a029b	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.3a029d	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a02a1	e8		inx		            INX
.3a02a2	c8		iny		            INY
.3a02a3	c4 8f		cpy $088f	            CPY MCOUNT
.3a02a5	d0 f4		bne $3a029b	            BNE copy_loop
.3a02a7	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.3a02ab	3a		dec a		            DEC A
.3a02ac	aa		tax		            TAX
.3a02ad	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.3a02b1	c9 20		cmp #$20	            CMP #CHAR_SP
.3a02b3	d0 09		bne $3a02be	            BNE done
.3a02b5	a9 00		lda #$00	            LDA #0
.3a02b7	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a02bb	ca		dex		            DEX
.3a02bc	10 ef		bpl $3a02ad	            BPL trim_loop
.3a02be	28		plp		done        PLP
.3a02bf	2b		pld		            PLD
.3a02c0	7a		ply		            PLY
.3a02c1	fa		plx		            PLX
.3a02c2	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.3a02c3					INITIO
.3a02c3	e2 20		sep #$20	            SEP #$20
.3a02c5	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.3a02c8	a9 00		lda #$00	            LDA #0
.3a02ca	9f 18 f0 3a	sta $3af018,x	sp_loop     STA GS_SP_CONTROL,X
.3a02ce	e8		inx		            INX
.3a02cf	e0 40 00	cpx #$0040	            CPX #SP_MAX
.3a02d2	d0 f6		bne $3a02ca	            BNE sp_loop
.3a02d4	a9 80		lda #$80	            LDA #DEV_SCREEN
.3a02d6	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.3a02da	e2 20		sep #$20	            SEP #$20
.3a02dc	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.3a02de	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.3a02e2	a9 00		lda #$00	            LDA #0
.3a02e4	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.3a02e8	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.3a02ec	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.3a02f0	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.3a02f4					done
.3a02f4	60		rts		            RTS
.3a02f5					SCREEN_PUTC
.3a02f5	08		php		            PHP
.3a02f6	e2 20		sep #$20	            SEP #$20
.3a02f8	48		pha		            PHA
.3a02f9	48		pha		            PHA
.3a02fa	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.3a02fc	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a0300	68		pla		            PLA
.3a0301	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a0305	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a0309	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a030b	d0 f8		bne $3a0305	            BNE loop                ; Yes: wait until it's released
.3a030d	68		pla		            PLA
.3a030e	28		plp		            PLP
.3a030f	60		rts		            RTS
.3a0310					UART_PUTC
.3a0310	08		php		            PHP
.3a0311	e2 20		sep #$20	            SEP #$20
.3a0313	48		pha		            PHA
.3a0314	48		pha		            PHA
.3a0315	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.3a0317	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a031b	68		pla		            PLA
.3a031c	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a0320	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a0324	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a0326	d0 f8		bne $3a0320	            BNE loop                ; Yes: wait until it's released
.3a0328	68		pla		            PLA
.3a0329	28		plp		            PLP
.3a032a	60		rts		            RTS
.3a032b					PRINTCR
.3a032b	08		php		            PHP
.3a032c	c2 20		rep #$20	            REP #$20
.3a032e	48		pha		            PHA
.3a032f	e2 20		sep #$20	            SEP #$20
.3a0331	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a0333	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0336	c2 20		rep #$20	            REP #$20
.3a0338	68		pla		            PLA
.3a0339	28		plp		            PLP
.3a033a	60		rts		            RTS
.3a033b					PRINTH
.3a033b	08		php		            PHP
.3a033c	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.3a0340	28		plp		            PLP
.3a0341	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.3a0342					PAGINATE
.3a0342	08		php		            PHP
.3a0343	0b		phd		            PHD
.3a0344	08		php		            PHP
.3a0345	c2 20		rep #$20	            REP #$20
.3a0347	48		pha		            PHA
.3a0348	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a034b	5b		tcd		            TCD
.3a034c	68		pla		            PLA
.3a034d	28		plp		            PLP
.3a034e	e2 20		sep #$20	            SEP #$20
.3a0350	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.3a0352	1a		inc a		            INC A
.3a0353	85 b6		sta $08b6	            STA LINECOUNT
.3a0355	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.3a0359	90 05		bcc $3a0360	            BLT done                ; If < limit, just return
.3a035b	20 14 00	jsr $3a0014	            JSR GETKEY
.3a035e	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.3a0360	2b		pld		done        PLD
.3a0361	28		plp		            PLP
.3a0362	60		rts		            RTS
.3a0363					IPRINTC
.3a0363	da		phx		            PHX
.3a0364	5a		phy		            PHY
.3a0365	0b		phd		            PHD
.3a0366	08		php		            PHP
.3a0367	08		php		            PHP
.3a0368	c2 20		rep #$20	            REP #$20
.3a036a	48		pha		            PHA
.3a036b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a036e	5b		tcd		            TCD
.3a036f	68		pla		            PLA
.3a0370	28		plp		            PLP
.3a0371	e2 20		sep #$20	            SEP #$20
.3a0373	c2 10		rep #$10	            REP #$10
.3a0375	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.3a0379	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.3a037d	29 20		and #$20	            AND #DEV_BUFFER
.3a037f	f0 07		beq $3a0388	            BEQ check_scrn      ; No... move on to the hardware screen
.3a0381	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0385	20 28 00	jsr $3a0028	            JSR OBUFF_PUTC
.3a0388	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.3a038c	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.3a038e	f0 07		beq $3a0397	            BEQ send_uart
.3a0390	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0394	20 f5 02	jsr $3a02f5	            JSR SCREEN_PUTC
.3a0397	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.3a039b	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.3a039d	f0 14		beq $3a03b3	            BEQ done
.3a039f	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a03a3	20 10 03	jsr $3a0310	            JSR UART_PUTC
.3a03a6	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.3a03aa	c9 0d		cmp #$0d	            CMP #CHAR_CR
.3a03ac	d0 05		bne $3a03b3	            BNE done
.3a03ae	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.3a03b0	20 10 03	jsr $3a0310	            JSR UART_PUTC
.3a03b3	28		plp		done        PLP
.3a03b4	2b		pld		            PLD
.3a03b5	7a		ply		            PLY
.3a03b6	fa		plx		            PLX
.3a03b7	60		rts		            RTS
.3a03b8					PRINTS
.3a03b8	08		php		            PHP
.3a03b9	e2 20		sep #$20	            SEP #$20
.3a03bb	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a03be	f0 06		beq $3a03c6	            BEQ done
.3a03c0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a03c3	e8		inx		            INX
.3a03c4	80 f5		bra $3a03bb	            BRA loop
.3a03c6	28		plp		done        PLP
.3a03c7	60		rts		            RTS
.3a03c8					PRHEXW
.3a03c8	08		php		            PHP
.3a03c9	c2 20		rep #$20	            REP #$20
.3a03cb	48		pha		            PHA
.3a03cc	48		pha		            PHA
.3a03cd	4a		lsr a		            LSR A
.3a03ce	4a		lsr a		            LSR A
.3a03cf	4a		lsr a		            LSR A
.3a03d0	4a		lsr a		            LSR A
.3a03d1	4a		lsr a		            LSR A
.3a03d2	4a		lsr a		            LSR A
.3a03d3	4a		lsr a		            LSR A
.3a03d4	4a		lsr a		            LSR A
.3a03d5	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a03d8	68		pla		            PLA
.3a03d9	29 ff 00	and #$00ff	            AND #$00FF
.3a03dc	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a03df	68		pla		            PLA
.3a03e0	28		plp		            PLP
.3a03e1	60		rts		            RTS
.3a03e2					PRHEXB
.3a03e2	08		php		            PHP
.3a03e3	c2 20		rep #$20	            REP #$20
.3a03e5	48		pha		            PHA
.3a03e6	e2 20		sep #$20	            SEP #$20
.3a03e8	48		pha		            PHA
.3a03e9	4a		lsr a		            LSR A
.3a03ea	4a		lsr a		            LSR A
.3a03eb	4a		lsr a		            LSR A
.3a03ec	4a		lsr a		            LSR A
.3a03ed	20 f9 03	jsr $3a03f9	            JSR PRHEXN
.3a03f0	68		pla		            PLA
.3a03f1	20 f9 03	jsr $3a03f9	            JSR PRHEXN
.3a03f4	c2 20		rep #$20	            REP #$20
.3a03f6	68		pla		            PLA
.3a03f7	28		plp		            PLP
.3a03f8	60		rts		            RTS
.3a03f9					PRHEXN
.3a03f9	08		php		            PHP
.3a03fa	c2 30		rep #$30	            REP #$30
.3a03fc	da		phx		            PHX
.3a03fd	29 0f 00	and #$000f	            AND #$000F
.3a0400	aa		tax		            TAX
.3a0401	bf 00 d0 3a	lda $3ad000,x	            LDA @lHEXDIGITS,X
.3a0405	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0408	fa		plx		            PLX
.3a0409	28		plp		            PLP
.3a040a	60		rts		            RTS
>3ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>3ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.3a040b					PRTRACE
.3a040b	08		php		            PHP
.3a040c	c2 30		rep #$30	            REP #$30
.3a040e	48		pha		            PHA
.3a040f	da		phx		            PHX
.3a0410	5a		phy		            PHY
.3a0411	8b		phb		            PHB
.3a0412	0b		phd		            PHD
.3a0413	c2 30		rep #$30	            REP #$30
.3a0415	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.3a0417	18		clc		calc_addr   CLC
.3a0418	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.3a041b	aa		tax		            TAX
.3a041c	e2 20		sep #$20	            SEP #$20
.3a041e	a9 3a		lda #$3a	            LDA #`PRTRACE
.3a0420	48		pha		            PHA
.3a0421	ab		plb		            PLB
.3a0422	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.3a0425	f0 06		beq $3a042d	            BEQ done
.3a0427	20 f5 02	jsr $3a02f5	            JSR SCREEN_PUTC
.3a042a	e8		inx		            INX
.3a042b	80 f5		bra $3a0422	            BRA pr_loop
.3a042d					done
.3a042d	c2 30		rep #$30	            REP #$30
.3a042f	2b		pld		            PLD
.3a0430	ab		plb		            PLB
.3a0431	7a		ply		            PLY
.3a0432	fa		plx		            PLX
.3a0433	68		pla		            PLA
.3a0434	28		plp		            PLP
.3a0435	60		rts		            RTS
.3a0436					ISALPHA
.3a0436	08		php		            PHP
.3a0437	e2 20		sep #$20	            SEP #$20
.3a0439	c9 5b		cmp #$5b	            CMP #'Z'+1
.3a043b	b0 04		bcs $3a0441	            BGE not_upper
.3a043d	c9 41		cmp #$41	            CMP #'A'
.3a043f	b0 0b		bcs $3a044c	            BGE is_alpha
.3a0441	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.3a0443	b0 04		bcs $3a0449	            BGE not_alpha
.3a0445	c9 61		cmp #$61	            CMP #'a'
.3a0447	b0 03		bcs $3a044c	            BGE is_alpha
.3a0449					not_alpha
.3a0449	28		plp		            PLP
.3a044a	18		clc		            CLC
.3a044b	60		rts		            RTS
.3a044c					is_alpha
.3a044c	28		plp		            PLP
.3a044d	38		sec		            SEC
.3a044e	60		rts		            RTS
.3a044f					ISNUMERAL
.3a044f	08		php		            PHP
.3a0450	e2 20		sep #$20	            SEP #$20
.3a0452	c9 3a		cmp #$3a	            CMP #'9'+1
.3a0454	b0 04		bcs $3a045a	            BGE ret_false
.3a0456	c9 30		cmp #$30	            CMP #'0'
.3a0458	b0 03		bcs $3a045d	            BGE ret_true
.3a045a	28		plp		ret_false   PLP
.3a045b	18		clc		            CLC
.3a045c	60		rts		            RTS
.3a045d	28		plp		ret_true    PLP
.3a045e	38		sec		            SEC
.3a045f	60		rts		            RTS
.3a0460					ISHEX
.3a0460	08		php		            PHP
.3a0461	e2 20		sep #$20	            SEP #$20
.3a0463	c9 3a		cmp #$3a	            CMP #'9'+1
.3a0465	b0 04		bcs $3a046b	            BGE chk_lca2f
.3a0467	c9 30		cmp #$30	            CMP #'0'
.3a0469	b0 13		bcs $3a047e	            BGE ret_true
.3a046b	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a046d	b0 04		bcs $3a0473	            BGE chk_uca2f
.3a046f	c9 61		cmp #$61	            CMP #'a'
.3a0471	b0 0b		bcs $3a047e	            BGE ret_true
.3a0473	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a0475	b0 04		bcs $3a047b	            BGE ret_false
.3a0477	c9 41		cmp #$41	            CMP #'A'
.3a0479	b0 03		bcs $3a047e	            BGE ret_true
.3a047b	28		plp		ret_false   PLP
.3a047c	18		clc		            CLC
.3a047d	60		rts		            RTS
.3a047e	28		plp		ret_true    PLP
.3a047f	38		sec		            SEC
.3a0480	60		rts		            RTS
.3a0481					HEX2BIN
.3a0481	08		php		            PHP
.3a0482	e2 20		sep #$20	            SEP #$20
.3a0484	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.3a0486	b0 04		bcs $3a048c	            BGE chk_lca2f
.3a0488	c9 30		cmp #$30	            CMP #'0'
.3a048a	b0 12		bcs $3a049e	            BGE conv_09         ; Yes: convert it
.3a048c	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a048e	b0 04		bcs $3a0494	            BGE chk_uca2f
.3a0490	c9 61		cmp #$61	            CMP #'a'
.3a0492	b0 0f		bcs $3a04a3	            BGE conv_lcaf
.3a0494	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a0496	b0 04		bcs $3a049c	            BGE done
.3a0498	c9 41		cmp #$41	            CMP #'A'
.3a049a	b0 09		bcs $3a04a5	            BGE conv_ucaf
.3a049c	28		plp		done        PLP
.3a049d	60		rts		            RTS
.3a049e	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.3a049f	e9 30		sbc #$30	            SBC #'0'
.3a04a1	80 f9		bra $3a049c	            BRA done
.3a04a3	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.3a04a5	38		sec		conv_ucaf   SEC
.3a04a6	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.3a04a8	80 f2		bra $3a049c	            BRA done
.3a04aa					TOUPPERA
.3a04aa	08		php		            PHP
.3a04ab	e2 20		sep #$20	            SEP #$20
.3a04ad	c9 7b		cmp #$7b	            CMP #'z'+1
.3a04af	b0 06		bcs $3a04b7	            BCS done
.3a04b1	c9 61		cmp #$61	            CMP #'a'
.3a04b3	90 02		bcc $3a04b7	            BCC done
.3a04b5	29 df		and #$df	            AND #%11011111
.3a04b7	28		plp		done        PLP
.3a04b8	60		rts		            RTS
.3a04b9					TOUPPER
.3a04b9	08		php		            PHP
.3a04ba	e2 20		sep #$20	            SEP #$20
.3a04bc	c2 10		rep #$10	            REP #$10
.3a04be	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a04c1	f0 09		beq $3a04cc	            BEQ done
.3a04c3	20 aa 04	jsr $3a04aa	            JSR TOUPPERA
.3a04c6	9d 00 00	sta $0000,x	            STA #0,B,X
.3a04c9	e8		inx		continue    INX
.3a04ca	80 f2		bra $3a04be	            BRA loop
.3a04cc	28		plp		done        PLP
.3a04cd	60		rts		            RTS
.3a04ce					MULINT10
.3a04ce	08		php		                PHP
.3a04cf	0b		phd		                PHD
.3a04d0	08		php		            PHP
.3a04d1	c2 20		rep #$20	            REP #$20
.3a04d3	48		pha		            PHA
.3a04d4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a04d7	5b		tcd		            TCD
.3a04d8	68		pla		            PLA
.3a04d9	28		plp		            PLP
.3a04da	c2 20		rep #$20	            REP #$20
.3a04dc	48		pha		                PHA
.3a04dd	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.3a04df	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.3a04e1	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a04e3	85 0c		sta $080c	                STA SCRATCH             ; 4
.3a04e5	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a04e7	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.3a04e9	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.3a04eb	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a04ed	06 0c		asl $080c	                ASL SCRATCH             ; 7
.3a04ef	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a04f1	18		clc		                CLC                     ; 2 -- 26
.3a04f2	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a04f4	65 0c		adc $080c	                ADC SCRATCH             ; 4
.3a04f6	85 23		sta $0823	                STA ARGUMENT1           ; 4
.3a04f8	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a04fa	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.3a04fc	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.3a04fe	68		pla		                PLA
.3a04ff	2b		pld		                PLD
.3a0500	28		plp		                PLP
.3a0501	60		rts		            RTS
.3a0502					DIVINT10
.3a0502	08		php		                PHP
.3a0503	0b		phd		                PHD
.3a0504	08		php		            PHP
.3a0505	c2 20		rep #$20	            REP #$20
.3a0507	48		pha		            PHA
.3a0508	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a050b	5b		tcd		            TCD
.3a050c	68		pla		            PLA
.3a050d	28		plp		            PLP
.3a050e	c2 20		rep #$20	            REP #$20
.3a0510	a5 23		lda $0823	                LDA ARGUMENT1
.3a0512	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a0516	a9 0a 00	lda #$000a	                LDA #10
.3a0519	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a051d	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a0521	85 23		sta $0823	                STA ARGUMENT1
.3a0523	64 25		stz $0825	                STZ ARGUMENT1+2
.3a0525	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a0529	85 29		sta $0829	                STA ARGUMENT2
.3a052b	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a052d	e2 20		sep #$20	            SEP #$20
.3a052f	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a0531	85 27		sta $0827	                STA ARGTYPE1
.3a0533	85 2d		sta $082d	                STA ARGTYPE2
.3a0535	2b		pld		                PLD
.3a0536	28		plp		                PLP
.3a0537	60		rts		            RTS
.3a0538					DIVINT100
.3a0538	08		php		                PHP
.3a0539	0b		phd		                PHD
.3a053a	08		php		            PHP
.3a053b	c2 20		rep #$20	            REP #$20
.3a053d	48		pha		            PHA
.3a053e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0541	5b		tcd		            TCD
.3a0542	68		pla		            PLA
.3a0543	28		plp		            PLP
.3a0544	c2 20		rep #$20	            REP #$20
.3a0546	a5 23		lda $0823	                LDA ARGUMENT1
.3a0548	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a054c	a9 64 00	lda #$0064	                LDA #100
.3a054f	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a0553	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a0557	85 23		sta $0823	                STA ARGUMENT1
.3a0559	64 25		stz $0825	                STZ ARGUMENT1+2
.3a055b	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a055f	85 29		sta $0829	                STA ARGUMENT2
.3a0561	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a0563	e2 20		sep #$20	            SEP #$20
.3a0565	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a0567	85 27		sta $0827	                STA ARGTYPE1
.3a0569	85 2d		sta $082d	                STA ARGTYPE2
.3a056b	2b		pld		                PLD
.3a056c	28		plp		                PLP
.3a056d	60		rts		            RTS
.3a056e					IS_ARG1_Z
.3a056e	08		php		                PHP
.3a056f	c2 20		rep #$20	            REP #$20
.3a0571	a5 23		lda $0823	                LDA ARGUMENT1
.3a0573	d0 08		bne $3a057d	                BNE return_false
.3a0575	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a0577	d0 04		bne $3a057d	                BNE return_false
.3a0579	28		plp		return_true     PLP
.3a057a	e2 02		sep #$02	                SEP #$02        ; Set Z
.3a057c	60		rts		            RTS
.3a057d	28		plp		return_false    PLP
.3a057e	c2 02		rep #$02	                REP #$02        ; Clear Z
.3a0580	60		rts		            RTS
.3a0581					SET_TRUE
.3a0581	08		php		                PHP
.3a0582	c2 30		rep #$30	            REP #$30
.3a0584	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a0587	85 23		sta $0823	                STA ARGUMENT1
.3a0589	85 25		sta $0825	                STA ARGUMENT1+2
.3a058b	e2 20		sep #$20	            SEP #$20
.3a058d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a058f	85 27		sta $0827	                STA ARGTYPE1
.3a0591	28		plp		                PLP
.3a0592	60		rts		            RTS
.3a0593					SET_FALSE
.3a0593	08		php		                PHP
.3a0594	c2 30		rep #$30	            REP #$30
.3a0596	a9 00 00	lda #$0000	                LDA #0
.3a0599	85 23		sta $0823	                STA ARGUMENT1
.3a059b	85 25		sta $0825	                STA ARGUMENT1+2
.3a059d	e2 20		sep #$20	            SEP #$20
.3a059f	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a05a1	85 27		sta $0827	                STA ARGTYPE1
.3a05a3	28		plp		                PLP
.3a05a4	60		rts		            RTS
.3a05a5					ASS_ARG1_INT
.3a05a5	08		php		                PHP
.3a05a6	e2 20		sep #$20	            SEP #$20
.3a05a8	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a05aa	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a05ac	f0 07		beq $3a05b5	                BEQ done                ; If so: just return
.3a05ae	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a05b0	d0 05		bne $3a05b7	                BNE TYPE_ERR            ; If not: throw an error
.3a05b2	20 b1 5a	jsr $3a5ab1	            JSR FTOI
.3a05b5	28		plp		done            PLP
.3a05b6	60		rts		            RTS
.3a05b7					TYPE_ERR
.3a05b7	08		php		            PHP
.3a05b8	c2 20		rep #$20	            REP #$20
.3a05ba	48		pha		            PHA
.3a05bb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a05be	5b		tcd		            TCD
.3a05bf	68		pla		            PLA
.3a05c0	28		plp		            PLP
.3a05c1	e2 20		sep #$20	            SEP #$20
.3a05c3	a9 04		lda #$04	            LDA #ERR_TYPE
.3a05c5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a05c9	c2 20		rep #$20	            REP #$20
.3a05cb	29 ff 00	and #$00ff	            AND #$00FF
.3a05ce	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a05d1	e2 20		sep #$20	            SEP #$20
.3a05d3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a05d6					ASS_ARG2_INT
.3a05d6	08		php		                PHP
.3a05d7	e2 20		sep #$20	            SEP #$20
.3a05d9	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.3a05db	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a05dd	f0 37		beq $3a0616	                BEQ done                    ; If so: just return
.3a05df	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.3a05e1	d0 35		bne $3a0618	                BNE TYPE_ERR                ; If not: throw an error
.3a05e3	c2 20		rep #$20	            REP #$20
.3a05e5	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a05e7	48		pha		            PHA
.3a05e8	a5 23		lda $0823	            LDA ARGUMENT1
.3a05ea	48		pha		            PHA
.3a05eb	c2 20		rep #$20	            REP #$20
.3a05ed	a5 29		lda $0829	            LDA ARGUMENT2
.3a05ef	85 23		sta $0823	            STA ARGUMENT1
.3a05f1	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a05f3	85 25		sta $0825	            STA ARGUMENT1+2
.3a05f5	e2 20		sep #$20	            SEP #$20
.3a05f7	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a05f9	85 27		sta $0827	            STA ARGTYPE1
.3a05fb	20 b1 5a	jsr $3a5ab1	            JSR FTOI
.3a05fe	c2 20		rep #$20	            REP #$20
.3a0600	a5 23		lda $0823	            LDA ARGUMENT1
.3a0602	85 29		sta $0829	            STA ARGUMENT2
.3a0604	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0606	85 2b		sta $082b	            STA ARGUMENT2+2
.3a0608	e2 20		sep #$20	            SEP #$20
.3a060a	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a060c	85 2d		sta $082d	            STA ARGTYPE2
.3a060e	c2 20		rep #$20	            REP #$20
.3a0610	68		pla		            PLA
.3a0611	85 23		sta $0823	            STA ARGUMENT1
.3a0613	68		pla		            PLA
.3a0614	85 25		sta $0825	            STA ARGUMENT1+2
.3a0616	28		plp		done            PLP
.3a0617	60		rts		            RTS
.3a0618					TYPE_ERR
.3a0618	08		php		            PHP
.3a0619	c2 20		rep #$20	            REP #$20
.3a061b	48		pha		            PHA
.3a061c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a061f	5b		tcd		            TCD
.3a0620	68		pla		            PLA
.3a0621	28		plp		            PLP
.3a0622	e2 20		sep #$20	            SEP #$20
.3a0624	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0626	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a062a	c2 20		rep #$20	            REP #$20
.3a062c	29 ff 00	and #$00ff	            AND #$00FF
.3a062f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a0632	e2 20		sep #$20	            SEP #$20
.3a0634	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0637					ASS_ARG1_STR
.3a0637	08		php		                PHP
.3a0638	e2 20		sep #$20	            SEP #$20
.3a063a	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.3a063c	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a063e	d0 02		bne $3a0642	                BNE TYPE_ERR
.3a0640	28		plp		                PLP
.3a0641	60		rts		            RTS
.3a0642					TYPE_ERR
.3a0642	08		php		            PHP
.3a0643	c2 20		rep #$20	            REP #$20
.3a0645	48		pha		            PHA
.3a0646	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0649	5b		tcd		            TCD
.3a064a	68		pla		            PLA
.3a064b	28		plp		            PLP
.3a064c	e2 20		sep #$20	            SEP #$20
.3a064e	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0650	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0654	c2 20		rep #$20	            REP #$20
.3a0656	29 ff 00	and #$00ff	            AND #$00FF
.3a0659	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a065c	e2 20		sep #$20	            SEP #$20
.3a065e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0661					ASS_ARG1_INT16
.3a0661	08		php		                PHP
.3a0662	e2 20		sep #$20	            SEP #$20
.3a0664	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a0666	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a0668	f0 07		beq $3a0671	                BEQ check_range         ; If so: check the range
.3a066a	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a066c	d0 0b		bne $3a0679	                BNE TYPE_ERR            ; If not: throw an error
.3a066e	20 b1 5a	jsr $3a5ab1	            JSR FTOI
.3a0671					check_range
.3a0671	c2 20		rep #$20	            REP #$20
.3a0673	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.3a0675	d0 21		bne $3a0698	                BNE range_err
.3a0677	28		plp		                PLP
.3a0678	60		rts		            RTS
.3a0679					TYPE_ERR
.3a0679	08		php		            PHP
.3a067a	c2 20		rep #$20	            REP #$20
.3a067c	48		pha		            PHA
.3a067d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0680	5b		tcd		            TCD
.3a0681	68		pla		            PLA
.3a0682	28		plp		            PLP
.3a0683	e2 20		sep #$20	            SEP #$20
.3a0685	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0687	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a068b	c2 20		rep #$20	            REP #$20
.3a068d	29 ff 00	and #$00ff	            AND #$00FF
.3a0690	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a0693	e2 20		sep #$20	            SEP #$20
.3a0695	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0698					RANGE_ERR
.3a0698	08		php		            PHP
.3a0699	c2 20		rep #$20	            REP #$20
.3a069b	48		pha		            PHA
.3a069c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a069f	5b		tcd		            TCD
.3a06a0	68		pla		            PLA
.3a06a1	28		plp		            PLP
.3a06a2	e2 20		sep #$20	            SEP #$20
.3a06a4	a9 09		lda #$09	            LDA #ERR_RANGE
.3a06a6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06aa	c2 20		rep #$20	            REP #$20
.3a06ac	29 ff 00	and #$00ff	            AND #$00FF
.3a06af	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a06b2	e2 20		sep #$20	            SEP #$20
.3a06b4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06b7					ASS_ARG1_BYTE
.3a06b7	08		php		                PHP
.3a06b8	e2 20		sep #$20	            SEP #$20
.3a06ba	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a06bc	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a06be	f0 07		beq $3a06c7	                BEQ check_range         ; If so: check the range
.3a06c0	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a06c2	d0 11		bne $3a06d5	                BNE TYPE_ERR            ; If not: throw an error
.3a06c4	20 b1 5a	jsr $3a5ab1	            JSR FTOI
.3a06c7	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.3a06c9	d0 29		bne $3a06f4	                BNE RANGE_ERR           ; If not... throw a range error
.3a06cb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a06cd	d0 25		bne $3a06f4	                BNE RANGE_ERR
.3a06cf	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a06d1	d0 21		bne $3a06f4	                BNE RANGE_ERR
.3a06d3	28		plp		                PLP
.3a06d4	60		rts		            RTS
.3a06d5					TYPE_ERR
.3a06d5	08		php		            PHP
.3a06d6	c2 20		rep #$20	            REP #$20
.3a06d8	48		pha		            PHA
.3a06d9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06dc	5b		tcd		            TCD
.3a06dd	68		pla		            PLA
.3a06de	28		plp		            PLP
.3a06df	e2 20		sep #$20	            SEP #$20
.3a06e1	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06e3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06e7	c2 20		rep #$20	            REP #$20
.3a06e9	29 ff 00	and #$00ff	            AND #$00FF
.3a06ec	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a06ef	e2 20		sep #$20	            SEP #$20
.3a06f1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06f4					RANGE_ERR
.3a06f4	08		php		            PHP
.3a06f5	c2 20		rep #$20	            REP #$20
.3a06f7	48		pha		            PHA
.3a06f8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06fb	5b		tcd		            TCD
.3a06fc	68		pla		            PLA
.3a06fd	28		plp		            PLP
.3a06fe	e2 20		sep #$20	            SEP #$20
.3a0700	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0702	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0706	c2 20		rep #$20	            REP #$20
.3a0708	29 ff 00	and #$00ff	            AND #$00FF
.3a070b	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a070e	e2 20		sep #$20	            SEP #$20
.3a0710	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0713					ASS_ARG1_FLOAT
.3a0713	08		php		                PHP
.3a0714	e2 20		sep #$20	            SEP #$20
.3a0716	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.3a0718	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a071a	f0 26		beq $3a0742	                BEQ done                ; Then we're done
.3a071c	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a071e	f0 1f		beq $3a073f	                BEQ cast                ; Then cast it to float
.3a0720					type_err
.3a0720	08		php		            PHP
.3a0721	c2 20		rep #$20	            REP #$20
.3a0723	48		pha		            PHA
.3a0724	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0727	5b		tcd		            TCD
.3a0728	68		pla		            PLA
.3a0729	28		plp		            PLP
.3a072a	e2 20		sep #$20	            SEP #$20
.3a072c	a9 04		lda #$04	            LDA #ERR_TYPE
.3a072e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0732	c2 20		rep #$20	            REP #$20
.3a0734	29 ff 00	and #$00ff	            AND #$00FF
.3a0737	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a073a	e2 20		sep #$20	            SEP #$20
.3a073c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a073f					cast
.3a073f	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a0742	28		plp		done            PLP
.3a0743	60		rts		            RTS
.3a0744					ASS_ARG2_FLOAT
.3a0744	08		php		                PHP
.3a0745	e2 20		sep #$20	            SEP #$20
.3a0747	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.3a0749	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a074b	f0 26		beq $3a0773	                BEQ done                ; Then we're done
.3a074d	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a074f	f0 1f		beq $3a0770	                BEQ cast                ; Then cast it to float
.3a0751					type_err
.3a0751	08		php		            PHP
.3a0752	c2 20		rep #$20	            REP #$20
.3a0754	48		pha		            PHA
.3a0755	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0758	5b		tcd		            TCD
.3a0759	68		pla		            PLA
.3a075a	28		plp		            PLP
.3a075b	e2 20		sep #$20	            SEP #$20
.3a075d	a9 04		lda #$04	            LDA #ERR_TYPE
.3a075f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0763	c2 20		rep #$20	            REP #$20
.3a0765	29 ff 00	and #$00ff	            AND #$00FF
.3a0768	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a076b	e2 20		sep #$20	            SEP #$20
.3a076d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0770					cast
.3a0770	20 75 07	jsr $3a0775	            JSR CAST_ARG2_FLOAT
.3a0773	28		plp		done            PLP
.3a0774	60		rts		            RTS
.3a0775					CAST_ARG2_FLOAT
.3a0775	c2 20		rep #$20	            REP #$20
.3a0777	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0779	48		pha		            PHA
.3a077a	a5 23		lda $0823	            LDA ARGUMENT1
.3a077c	48		pha		            PHA
.3a077d	c2 20		rep #$20	            REP #$20
.3a077f	a5 29		lda $0829	            LDA ARGUMENT2
.3a0781	85 23		sta $0823	            STA ARGUMENT1
.3a0783	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a0785	85 25		sta $0825	            STA ARGUMENT1+2
.3a0787	e2 20		sep #$20	            SEP #$20
.3a0789	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a078b	85 27		sta $0827	            STA ARGTYPE1
.3a078d	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a0790	c2 20		rep #$20	            REP #$20
.3a0792	a5 23		lda $0823	            LDA ARGUMENT1
.3a0794	85 29		sta $0829	            STA ARGUMENT2
.3a0796	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0798	85 2b		sta $082b	            STA ARGUMENT2+2
.3a079a	e2 20		sep #$20	            SEP #$20
.3a079c	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a079e	85 2d		sta $082d	            STA ARGTYPE2
.3a07a0	c2 20		rep #$20	            REP #$20
.3a07a2	68		pla		            PLA
.3a07a3	85 23		sta $0823	            STA ARGUMENT1
.3a07a5	68		pla		            PLA
.3a07a6	85 25		sta $0825	            STA ARGUMENT1+2
.3a07a8	60		rts		            RTS
.3a07a9					ASS_ARGS_NUM
.3a07a9	08		php		                PHP
.3a07aa	e2 20		sep #$20	            SEP #$20
.3a07ac	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.3a07ae	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a07b0	f0 23		beq $3a07d5	                BEQ arg1_int
.3a07b2	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a07b4	f0 2e		beq $3a07e4	                BEQ arg1_float
.3a07b6					type_err
.3a07b6	08		php		            PHP
.3a07b7	c2 20		rep #$20	            REP #$20
.3a07b9	48		pha		            PHA
.3a07ba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a07bd	5b		tcd		            TCD
.3a07be	68		pla		            PLA
.3a07bf	28		plp		            PLP
.3a07c0	e2 20		sep #$20	            SEP #$20
.3a07c2	a9 04		lda #$04	            LDA #ERR_TYPE
.3a07c4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07c8	c2 20		rep #$20	            REP #$20
.3a07ca	29 ff 00	and #$00ff	            AND #$00FF
.3a07cd	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a07d0	e2 20		sep #$20	            SEP #$20
.3a07d2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07d5	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.3a07d7	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.3a07d9	f0 16		beq $3a07f1	                BEQ done
.3a07db	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.3a07dd	d0 d7		bne $3a07b6	                BNE type_err
.3a07df	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a07e2	80 0d		bra $3a07f1	                BRA done
.3a07e4	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.3a07e6	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.3a07e8	f0 07		beq $3a07f1	                BEQ done                    ; Then we're done
.3a07ea	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.3a07ec	d0 c8		bne $3a07b6	                BNE type_err                ; Thrown an error
.3a07ee	20 75 07	jsr $3a0775	            JSR CAST_ARG2_FLOAT
.3a07f1					done
.3a07f1	e2 20		sep #$20	            SEP #$20
.3a07f3	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.3a07f5	28		plp		                PLP
.3a07f6	60		rts		            RTS
.3a07f7					ASS_ARGS_NUMSTR
.3a07f7	08		php		                PHP
.3a07f8	e2 20		sep #$20	            SEP #$20
.3a07fa	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.3a07fc	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a07fe	d0 25		bne $3a0825	                BNE numbers
.3a0800	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.3a0802	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a0804	f0 24		beq $3a082a	                BEQ done
.3a0806					TYPE_ERR
.3a0806	08		php		            PHP
.3a0807	c2 20		rep #$20	            REP #$20
.3a0809	48		pha		            PHA
.3a080a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a080d	5b		tcd		            TCD
.3a080e	68		pla		            PLA
.3a080f	28		plp		            PLP
.3a0810	e2 20		sep #$20	            SEP #$20
.3a0812	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0814	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0818	c2 20		rep #$20	            REP #$20
.3a081a	29 ff 00	and #$00ff	            AND #$00FF
.3a081d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a0820	e2 20		sep #$20	            SEP #$20
.3a0822	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0825					numbers
.3a0825	20 a9 07	jsr $3a07a9	            JSR ASS_ARGS_NUM
.3a0828	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.3a082a	28		plp		done            PLP
.3a082b	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.3a082c					PARSEINT
.3a082c	08		php		            PHP
.3a082d	0b		phd		            PHD
.3a082e	08		php		            PHP
.3a082f	c2 20		rep #$20	            REP #$20
.3a0831	48		pha		            PHA
.3a0832	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0835	5b		tcd		            TCD
.3a0836	68		pla		            PLA
.3a0837	28		plp		            PLP
.3a0838	c2 30		rep #$30	            REP #$30
.3a083a	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.3a083c	64 25		stz $0825	            STZ ARGUMENT1+2
.3a083e	e2 20		sep #$20	            SEP #$20
.3a0840	64 27		stz $0827	            STZ ARGTYPE1
.3a0842	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.3a0844	c9 26		cmp #$26	            CMP #'&'
.3a0846	f0 44		beq $3a088c	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.3a0848					loop
.3a0848	e2 20		sep #$20	            SEP #$20
.3a084a	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a084c	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a084f	90 76		bcc $3a08c7	            BCC done            ; No, we're done parsing
.3a0851	20 ce 04	jsr $3a04ce	            JSR MULINT10
.3a0854	38		sec		            SEC                 ; Convert the ASCII code to a number
.3a0855	e9 30		sbc #$30	            SBC #'0'
.3a0857	c2 20		rep #$20	            REP #$20
.3a0859	29 ff 00	and #$00ff	            AND #$00FF
.3a085c	18		clc		            CLC
.3a085d	65 23		adc $0823	            ADC ARGUMENT1
.3a085f	85 23		sta $0823	            STA ARGUMENT1
.3a0861	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0863	69 00 00	adc #$0000	            ADC #0
.3a0866	85 25		sta $0825	            STA ARGUMENT1+2
.3a0868	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a086b	80 db		bra $3a0848	            BRA loop            ; And try to process it
.3a086d					syntaxerr
.3a086d	08		php		            PHP
.3a086e	c2 20		rep #$20	            REP #$20
.3a0870	48		pha		            PHA
.3a0871	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0874	5b		tcd		            TCD
.3a0875	68		pla		            PLA
.3a0876	28		plp		            PLP
.3a0877	e2 20		sep #$20	            SEP #$20
.3a0879	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a087b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a087f	c2 20		rep #$20	            REP #$20
.3a0881	29 ff 00	and #$00ff	            AND #$00FF
.3a0884	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a0887	e2 20		sep #$20	            SEP #$20
.3a0889	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a088c					check_hex
.3a088c	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a088f	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a0891	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.3a0893	f0 04		beq $3a0899	            BEQ parse_hex       ; Yes: skip it and parse hex
.3a0895	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.3a0897	d0 d4		bne $3a086d	            BNE syntaxerr       ; No: throw an error
.3a0899					parse_hex
.3a0899	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a089c					hexloop
.3a089c	e2 20		sep #$20	            SEP #$20
.3a089e	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a08a0	20 60 04	jsr $3a0460	            JSR ISHEX
.3a08a3	90 22		bcc $3a08c7	            BCC done            ; No, we're done parsing
.3a08a5	20 81 04	jsr $3a0481	            JSR HEX2BIN
.3a08a8	c2 20		rep #$20	            REP #$20
.3a08aa	06 23		asl $0823	            ASL ARGUMENT1
.3a08ac	26 25		rol $0825	            ROL ARGUMENT1+2
.3a08ae	06 23		asl $0823	            ASL ARGUMENT1
.3a08b0	26 25		rol $0825	            ROL ARGUMENT1+2
.3a08b2	06 23		asl $0823	            ASL ARGUMENT1
.3a08b4	26 25		rol $0825	            ROL ARGUMENT1+2
.3a08b6	06 23		asl $0823	            ASL ARGUMENT1
.3a08b8	26 25		rol $0825	            ROL ARGUMENT1+2
.3a08ba	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.3a08bd	18		clc		            CLC
.3a08be	65 23		adc $0823	            ADC ARGUMENT1
.3a08c0	85 23		sta $0823	            STA ARGUMENT1
.3a08c2	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a08c5	80 d5		bra $3a089c	            BRA hexloop         ; And try to process it
.3a08c7	2b		pld		done        PLD
.3a08c8	28		plp		            PLP
.3a08c9	60		rts		            RTS
.3a08ca					PREVCHAR
.3a08ca	08		php		            PHP
.3a08cb	c2 30		rep #$30	            REP #$30
.3a08cd	a5 04		lda $0804	            LDA BIPPREV
.3a08cf	f0 1c		beq $3a08ed	            BEQ ret_false
.3a08d1	38		sec		            SEC
.3a08d2	a5 04		lda $0804	            LDA BIPPREV
.3a08d4	e5 1a		sbc $081a	            SBC CURLINE
.3a08d6	a8		tay		            TAY
.3a08d7	e2 20		sep #$20	            SEP #$20
.3a08d9	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.3a08db	f0 10		beq $3a08ed	            BEQ ret_false
.3a08dd	c9 20		cmp #$20	            CMP #CHAR_SP
.3a08df	f0 06		beq $3a08e7	            BEQ go_back
.3a08e1	c9 09		cmp #$09	            CMP #CHAR_TAB
.3a08e3	f0 02		beq $3a08e7	            BEQ go_back
.3a08e5	28		plp		            PLP
.3a08e6	60		rts		            RTS
.3a08e7	88		dey		go_back     DEY
.3a08e8	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.3a08eb	d0 ec		bne $3a08d9	            BNE loop
.3a08ed					ret_false
.3a08ed	a9 00		lda #$00	            LDA #0
.3a08ef	60		rts		            RTS
.3a08f0					TOKENIZE
.3a08f0	08		php		            PHP
.3a08f1	0b		phd		            PHD
.3a08f2	08		php		            PHP
.3a08f3	c2 20		rep #$20	            REP #$20
.3a08f5	48		pha		            PHA
.3a08f6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a08f9	5b		tcd		            TCD
.3a08fa	68		pla		            PLA
.3a08fb	28		plp		            PLP
.3a08fc	c2 30		rep #$30	            REP #$30
.3a08fe	a5 1a		lda $081a	            LDA CURLINE
.3a0900	85 00		sta $0800	            STA BIP
.3a0902	e2 20		sep #$20	            SEP #$20
.3a0904	a5 1c		lda $081c	            LDA CURLINE+2
.3a0906	85 02		sta $0802	            STA BIP+2
.3a0908	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a090b	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.3a090d	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a0910	90 0c		bcc $3a091e	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.3a0912	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a0915	c2 20		rep #$20	            REP #$20
.3a0917	a5 23		lda $0823	            LDA ARGUMENT1
.3a0919	85 d7		sta $08d7	            STA LINENUM
.3a091b	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a091e					mv_curline
.3a091e	c2 20		rep #$20	            REP #$20
.3a0920	a5 00		lda $0800	            LDA BIP
.3a0922	85 1a		sta $081a	            STA CURLINE
.3a0924	e2 20		sep #$20	            SEP #$20
.3a0926	a5 02		lda $0802	            LDA BIP+2
.3a0928	85 1c		sta $081c	            STA CURLINE+2
.3a092a	20 3e 09	jsr $3a093e	            JSR FINDREM
.3a092d	e2 20		sep #$20	            SEP #$20
.3a092f					loop
.3a092f	20 af 09	jsr $3a09af	            JSR TKFINDTOKEN
.3a0932	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.3a0934	f0 05		beq $3a093b	            BEQ done                ; No: return
.3a0936	20 5d 0b	jsr $3a0b5d	            JSR TKWRITE
.3a0939	80 f4		bra $3a092f	            BRA loop                ; And try again
.3a093b	2b		pld		done        PLD
.3a093c	28		plp		            PLP
.3a093d	60		rts		            RTS
.3a093e					FINDREM
.3a093e	08		php		            PHP
.3a093f	c2 20		rep #$20	            REP #$20
.3a0941	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.3a0943	85 00		sta $0800	            STA BIP
.3a0945	a5 1c		lda $081c	            LDA CURLINE+2
.3a0947	85 02		sta $0802	            STA BIP+2
.3a0949	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.3a094c	e2 20		sep #$20	            SEP #$20
.3a094e	a0 00 00	ldy #$0000	loop        LDY #0
.3a0951	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.3a0954	f0 0d		beq $3a0963	            BEQ skip_delim          ; ... skip looking for a delimiter
.3a0956	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0958	f0 53		beq $3a09ad	            BEQ done                ; Is it null? Then we're done
.3a095a	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.3a095c	f0 04		beq $3a0962	            BEQ found_delim         ; Yes: we might have a REM... look for E
.3a095e	c9 20		cmp #$20	            CMP #CHAR_SP
.3a0960	d0 33		bne $3a0995	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0962	c8		iny		found_delim INY
.3a0963	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.3a0965	f0 46		beq $3a09ad	            BEQ done                ; Is it null? Then we're done
.3a0967	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a0969	f0 10		beq $3a097b	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a096b	c9 72		cmp #$72	            CMP #'r'
.3a096d	d0 26		bne $3a0995	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a096f	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0971	f0 3a		beq $3a09ad	            BEQ done                ; Is it null? Then we're done
.3a0973	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a0975	f0 04		beq $3a097b	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a0977	c9 72		cmp #$72	            CMP #'r'
.3a0979	d0 1a		bne $3a0995	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a097b	c8		iny		found_R     INY
.3a097c	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a097e	f0 2d		beq $3a09ad	            BEQ done                ; Is it null? Then we're done
.3a0980	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.3a0982	f0 04		beq $3a0988	            BEQ found_E             ; Yes: we might have a REM... look for M
.3a0984	c9 65		cmp #$65	            CMP #'e'
.3a0986	d0 0d		bne $3a0995	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0988	c8		iny		found_E     INY
.3a0989	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a098b	f0 20		beq $3a09ad	            BEQ done                ; Is it null? Then we're done
.3a098d	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.3a098f	f0 0a		beq $3a099b	            BEQ found_REM           ; Yes: we might have a REM... look for M
.3a0991	c9 6d		cmp #$6d	            CMP #'m'
.3a0993	f0 06		beq $3a099b	            BEQ found_REM
.3a0995	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.3a0996	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a0999	80 b3		bra $3a094e	            BRA loop
.3a099b	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.3a099d	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.3a099f	d0 03		bne $3a09a4	            BNE ret_REM             ; No: go ahead and return REM at that location
.3a09a1	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a09a4	a9 03		lda #$03	ret_REM     LDA #3
.3a09a6	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.3a09a8	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.3a09aa	20 5d 0b	jsr $3a0b5d	            JSR TKWRITE
.3a09ad	28		plp		done        PLP
.3a09ae	60		rts		            RTS
.3a09af					TKFINDTOKEN
.3a09af	08		php		            PHP
.3a09b0	0b		phd		            PHD
.3a09b1	08		php		            PHP
.3a09b2	c2 20		rep #$20	            REP #$20
.3a09b4	48		pha		            PHA
.3a09b5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a09b8	5b		tcd		            TCD
.3a09b9	68		pla		            PLA
.3a09ba	28		plp		            PLP
.3a09bb	e2 20		sep #$20	            SEP #$20
.3a09bd	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.3a09bf	85 1e		sta $081e	            STA CURTOKLEN
.3a09c1					next_size
.3a09c1	c2 10		rep #$10	            REP #$10
.3a09c3	20 12 0b	jsr $3a0b12	            JSR TKNEXTBIG
.3a09c6	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.3a09c8	d0 03		bne $3a09cd	            BNE else
.3a09ca	4c 52 0a	jmp $3a0a52	            JMP done                ; No: return to caller
.3a09cd					else
.3a09cd	c2 20		rep #$20	            REP #$20
.3a09cf	a5 1a		lda $081a	            LDA CURLINE
.3a09d1	85 00		sta $0800	            STA BIP
.3a09d3	e2 20		sep #$20	            SEP #$20
.3a09d5	a5 1c		lda $081c	            LDA CURLINE+2
.3a09d7	85 02		sta $0802	            STA BIP+2
.3a09d9	c2 20		rep #$20	            REP #$20
.3a09db	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.3a09dd	64 06		stz $0806	            STZ BIPPREV+2
.3a09df					check_len
.3a09df	e2 30		sep #$30	            SEP #$30
.3a09e1	a0 00		ldy #$00	            LDY #0
.3a09e3	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.3a09e5	f0 da		beq $3a09c1	            BEQ next_size
.3a09e7	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.3a09e9	f0 d6		beq $3a09c1	            BEQ next_size
.3a09eb	c8		iny		            INY
.3a09ec	c4 1e		cpy $081e	            CPY CURTOKLEN
.3a09ee	90 f3		bcc $3a09e3	            BCC nul_scan
.3a09f0	c2 10		rep #$10	            REP #$10
.3a09f2	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.3a09f4	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a09f6	d0 05		bne $3a09fd	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.3a09f8	20 74 0a	jsr $3a0a74	            JSR SKIPQUOTED
.3a09fb	80 28		bra $3a0a25	            BRA go_next             ; And move on to the next character
.3a09fd	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.3a09ff	c9 03		cmp #$03	            CMP #3
.3a0a01	90 19		bcc $3a0a1c	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.3a0a03	c2 20		rep #$20	            REP #$20
.3a0a05	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.3a0a07	c5 1a		cmp $081a	            CMP CURLINE
.3a0a09	d0 08		bne $3a0a13	            BNE chk_delim           ; No: we need to check for a delimiters
.3a0a0b	e2 20		sep #$20	            SEP #$20
.3a0a0d	a5 02		lda $0802	            LDA BIP+2
.3a0a0f	c5 1c		cmp $081c	            CMP CURLINE+2
.3a0a11	f0 09		beq $3a0a1c	            BEQ try_match           ; Yes: this can be a keyword
.3a0a13					chk_delim
.3a0a13	e2 20		sep #$20	            SEP #$20
.3a0a15	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0a17	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a0a1a	b0 09		bcs $3a0a25	            BCS go_next             ; Yes: we can't start a keyword here
.3a0a1c					try_match
.3a0a1c	e2 20		sep #$20	            SEP #$20
.3a0a1e	20 84 0a	jsr $3a0a84	            JSR TKMATCH
.3a0a21	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.3a0a23	d0 11		bne $3a0a36	            BNE found               ; Yes: return it
.3a0a25					go_next
.3a0a25	c2 20		rep #$20	            REP #$20
.3a0a27	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.3a0a29	85 04		sta $0804	            STA BIPPREV
.3a0a2b	e2 20		sep #$20	            SEP #$20
.3a0a2d	a5 02		lda $0802	            LDA BIP+2
.3a0a2f	85 06		sta $0806	            STA BIPPREV+2
.3a0a31	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a0a34	80 a9		bra $3a09df	            BRA check_len           ; And try there
.3a0a36					found
.3a0a36	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.3a0a38	d0 18		bne $3a0a52	            BNE done                ; Nope: go ahead and return it
.3a0a3a	20 ca 08	jsr $3a08ca	            JSR PREVCHAR
.3a0a3d	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.3a0a3f	f0 14		beq $3a0a55	            BEQ syntax              ; No: line cannot start with minus... throw error
.3a0a41	89 80		bit #$80	            BIT #$80                ; Is it a token?
.3a0a43	10 0b		bpl $3a0a50	            BPL binaryminus         ; No: leave token unchanged
.3a0a45	20 fe 0b	jsr $3a0bfe	            JSR TOKTYPE
.3a0a48	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.3a0a4a	f0 04		beq $3a0a50	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.3a0a4c	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.3a0a4e	80 02		bra $3a0a52	            BRA done
.3a0a50	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.3a0a52					done
.3a0a52	2b		pld		            PLD
.3a0a53	28		plp		            PLP
.3a0a54	60		rts		            RTS
.3a0a55					syntax
.3a0a55	08		php		            PHP
.3a0a56	c2 20		rep #$20	            REP #$20
.3a0a58	48		pha		            PHA
.3a0a59	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0a5c	5b		tcd		            TCD
.3a0a5d	68		pla		            PLA
.3a0a5e	28		plp		            PLP
.3a0a5f	e2 20		sep #$20	            SEP #$20
.3a0a61	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a0a63	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0a67	c2 20		rep #$20	            REP #$20
.3a0a69	29 ff 00	and #$00ff	            AND #$00FF
.3a0a6c	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a0a6f	e2 20		sep #$20	            SEP #$20
.3a0a71	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0a74					SKIPQUOTED
.3a0a74	08		php		            PHP
.3a0a75	e2 20		sep #$20	            SEP #$20
.3a0a77					loop
.3a0a77	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a0a7a	a7 00		lda [$0800]	            LDA [BIP]
.3a0a7c	f0 04		beq $3a0a82	            BEQ done                ; If EOL, just return
.3a0a7e	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0a80	d0 f5		bne $3a0a77	            BNE loop                ; No: keep skipping
.3a0a82	28		plp		done        PLP
.3a0a83	60		rts		            RTS
.3a0a84					TKMATCH
.3a0a84	da		phx		            PHX
.3a0a85	5a		phy		            PHY
.3a0a86	08		php		            PHP
.3a0a87	0b		phd		            PHD
.3a0a88	08		php		            PHP
.3a0a89	c2 20		rep #$20	            REP #$20
.3a0a8b	48		pha		            PHA
.3a0a8c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0a8f	5b		tcd		            TCD
.3a0a90	68		pla		            PLA
.3a0a91	28		plp		            PLP
.3a0a92	c2 20		rep #$20	            REP #$20
.3a0a94	a5 04		lda $0804	            LDA BIPPREV
.3a0a96	d0 0a		bne $3a0aa2	            BNE check_prev
.3a0a98	e2 20		sep #$20	            SEP #$20
.3a0a9a	a5 04		lda $0804	            LDA BIPPREV
.3a0a9c	d0 04		bne $3a0aa2	            BNE check_prev
.3a0a9e	a9 00		lda #$00	            LDA #0
.3a0aa0	80 0a		bra $3a0aac	            BRA save_delim
.3a0aa2					check_prev
.3a0aa2	e2 20		sep #$20	            SEP #$20
.3a0aa4	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0aa6	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a0aa9	a9 00		lda #$00	            LDA #0
.3a0aab	2a		rol a		            ROL A
.3a0aac	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.3a0aae	c2 30		rep #$30	            REP #$30
.3a0ab0	a9 52 0c	lda #$0c52	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.3a0ab3	85 08		sta $0808	            STA INDEX
.3a0ab5	e2 20		sep #$20	            SEP #$20
.3a0ab7	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0ab9	85 0a		sta $080a	            STA INDEX+2
.3a0abb	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.3a0abe					token_loop
.3a0abe	e2 20		sep #$20	            SEP #$20
.3a0ac0	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0ac3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.3a0ac5	f0 31		beq $3a0af8	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.3a0ac7	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.3a0ac9	d0 32		bne $3a0afd	            BNE next_token          ; No: try the next token
.3a0acb	c2 30		rep #$30	            REP #$30
.3a0acd	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a0ad0	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.3a0ad2	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.3a0ad4	e2 20		sep #$20	            SEP #$20
.3a0ad6	a9 3a		lda #$3a	            LDA #`DATA_BLOCK
.3a0ad8	85 0e		sta $080e	            STA SCRATCH+2
.3a0ada	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.3a0adc	f0 07		beq $3a0ae5	            BEQ cmp_keyword         ; No: we can check for this token
.3a0ade	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.3a0ae0	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a0ae3	b0 18		bcs $3a0afd	            BCS next_token          ; Yes: skip this token
.3a0ae5					cmp_keyword
.3a0ae5	e2 10		sep #$10	            SEP #$10
.3a0ae7	a0 00		ldy #$00	            LDY #0
.3a0ae9	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.3a0aeb	20 aa 04	jsr $3a04aa	            JSR TOUPPERA
.3a0aee	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.3a0af0	d0 0b		bne $3a0afd	            BNE next_token          ; If they don't match, try the next token
.3a0af2	c8		iny		            INY                     ; Move to the next character in the window
.3a0af3	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.3a0af5	90 f2		bcc $3a0ae9	            BCC cmp_loop            ; No: check this next character
.3a0af7	8a		txa		            TXA                     ; Move the token ID to A
.3a0af8	2b		pld		no_match    PLD
.3a0af9	28		plp		            PLP
.3a0afa	7a		ply		            PLY
.3a0afb	fa		plx		            PLX
.3a0afc	60		rts		            RTS
.3a0afd					next_token
.3a0afd	c2 30		rep #$30	            REP #$30
.3a0aff	18		clc		            CLC
.3a0b00	a5 08		lda $0808	            LDA INDEX
.3a0b02	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0b05	85 08		sta $0808	            STA INDEX
.3a0b07	e2 20		sep #$20	            SEP #$20
.3a0b09	a5 0a		lda $080a	            LDA INDEX+2
.3a0b0b	69 00		adc #$00	            ADC #0
.3a0b0d	85 0a		sta $080a	            STA INDEX+2
.3a0b0f	e8		inx		            INX                     ; Increment the token ID
.3a0b10	80 ac		bra $3a0abe	            BRA token_loop          ; And check that token
.3a0b12					TKNEXTBIG
.3a0b12	08		php		            PHP
.3a0b13	0b		phd		            PHD
.3a0b14	8b		phb		            PHB
.3a0b15	08		php		            PHP
.3a0b16	c2 20		rep #$20	            REP #$20
.3a0b18	48		pha		            PHA
.3a0b19	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b1c	5b		tcd		            TCD
.3a0b1d	68		pla		            PLA
.3a0b1e	28		plp		            PLP
.3a0b1f	c2 30		rep #$30	            REP #$30
.3a0b21	a9 52 0c	lda #$0c52	            LDA #<>TOKENS
.3a0b24	85 08		sta $0808	            STA INDEX
.3a0b26	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a0b29	85 0a		sta $080a	            STA INDEX+2
.3a0b2b	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.3a0b2d					loop
.3a0b2d	e2 20		sep #$20	            SEP #$20
.3a0b2f	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0b32	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.3a0b34	f0 1d		beq $3a0b53	            BEQ done                ; If length is 0, we're done
.3a0b36	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.3a0b38	b0 06		bcs $3a0b40	            BGE skip                ; Yes: skip to the next token
.3a0b3a	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.3a0b3c	90 02		bcc $3a0b40	            BLT skip                ; Yes: skip to the next token
.3a0b3e	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.3a0b40					skip
.3a0b40	c2 20		rep #$20	            REP #$20
.3a0b42	18		clc		            CLC
.3a0b43	a5 08		lda $0808	            LDA INDEX
.3a0b45	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0b48	85 08		sta $0808	            STA INDEX
.3a0b4a	a5 0a		lda $080a	            LDA INDEX+2
.3a0b4c	69 00 00	adc #$0000	            ADC #0
.3a0b4f	85 0a		sta $080a	            STA INDEX+2
.3a0b51	80 da		bra $3a0b2d	            BRA loop                ; And go around for another pass
.3a0b53					done
.3a0b53	e2 20		sep #$20	            SEP #$20
.3a0b55	a5 0c		lda $080c	            LDA SCRATCH
.3a0b57	85 1e		sta $081e	            STA CURTOKLEN
.3a0b59	ab		plb		            PLB
.3a0b5a	2b		pld		            PLD
.3a0b5b	28		plp		            PLP
.3a0b5c	60		rts		            RTS
.3a0b5d					TKWRITE
.3a0b5d	08		php		            PHP
.3a0b5e	0b		phd		            PHD
.3a0b5f	08		php		            PHP
.3a0b60	c2 20		rep #$20	            REP #$20
.3a0b62	48		pha		            PHA
.3a0b63	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b66	5b		tcd		            TCD
.3a0b67	68		pla		            PLA
.3a0b68	28		plp		            PLP
.3a0b69	e2 20		sep #$20	            SEP #$20
.3a0b6b	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.3a0b6d	c2 20		rep #$20	            REP #$20
.3a0b6f	18		clc		            CLC
.3a0b70	a5 00		lda $0800	            LDA BIP
.3a0b72	69 01 00	adc #$0001	            ADC #1
.3a0b75	85 08		sta $0808	            STA INDEX
.3a0b77	a5 02		lda $0802	            LDA BIP+2
.3a0b79	69 00 00	adc #$0000	            ADC #0
.3a0b7c	85 0a		sta $080a	            STA INDEX+2
.3a0b7e	e2 10		sep #$10	            SEP #$10
.3a0b80	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.3a0b82	88		dey		            DEY
.3a0b83					copy_down
.3a0b83	e2 20		sep #$20	            SEP #$20
.3a0b85	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.3a0b87	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.3a0b89	f0 13		beq $3a0b9e	            BEQ done                ; We've reached the end of the line
.3a0b8b	c2 20		rep #$20	            REP #$20
.3a0b8d	18		clc		            CLC
.3a0b8e	a5 08		lda $0808	            LDA INDEX
.3a0b90	69 01 00	adc #$0001	            ADC #1
.3a0b93	85 08		sta $0808	            STA INDEX
.3a0b95	a5 0a		lda $080a	            LDA INDEX+2
.3a0b97	69 00 00	adc #$0000	            ADC #0
.3a0b9a	85 0a		sta $080a	            STA INDEX+2
.3a0b9c	80 e5		bra $3a0b83	            BRA copy_down
.3a0b9e	2b		pld		done        PLD
.3a0b9f	28		plp		            PLP
.3a0ba0	60		rts		            RTS
.3a0ba1					GETTOKREC
.3a0ba1	08		php		            PHP
.3a0ba2	c2 30		rep #$30	            REP #$30
.3a0ba4	29 7f 00	and #$007f	            AND #$007F
.3a0ba7	0a		asl a		            ASL A
.3a0ba8	0a		asl a		            ASL A
.3a0ba9	0a		asl a		            ASL A
.3a0baa	18		clc		            CLC
.3a0bab	69 52 0c	adc #$0c52	            ADC #<>TOKENS
.3a0bae	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.3a0baf	28		plp		            PLP
.3a0bb0	60		rts		            RTS
.3a0bb1					TOKPRECED
.3a0bb1	08		php		            PHP
.3a0bb2	8b		phb		            PHB
.3a0bb3	0b		phd		            PHD
.3a0bb4	08		php		            PHP
.3a0bb5	c2 20		rep #$20	            REP #$20
.3a0bb7	48		pha		            PHA
.3a0bb8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0bbb	5b		tcd		            TCD
.3a0bbc	68		pla		            PLA
.3a0bbd	28		plp		            PLP
.3a0bbe	08		php		            PHP
.3a0bbf	e2 20		sep #$20	            SEP #$20
.3a0bc1	48		pha		            PHA
.3a0bc2	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0bc4	48		pha		            PHA
.3a0bc5	ab		plb		            PLB
.3a0bc6	68		pla		            PLA
.3a0bc7	28		plp		            PLP
.3a0bc8	e2 20		sep #$20	            SEP #$20
.3a0bca	c2 10		rep #$10	            REP #$10
.3a0bcc	20 a1 0b	jsr $3a0ba1	            JSR GETTOKREC
.3a0bcf	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0bd2	c2 20		rep #$20	            REP #$20
.3a0bd4	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.3a0bd7	2b		pld		            PLD
.3a0bd8	ab		plb		            PLB
.3a0bd9	28		plp		            PLP
.3a0bda	60		rts		            RTS
.3a0bdb					TOKEVAL
.3a0bdb	08		php		            PHP
.3a0bdc	8b		phb		            PHB
.3a0bdd	0b		phd		            PHD
.3a0bde	08		php		            PHP
.3a0bdf	c2 20		rep #$20	            REP #$20
.3a0be1	48		pha		            PHA
.3a0be2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0be5	5b		tcd		            TCD
.3a0be6	68		pla		            PLA
.3a0be7	28		plp		            PLP
.3a0be8	08		php		            PHP
.3a0be9	e2 20		sep #$20	            SEP #$20
.3a0beb	48		pha		            PHA
.3a0bec	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0bee	48		pha		            PHA
.3a0bef	ab		plb		            PLB
.3a0bf0	68		pla		            PLA
.3a0bf1	28		plp		            PLP
.3a0bf2	c2 30		rep #$30	            REP #$30
.3a0bf4	20 a1 0b	jsr $3a0ba1	            JSR GETTOKREC
.3a0bf7	bd 04 00	lda $3a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.3a0bfa	2b		pld		            PLD
.3a0bfb	ab		plb		            PLB
.3a0bfc	28		plp		            PLP
.3a0bfd	60		rts		            RTS
.3a0bfe					TOKTYPE
.3a0bfe	08		php		            PHP
.3a0bff	8b		phb		            PHB
.3a0c00	0b		phd		            PHD
.3a0c01	08		php		            PHP
.3a0c02	c2 20		rep #$20	            REP #$20
.3a0c04	48		pha		            PHA
.3a0c05	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c08	5b		tcd		            TCD
.3a0c09	68		pla		            PLA
.3a0c0a	28		plp		            PLP
.3a0c0b	08		php		            PHP
.3a0c0c	e2 20		sep #$20	            SEP #$20
.3a0c0e	48		pha		            PHA
.3a0c0f	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c11	48		pha		            PHA
.3a0c12	ab		plb		            PLB
.3a0c13	68		pla		            PLA
.3a0c14	28		plp		            PLP
.3a0c15	e2 20		sep #$20	            SEP #$20
.3a0c17	c2 10		rep #$10	            REP #$10
.3a0c19	20 a1 0b	jsr $3a0ba1	            JSR GETTOKREC
.3a0c1c	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0c1f	c2 20		rep #$20	            REP #$20
.3a0c21	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.3a0c24	2b		pld		            PLD
.3a0c25	ab		plb		            PLB
.3a0c26	28		plp		            PLP
.3a0c27	60		rts		            RTS
.3a0c28					TOKARITY
.3a0c28	08		php		            PHP
.3a0c29	8b		phb		            PHB
.3a0c2a	0b		phd		            PHD
.3a0c2b	08		php		            PHP
.3a0c2c	c2 20		rep #$20	            REP #$20
.3a0c2e	48		pha		            PHA
.3a0c2f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c32	5b		tcd		            TCD
.3a0c33	68		pla		            PLA
.3a0c34	28		plp		            PLP
.3a0c35	08		php		            PHP
.3a0c36	e2 20		sep #$20	            SEP #$20
.3a0c38	48		pha		            PHA
.3a0c39	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c3b	48		pha		            PHA
.3a0c3c	ab		plb		            PLB
.3a0c3d	68		pla		            PLA
.3a0c3e	28		plp		            PLP
.3a0c3f	e2 20		sep #$20	            SEP #$20
.3a0c41	c2 10		rep #$10	            REP #$10
.3a0c43	20 a1 0b	jsr $3a0ba1	            JSR GETTOKREC
.3a0c46	bd 06 00	lda $3a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.3a0c49	c2 20		rep #$20	            REP #$20
.3a0c4b	29 ff 00	and #$00ff	            AND #$00FF
.3a0c4e	2b		pld		            PLD
.3a0c4f	ab		plb		            PLB
.3a0c50	28		plp		            PLP
.3a0c51	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.3a0c52					TOKENS
=$80					TOK_PLUS = $80
>3ad010	2b 00				TOKEN_TEXT  .null "+"
>3a0c52	03				precedence  .byte TOK_TY_OP | 3
>3a0c53	01				length      .byte len("+")
>3a0c54	10 d0				name        .word <>TOKEN_TEXT
>3a0c56	32 27				eval        .word <>OP_PLUS
>3a0c58	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>3ad012	2d 00				TOKEN_TEXT  .null "-"
>3a0c5a	03				precedence  .byte TOK_TY_OP | 3
>3a0c5b	01				length      .byte len("-")
>3a0c5c	12 d0				name        .word <>TOKEN_TEXT
>3a0c5e	72 27				eval        .word <>OP_MINUS
>3a0c60	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>3ad014	2a 00				TOKEN_TEXT  .null "*"
>3a0c62	02				precedence  .byte TOK_TY_OP | 2
>3a0c63	01				length      .byte len("*")
>3a0c64	14 d0				name        .word <>TOKEN_TEXT
>3a0c66	a9 27				eval        .word <>OP_MULTIPLY
>3a0c68	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>3ad016	2f 00				TOKEN_TEXT  .null "/"
>3a0c6a	02				precedence  .byte TOK_TY_OP | 2
>3a0c6b	01				length      .byte len("/")
>3a0c6c	16 d0				name        .word <>TOKEN_TEXT
>3a0c6e	e0 27				eval        .word <>OP_DIVIDE
>3a0c70	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>3ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>3a0c72	02				precedence  .byte TOK_TY_OP | 2
>3a0c73	03				length      .byte len("MOD")
>3a0c74	18 d0				name        .word <>TOKEN_TEXT
>3a0c76	ea 27				eval        .word <>OP_MOD
>3a0c78	02 00				arity       .word <>2
>3ad01c	5e 00				TOKEN_TEXT  .null "^"
>3a0c7a	00				precedence  .byte TOK_TY_OP | 0
>3a0c7b	01				length      .byte len("^")
>3a0c7c	1c d0				name        .word <>TOKEN_TEXT
>3a0c7e	fd 27				eval        .word <>OP_POW
>3a0c80	02 00				arity       .word <>2
=$86					TOK_LE = $86
>3ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>3a0c82	04				precedence  .byte TOK_TY_OP | 4
>3a0c83	02				length      .byte len("<=")
>3a0c84	1e d0				name        .word <>TOKEN_TEXT
>3a0c86	bb 29				eval        .word <>OP_LTE
>3a0c88	02 00				arity       .word <>2
=$87					TOK_GE = $87
>3ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>3a0c8a	04				precedence  .byte TOK_TY_OP | 4
>3a0c8b	02				length      .byte len(">=")
>3a0c8c	21 d0				name        .word <>TOKEN_TEXT
>3a0c8e	7b 29				eval        .word <>OP_GTE
>3a0c90	02 00				arity       .word <>2
=$88					TOK_NE = $88
>3ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>3a0c92	04				precedence  .byte TOK_TY_OP | 4
>3a0c93	02				length      .byte len("<>")
>3a0c94	24 d0				name        .word <>TOKEN_TEXT
>3a0c96	3b 29				eval        .word <>OP_NE
>3a0c98	02 00				arity       .word <>2
>3ad027	3c 00				TOKEN_TEXT  .null "<"
>3a0c9a	04				precedence  .byte TOK_TY_OP | 4
>3a0c9b	01				length      .byte len("<")
>3a0c9c	27 d0				name        .word <>TOKEN_TEXT
>3a0c9e	7b 28				eval        .word <>OP_LT
>3a0ca0	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>3ad029	3d 00				TOKEN_TEXT  .null "="
>3a0ca2	04				precedence  .byte TOK_TY_OP | 4
>3a0ca3	01				length      .byte len("=")
>3a0ca4	29 d0				name        .word <>TOKEN_TEXT
>3a0ca6	fb 28				eval        .word <>OP_EQ
>3a0ca8	02 00				arity       .word <>2
>3ad02b	3e 00				TOKEN_TEXT  .null ">"
>3a0caa	04				precedence  .byte TOK_TY_OP | 4
>3a0cab	01				length      .byte len(">")
>3a0cac	2b d0				name        .word <>TOKEN_TEXT
>3a0cae	bb 28				eval        .word <>OP_GT
>3a0cb0	02 00				arity       .word <>2
>3ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>3a0cb2	05				precedence  .byte TOK_TY_OP | 5
>3a0cb3	03				length      .byte len("NOT")
>3a0cb4	2d d0				name        .word <>TOKEN_TEXT
>3a0cb6	65 28				eval        .word <>OP_NOT
>3a0cb8	01 00				arity       .word <>1
>3ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>3a0cba	06				precedence  .byte TOK_TY_OP | 6
>3a0cbb	03				length      .byte len("AND")
>3a0cbc	31 d0				name        .word <>TOKEN_TEXT
>3a0cbe	37 28				eval        .word <>OP_AND
>3a0cc0	02 00				arity       .word <>2
>3ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>3a0cc2	07				precedence  .byte TOK_TY_OP | 7
>3a0cc3	02				length      .byte len("OR")
>3a0cc4	35 d0				name        .word <>TOKEN_TEXT
>3a0cc6	4e 28				eval        .word <>OP_OR
>3a0cc8	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>3ad038	28 00				TOKEN_TEXT  .null "("
>3a0cca	ff				precedence  .byte TOK_TY_PUNCT | $FF
>3a0ccb	01				length      .byte len("(")
>3a0ccc	38 d0				name        .word <>TOKEN_TEXT
>3a0cce	00 00				eval        .word <>0
>3a0cd0	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>3ad03a	29 00				TOKEN_TEXT  .null ")"
>3a0cd2	40				precedence  .byte TOK_TY_PUNCT | 0
>3a0cd3	01				length      .byte len(")")
>3a0cd4	3a d0				name        .word <>TOKEN_TEXT
>3a0cd6	00 00				eval        .word <>0
>3a0cd8	00 00				arity       .word <>0
=$91					TOK_REM = $91
>3ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>3a0cda	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cdb	03				length      .byte len("REM")
>3a0cdc	3c d0				name        .word <>TOKEN_TEXT
>3a0cde	81 40				eval        .word <>S_REM
>3a0ce0	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>3ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>3a0ce2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ce3	05				length      .byte len("PRINT")
>3a0ce4	40 d0				name        .word <>TOKEN_TEXT
>3a0ce6	86 44				eval        .word <>S_PRINT
>3a0ce8	00 00				arity       .word <>0
=$93					TOK_LET = $93
>3ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>3a0cea	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ceb	03				length      .byte len("LET")
>3a0cec	46 d0				name        .word <>TOKEN_TEXT
>3a0cee	d1 43				eval        .word <>S_LET
>3a0cf0	00 00				arity       .word <>0
>3ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>3a0cf2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cf3	04				length      .byte len("GOTO")
>3a0cf4	4a d0				name        .word <>TOKEN_TEXT
>3a0cf6	71 43				eval        .word <>S_GOTO
>3a0cf8	00 00				arity       .word <>0
=$95					TOK_END = $95
>3ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>3a0cfa	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cfb	03				length      .byte len("END")
>3a0cfc	4f d0				name        .word <>TOKEN_TEXT
>3a0cfe	68 43				eval        .word <>S_END
>3a0d00	00 00				arity       .word <>0
>3ad053	49 46 00			TOKEN_TEXT  .null "IF"
>3a0d02	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d03	02				length      .byte len("IF")
>3a0d04	53 d0				name        .word <>TOKEN_TEXT
>3a0d06	00 43				eval        .word <>S_IF
>3a0d08	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>3ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>3a0d0a	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d0b	04				length      .byte len("THEN")
>3a0d0c	56 d0				name        .word <>TOKEN_TEXT
>3a0d0e	00 00				eval        .word <>0
>3a0d10	00 00				arity       .word <>0
>3ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>3a0d12	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d13	04				length      .byte len("ELSE")
>3a0d14	5b d0				name        .word <>TOKEN_TEXT
>3a0d16	00 00				eval        .word <>0
>3a0d18	00 00				arity       .word <>0
>3ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>3a0d1a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d1b	05				length      .byte len("GOSUB")
>3a0d1c	60 d0				name        .word <>TOKEN_TEXT
>3a0d1e	43 42				eval        .word <>S_GOSUB
>3a0d20	00 00				arity       .word <>0
>3ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>3a0d22	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d23	06				length      .byte len("RETURN")
>3a0d24	66 d0				name        .word <>TOKEN_TEXT
>3a0d26	bc 42				eval        .word <>S_RETURN
>3a0d28	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>3ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>3a0d2a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d2b	03				length      .byte len("FOR")
>3a0d2c	6d d0				name        .word <>TOKEN_TEXT
>3a0d2e	98 40				eval        .word <>S_FOR
>3a0d30	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>3ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>3a0d32	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d33	02				length      .byte len("TO")
>3a0d34	71 d0				name        .word <>TOKEN_TEXT
>3a0d36	00 00				eval        .word <>0
>3a0d38	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>3ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>3a0d3a	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d3b	04				length      .byte len("STEP")
>3a0d3c	74 d0				name        .word <>TOKEN_TEXT
>3a0d3e	00 00				eval        .word <>0
>3a0d40	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>3ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>3a0d42	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d43	04				length      .byte len("NEXT")
>3a0d44	79 d0				name        .word <>TOKEN_TEXT
>3a0d46	8c 41				eval        .word <>S_NEXT
>3a0d48	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>3ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>3a0d4a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d4b	02				length      .byte len("DO")
>3a0d4c	7e d0				name        .word <>TOKEN_TEXT
>3a0d4e	92 40				eval        .word <>S_DO
>3a0d50	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>3ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>3a0d52	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d53	04				length      .byte len("LOOP")
>3a0d54	81 d0				name        .word <>TOKEN_TEXT
>3a0d56	95 40				eval        .word <>S_LOOP
>3a0d58	00 00				arity       .word <>0
>3ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>3a0d5a	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d5b	05				length      .byte len("WHILE")
>3a0d5c	86 d0				name        .word <>TOKEN_TEXT
>3a0d5e	00 00				eval        .word <>0
>3a0d60	00 00				arity       .word <>0
>3ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>3a0d62	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d63	05				length      .byte len("UNTIL")
>3a0d64	8c d0				name        .word <>TOKEN_TEXT
>3a0d66	00 00				eval        .word <>0
>3a0d68	00 00				arity       .word <>0
>3ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>3a0d6a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d6b	04				length      .byte len("EXIT")
>3a0d6c	92 d0				name        .word <>TOKEN_TEXT
>3a0d6e	8f 40				eval        .word <>S_EXIT
>3a0d70	00 00				arity       .word <>0
>3ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>3a0d72	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d73	03				length      .byte len("CLR")
>3a0d74	97 d0				name        .word <>TOKEN_TEXT
>3a0d76	c7 43				eval        .word <>S_CLR
>3a0d78	00 00				arity       .word <>0
>3ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>3a0d7a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d7b	04				length      .byte len("STOP")
>3a0d7c	9b d0				name        .word <>TOKEN_TEXT
>3a0d7e	62 40				eval        .word <>S_STOP
>3a0d80	00 00				arity       .word <>0
>3ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>3a0d82	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d83	04				length      .byte len("POKE")
>3a0d84	a0 d0				name        .word <>TOKEN_TEXT
>3a0d86	f2 3f				eval        .word <>S_POKE
>3a0d88	00 00				arity       .word <>0
>3ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>3a0d8a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d8b	05				length      .byte len("POKEW")
>3a0d8c	a5 d0				name        .word <>TOKEN_TEXT
>3a0d8e	88 3f				eval        .word <>S_POKEW
>3a0d90	00 00				arity       .word <>0
>3ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>3a0d92	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d93	05				length      .byte len("POKEL")
>3a0d94	ab d0				name        .word <>TOKEN_TEXT
>3a0d96	15 3f				eval        .word <>S_POKEL
>3a0d98	00 00				arity       .word <>0
>3ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>3a0d9a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d9b	03				length      .byte len("CLS")
>3a0d9c	b1 d0				name        .word <>TOKEN_TEXT
>3a0d9e	11 3f				eval        .word <>S_CLS
>3a0da0	00 00				arity       .word <>0
>3ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>3a0da2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0da3	04				length      .byte len("READ")
>3a0da4	b5 d0				name        .word <>TOKEN_TEXT
>3a0da6	f2 3d				eval        .word <>S_READ
>3a0da8	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>3ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>3a0daa	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dab	04				length      .byte len("DATA")
>3a0dac	ba d0				name        .word <>TOKEN_TEXT
>3a0dae	04 3f				eval        .word <>S_DATA
>3a0db0	00 00				arity       .word <>0
>3ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>3a0db2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0db3	07				length      .byte len("RESTORE")
>3a0db4	bf d0				name        .word <>TOKEN_TEXT
>3a0db6	08 3f				eval        .word <>S_RESTORE
>3a0db8	00 00				arity       .word <>0
>3ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>3a0dba	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dbb	03				length      .byte len("DIM")
>3a0dbc	c7 d0				name        .word <>TOKEN_TEXT
>3a0dbe	45 3d				eval        .word <>S_DIM
>3a0dc0	00 00				arity       .word <>0
>3ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>3a0dc2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dc3	04				length      .byte len("CALL")
>3a0dc4	cb d0				name        .word <>TOKEN_TEXT
>3a0dc6	ae 3c				eval        .word <>S_CALL
>3a0dc8	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>3ad0d0	2d 00				TOKEN_TEXT  .null "-"
>3a0dca	00				precedence  .byte TOK_TY_OP | 0
>3a0dcb	01				length      .byte len("-")
>3a0dcc	d0 d0				name        .word <>TOKEN_TEXT
>3a0dce	fb 29				eval        .word <>OP_NEGATIVE
>3a0dd0	01 00				arity       .word <>1
>3ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>3a0dd2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0dd3	03				length      .byte len("LEN")
>3a0dd4	d2 d0				name        .word <>TOKEN_TEXT
>3a0dd6	7a 4a				eval        .word <>FN_LEN
>3a0dd8	00 00				arity       .word <>0
>3ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>3a0dda	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ddb	04				length      .byte len("PEEK")
>3a0ddc	d6 d0				name        .word <>TOKEN_TEXT
>3a0dde	ca 4a				eval        .word <>FN_PEEK
>3a0de0	00 00				arity       .word <>0
>3ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>3a0de2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0de3	05				length      .byte len("PEEKW")
>3a0de4	db d0				name        .word <>TOKEN_TEXT
>3a0de6	7c 4b				eval        .word <>FN_PEEKW
>3a0de8	00 00				arity       .word <>0
>3ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>3a0dea	30				precedence  .byte TOK_TY_FUNC | 0
>3a0deb	05				length      .byte len("PEEKL")
>3a0dec	e1 d0				name        .word <>TOKEN_TEXT
>3a0dee	2e 4b				eval        .word <>FN_PEEKL
>3a0df0	00 00				arity       .word <>0
>3ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>3a0df2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0df3	04				length      .byte len("CHR$")
>3a0df4	e7 d0				name        .word <>TOKEN_TEXT
>3a0df6	bb 4b				eval        .word <>FN_CHR
>3a0df8	00 00				arity       .word <>0
>3ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>3a0dfa	30				precedence  .byte TOK_TY_FUNC | 0
>3a0dfb	03				length      .byte len("ASC")
>3a0dfc	ec d0				name        .word <>TOKEN_TEXT
>3a0dfe	10 4c				eval        .word <>FN_ASC
>3a0e00	00 00				arity       .word <>0
>3ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>3a0e02	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e03	03				length      .byte len("SPC")
>3a0e04	f0 d0				name        .word <>TOKEN_TEXT
>3a0e06	55 4c				eval        .word <>FN_SPC
>3a0e08	00 00				arity       .word <>0
>3ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>3a0e0a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e0b	03				length      .byte len("TAB")
>3a0e0c	f4 d0				name        .word <>TOKEN_TEXT
>3a0e0e	de 4c				eval        .word <>FN_TAB
>3a0e10	00 00				arity       .word <>0
>3ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>3a0e12	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e13	03				length      .byte len("ABS")
>3a0e14	f8 d0				name        .word <>TOKEN_TEXT
>3a0e16	67 4d				eval        .word <>FN_ABS
>3a0e18	00 00				arity       .word <>0
>3ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>3a0e1a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e1b	03				length      .byte len("SGN")
>3a0e1c	fc d0				name        .word <>TOKEN_TEXT
>3a0e1e	c9 4d				eval        .word <>FN_SGN
>3a0e20	00 00				arity       .word <>0
>3ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>3a0e22	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e23	04				length      .byte len("HEX$")
>3a0e24	00 d1				name        .word <>TOKEN_TEXT
>3a0e26	ec 49				eval        .word <>FN_HEX
>3a0e28	00 00				arity       .word <>0
>3ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>3a0e2a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e2b	03				length      .byte len("DEC")
>3a0e2c	05 d1				name        .word <>TOKEN_TEXT
>3a0e2e	8b 49				eval        .word <>FN_DEC
>3a0e30	00 00				arity       .word <>0
>3ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>3a0e32	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e33	04				length      .byte len("STR$")
>3a0e34	09 d1				name        .word <>TOKEN_TEXT
>3a0e36	3d 49				eval        .word <>FN_STR
>3a0e38	00 00				arity       .word <>0
>3ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>3a0e3a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e3b	03				length      .byte len("VAL")
>3a0e3c	0e d1				name        .word <>TOKEN_TEXT
>3a0e3e	e7 48				eval        .word <>FN_VAL
>3a0e40	00 00				arity       .word <>0
>3ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>3a0e42	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e43	05				length      .byte len("LEFT$")
>3a0e44	12 d1				name        .word <>TOKEN_TEXT
>3a0e46	1e 48				eval        .word <>FN_LEFT
>3a0e48	00 00				arity       .word <>0
>3ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>3a0e4a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e4b	06				length      .byte len("RIGHT$")
>3a0e4c	18 d1				name        .word <>TOKEN_TEXT
>3a0e4e	3d 47				eval        .word <>FN_RIGHT
>3a0e50	00 00				arity       .word <>0
>3ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>3a0e52	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e53	04				length      .byte len("MID$")
>3a0e54	1f d1				name        .word <>TOKEN_TEXT
>3a0e56	88 46				eval        .word <>FN_MID
>3a0e58	00 00				arity       .word <>0
>3ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>3a0e5a	10				precedence  .byte TOK_TY_CMD | 0
>3a0e5b	03				length      .byte len("RUN")
>3a0e5c	24 d1				name        .word <>TOKEN_TEXT
>3a0e5e	30 4f				eval        .word <>CMD_RUN
>3a0e60	00 00				arity       .word <>0
>3ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>3a0e62	10				precedence  .byte TOK_TY_CMD | 0
>3a0e63	03				length      .byte len("NEW")
>3a0e64	28 d1				name        .word <>TOKEN_TEXT
>3a0e66	fb 4e				eval        .word <>CMD_NEW
>3a0e68	00 00				arity       .word <>0
>3ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>3a0e6a	10				precedence  .byte TOK_TY_CMD | 0
>3a0e6b	04				length      .byte len("LOAD")
>3a0e6c	2c d1				name        .word <>TOKEN_TEXT
>3a0e6e	04 6b				eval        .word <>CMD_LOAD
>3a0e70	00 00				arity       .word <>0
>3ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>3a0e72	10				precedence  .byte TOK_TY_CMD | 0
>3a0e73	04				length      .byte len("LIST")
>3a0e74	31 d1				name        .word <>TOKEN_TEXT
>3a0e76	47 4f				eval        .word <>CMD_LIST
>3a0e78	00 00				arity       .word <>0
>3ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>3a0e7a	10				precedence  .byte TOK_TY_CMD | 0
>3a0e7b	03				length      .byte len("DIR")
>3a0e7c	36 d1				name        .word <>TOKEN_TEXT
>3a0e7e	2b 68				eval        .word <>CMD_DIR
>3a0e80	00 00				arity       .word <>0
>3ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>3a0e82	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e83	05				length      .byte len("BLOAD")
>3a0e84	3a d1				name        .word <>TOKEN_TEXT
>3a0e86	d6 69				eval        .word <>S_BLOAD
>3a0e88	00 00				arity       .word <>0
>3ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>3a0e8a	10				precedence  .byte TOK_TY_CMD | 0
>3a0e8b	04				length      .byte len("BRUN")
>3a0e8c	40 d1				name        .word <>TOKEN_TEXT
>3a0e8e	b1 6a				eval        .word <>CMD_BRUN
>3a0e90	00 00				arity       .word <>0
>3ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>3a0e92	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e93	05				length      .byte len("BSAVE")
>3a0e94	45 d1				name        .word <>TOKEN_TEXT
>3a0e96	bd 6b				eval        .word <>S_BSAVE
>3a0e98	00 00				arity       .word <>0
>3ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>3a0e9a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e9b	03				length      .byte len("DEL")
>3a0e9c	4b d1				name        .word <>TOKEN_TEXT
>3a0e9e	dc 6c				eval        .word <>S_DEL
>3a0ea0	00 00				arity       .word <>0
>3ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>3a0ea2	10				precedence  .byte TOK_TY_CMD | 0
>3a0ea3	04				length      .byte len("SAVE")
>3a0ea4	4f d1				name        .word <>TOKEN_TEXT
>3a0ea6	49 6c				eval        .word <>CMD_SAVE
>3a0ea8	00 00				arity       .word <>0
>3ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>3a0eaa	20				precedence  .byte TOK_TY_STMNT | 0
>3a0eab	06				length      .byte len("RENAME")
>3a0eac	54 d1				name        .word <>TOKEN_TEXT
>3a0eae	52 6d				eval        .word <>S_RENAME
>3a0eb0	00 00				arity       .word <>0
>3ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>3a0eb2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0eb3	04				length      .byte len("COPY")
>3a0eb4	5b d1				name        .word <>TOKEN_TEXT
>3a0eb6	76 6e				eval        .word <>S_COPY
>3a0eb8	00 00				arity       .word <>0
>3ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>3a0eba	10				precedence  .byte TOK_TY_CMD | 0
>3a0ebb	07				length      .byte len("MONITOR")
>3a0ebc	60 d1				name        .word <>TOKEN_TEXT
>3a0ebe	f8 4e				eval        .word <>CMD_MONITOR
>3a0ec0	00 00				arity       .word <>0
>3ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>3a0ec2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ec3	03				length      .byte len("GET")
>3a0ec4	68 d1				name        .word <>TOKEN_TEXT
>3a0ec6	3c 3c				eval        .word <>S_GET
>3a0ec8	00 00				arity       .word <>0
>3ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>3a0eca	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ecb	05				length      .byte len("INPUT")
>3a0ecc	6c d1				name        .word <>TOKEN_TEXT
>3a0ece	4c 3b				eval        .word <>S_INPUT
>3a0ed0	00 00				arity       .word <>0
>3ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>3ad17a	52 00
>3a0ed2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ed3	09				length      .byte len("SETBORDER")
>3a0ed4	72 d1				name        .word <>TOKEN_TEXT
>3a0ed6	ba 2b				eval        .word <>S_SETBORDER
>3a0ed8	00 00				arity       .word <>0
>3ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>3ad184	52 00
>3a0eda	20				precedence  .byte TOK_TY_STMNT | 0
>3a0edb	09				length      .byte len("TEXTCOLOR")
>3a0edc	7c d1				name        .word <>TOKEN_TEXT
>3a0ede	47 2b				eval        .word <>S_TEXTCOLOR
>3a0ee0	00 00				arity       .word <>0
>3ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>3ad18e	4f 52 00
>3a0ee2	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ee3	0a				length      .byte len("SETBGCOLOR")
>3a0ee4	86 d1				name        .word <>TOKEN_TEXT
>3a0ee6	77 2b				eval        .word <>S_SETBGCOLOR
>3a0ee8	00 00				arity       .word <>0
>3ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>3a0eea	20				precedence  .byte TOK_TY_STMNT | 0
>3a0eeb	07				length      .byte len("SETDATE")
>3a0eec	91 d1				name        .word <>TOKEN_TEXT
>3a0eee	b4 2a				eval        .word <>S_SETDATE
>3a0ef0	00 00				arity       .word <>0
>3ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>3ad1a1	00
>3a0ef2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ef3	08				length      .byte len("GETDATE$")
>3a0ef4	99 d1				name        .word <>TOKEN_TEXT
>3a0ef6	63 45				eval        .word <>F_GETDATE
>3a0ef8	00 00				arity       .word <>0
>3ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>3a0efa	20				precedence  .byte TOK_TY_STMNT | 0
>3a0efb	07				length      .byte len("SETTIME")
>3a0efc	a2 d1				name        .word <>TOKEN_TEXT
>3a0efe	49 2a				eval        .word <>S_SETTIME
>3a0f00	00 00				arity       .word <>0
>3ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>3ad1b2	00
>3a0f02	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f03	08				length      .byte len("GETTIME$")
>3a0f04	aa d1				name        .word <>TOKEN_TEXT
>3a0f06	cd 45				eval        .word <>F_GETTIME
>3a0f08	00 00				arity       .word <>0
>3ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>3ad1bb	00
>3a0f0a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f0b	08				length      .byte len("GRAPHICS")
>3a0f0c	b3 d1				name        .word <>TOKEN_TEXT
>3a0f0e	ff 2c				eval        .word <>S_GRAPHICS
>3a0f10	00 00				arity       .word <>0
>3ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>3ad1c4	00
>3a0f12	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f13	08				length      .byte len("SETCOLOR")
>3a0f14	bc d1				name        .word <>TOKEN_TEXT
>3a0f16	33 2c				eval        .word <>S_SETCOLOR
>3a0f18	00 00				arity       .word <>0
>3ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>3a0f1a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f1b	06				length      .byte len("BITMAP")
>3a0f1c	c5 d1				name        .word <>TOKEN_TEXT
>3a0f1e	39 2e				eval        .word <>S_BITMAP
>3a0f20	00 00				arity       .word <>0
>3ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>3ad1d4	50 00
>3a0f22	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f23	09				length      .byte len("CLRBITMAP")
>3a0f24	cc d1				name        .word <>TOKEN_TEXT
>3a0f26	41 2f				eval        .word <>S_CLRBITMAP
>3a0f28	00 00				arity       .word <>0
>3ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>3a0f2a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f2b	04				length      .byte len("PLOT")
>3a0f2c	d6 d1				name        .word <>TOKEN_TEXT
>3a0f2e	51 30				eval        .word <>S_PLOT
>3a0f30	00 00				arity       .word <>0
>3ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>3a0f32	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f33	04				length      .byte len("LINE")
>3a0f34	db d1				name        .word <>TOKEN_TEXT
>3a0f36	c2 30				eval        .word <>S_LINE
>3a0f38	00 00				arity       .word <>0
>3ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>3a0f3a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f3b	04				length      .byte len("FILL")
>3a0f3c	e0 d1				name        .word <>TOKEN_TEXT
>3a0f3e	5b 31				eval        .word <>S_FILL
>3a0f40	00 00				arity       .word <>0
>3ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>3a0f42	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f43	06				length      .byte len("SPRITE")
>3a0f44	e5 d1				name        .word <>TOKEN_TEXT
>3a0f46	97 32				eval        .word <>S_SPRITE
>3a0f48	00 00				arity       .word <>0
>3ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>3ad1f4	00
>3a0f4a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f4b	08				length      .byte len("SPRITEAT")
>3a0f4c	ec d1				name        .word <>TOKEN_TEXT
>3a0f4e	35 33				eval        .word <>S_SPRITEAT
>3a0f50	00 00				arity       .word <>0
>3ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>3ad1fd	4f 57 00
>3a0f52	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f53	0a				length      .byte len("SPRITESHOW")
>3a0f54	f5 d1				name        .word <>TOKEN_TEXT
>3a0f56	83 33				eval        .word <>S_SPRITESHOW
>3a0f58	00 00				arity       .word <>0
>3ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>3a0f5a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f5b	07				length      .byte len("TILESET")
>3a0f5c	00 d2				name        .word <>TOKEN_TEXT
>3a0f5e	ba 34				eval        .word <>S_TILESET
>3a0f60	00 00				arity       .word <>0
>3ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>3a0f62	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f63	07				length      .byte len("TILEMAP")
>3a0f64	08 d2				name        .word <>TOKEN_TEXT
>3a0f66	38 35				eval        .word <>S_TILEMAP
>3a0f68	00 00				arity       .word <>0
>3ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>3ad218	00
>3a0f6a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f6b	08				length      .byte len("TILESHOW")
>3a0f6c	10 d2				name        .word <>TOKEN_TEXT
>3a0f6e	aa 35				eval        .word <>S_TILESHOW
>3a0f70	00 00				arity       .word <>0
>3ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>3a0f72	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f73	06				length      .byte len("TILEAT")
>3a0f74	19 d2				name        .word <>TOKEN_TEXT
>3a0f76	e7 35				eval        .word <>S_TILEAT
>3a0f78	00 00				arity       .word <>0
>3ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>3a0f7a	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f7b	07				length      .byte len("MEMCOPY")
>3a0f7c	20 d2				name        .word <>TOKEN_TEXT
>3a0f7e	17 39				eval        .word <>S_MEMCOPY
>3a0f80	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>3ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>3a0f82	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0f83	06				length      .byte len("LINEAR")
>3a0f84	28 d2				name        .word <>TOKEN_TEXT
>3a0f86	00 00				eval        .word <>0
>3a0f88	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>3ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>3a0f8a	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0f8b	04				length      .byte len("RECT")
>3a0f8c	2f d2				name        .word <>TOKEN_TEXT
>3a0f8e	00 00				eval        .word <>0
>3a0f90	00 00				arity       .word <>0
>3ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>3a0f92	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f93	06				length      .byte len("LOCATE")
>3a0f94	34 d2				name        .word <>TOKEN_TEXT
>3a0f96	2c 3b				eval        .word <>S_LOCATE
>3a0f98	00 00				arity       .word <>0
>3ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>3a0f9a	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f9b	03				length      .byte len("INT")
>3a0f9c	3b d2				name        .word <>TOKEN_TEXT
>3a0f9e	1f 4e				eval        .word <>FN_INT
>3a0fa0	00 00				arity       .word <>0
>3ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>3a0fa2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fa3	03				length      .byte len("RND")
>3a0fa4	3f d2				name        .word <>TOKEN_TEXT
>3a0fa6	32 46				eval        .word <>FN_RND
>3a0fa8	00 00				arity       .word <>0
>3ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>3a0faa	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fab	03				length      .byte len("SIN")
>3a0fac	43 d2				name        .word <>TOKEN_TEXT
>3a0fae	32 4e				eval        .word <>FN_SIN
>3a0fb0	00 00				arity       .word <>0
>3ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>3a0fb2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fb3	03				length      .byte len("COS")
>3a0fb4	47 d2				name        .word <>TOKEN_TEXT
>3a0fb6	48 4e				eval        .word <>FN_COS
>3a0fb8	00 00				arity       .word <>0
>3ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>3a0fba	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fbb	03				length      .byte len("TAN")
>3a0fbc	4b d2				name        .word <>TOKEN_TEXT
>3a0fbe	5e 4e				eval        .word <>FN_TAN
>3a0fc0	00 00				arity       .word <>0
>3ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>3a0fc2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fc3	02				length      .byte len("LN")
>3a0fc4	4f d2				name        .word <>TOKEN_TEXT
>3a0fc6	74 4e				eval        .word <>FN_LN
>3a0fc8	00 00				arity       .word <>0
>3ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>3a0fca	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fcb	04				length      .byte len("ACOS")
>3a0fcc	52 d2				name        .word <>TOKEN_TEXT
>3a0fce	8a 4e				eval        .word <>FN_ACOS
>3a0fd0	00 00				arity       .word <>0
>3ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>3a0fd2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fd3	04				length      .byte len("ASIN")
>3a0fd4	57 d2				name        .word <>TOKEN_TEXT
>3a0fd6	a0 4e				eval        .word <>FN_ASIN
>3a0fd8	00 00				arity       .word <>0
>3ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>3a0fda	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fdb	04				length      .byte len("ATAN")
>3a0fdc	5c d2				name        .word <>TOKEN_TEXT
>3a0fde	b6 4e				eval        .word <>FN_ATAN
>3a0fe0	00 00				arity       .word <>0
>3ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>3a0fe2	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fe3	03				length      .byte len("EXP")
>3a0fe4	61 d2				name        .word <>TOKEN_TEXT
>3a0fe6	cc 4e				eval        .word <>FN_EXP
>3a0fe8	00 00				arity       .word <>0
>3ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>3a0fea	30				precedence  .byte TOK_TY_FUNC | 0
>3a0feb	03				length      .byte len("SQR")
>3a0fec	65 d2				name        .word <>TOKEN_TEXT
>3a0fee	e2 4e				eval        .word <>FN_SQR
>3a0ff0	00 00				arity       .word <>0
>3a0ff2	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.3a0ffa					INITHEAP
.3a0ffa	08		php		            PHP
.3a0ffb	0b		phd		            PHD
.3a0ffc	08		php		            PHP
.3a0ffd	c2 20		rep #$20	            REP #$20
.3a0fff	48		pha		            PHA
.3a1000	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1003	5b		tcd		            TCD
.3a1004	68		pla		            PLA
.3a1005	28		plp		            PLP
.3a1006	c2 30		rep #$30	            REP #$30
.3a1008	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.3a100b	85 ba		sta $08ba	            STA HEAP
.3a100d	e2 20		sep #$20	            SEP #$20
.3a100f	a9 37		lda #$37	            LDA #`HEAP_TOP
.3a1011	85 bc		sta $08bc	            STA HEAP+2
.3a1013	c2 20		rep #$20	            REP #$20
.3a1015	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.3a1017	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.3a1019	e2 20		sep #$20	            SEP #$20
.3a101b	64 b9		stz $08b9	            STZ ALLOCATED+2
.3a101d	64 bf		stz $08bf	            STZ FREED+2
.3a101f	2b		pld		            PLD
.3a1020	28		plp		            PLP
.3a1021	60		rts		            RTS
.3a1022					ALLOC
.3a1022	5a		phy		            PHY
.3a1023	08		php		            PHP
.3a1024	e2 20		sep #$20	            SEP #$20
.3a1026	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.3a1028	c2 10		rep #$10	            REP #$10
.3a102a	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.3a102c	c2 20		rep #$20	            REP #$20
.3a102e	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1030	48		pha		            PHA
.3a1031	a5 0c		lda $080c	            LDA SCRATCH
.3a1033	48		pha		            PHA
.3a1034	a5 12		lda $0812	            LDA SCRATCH2+2
.3a1036	48		pha		            PHA
.3a1037	a5 10		lda $0810	            LDA SCRATCH2
.3a1039	48		pha		            PHA
.3a103a	20 d2 10	jsr $3a10d2	            JSR ALLOCFREED
.3a103d	b0 03		bcs $3a1042	            BCS done            ; Return, if we got something back
.3a103f	20 56 10	jsr $3a1056	            JSR ALLOCHEAP
.3a1042					done
.3a1042	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a1045	c2 20		rep #$20	            REP #$20
.3a1047	68		pla		            PLA
.3a1048	85 10		sta $0810	            STA SCRATCH2
.3a104a	68		pla		            PLA
.3a104b	85 12		sta $0812	            STA SCRATCH2+2
.3a104d	68		pla		            PLA
.3a104e	85 0c		sta $080c	            STA SCRATCH
.3a1050	68		pla		            PLA
.3a1051	85 0e		sta $080e	            STA SCRATCH+2
.3a1053	28		plp		            PLP
.3a1054	7a		ply		            PLY
.3a1055	60		rts		            RTS
.3a1056					ALLOCHEAP
.3a1056	08		php		            PHP
.3a1057	0b		phd		            PHD
.3a1058	08		php		            PHP
.3a1059	c2 20		rep #$20	            REP #$20
.3a105b	48		pha		            PHA
.3a105c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a105f	5b		tcd		            TCD
.3a1060	68		pla		            PLA
.3a1061	28		plp		            PLP
.3a1062	e2 20		sep #$20	            SEP #$20
.3a1064	a6 8f		ldx $088f	            LDX MCOUNT
.3a1066	ca		dex		            DEX
.3a1067	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.3a1069	e8		inx		            INX
.3a106a	c2 30		rep #$30	            REP #$30
.3a106c	38		sec		            SEC
.3a106d	a5 ba		lda $08ba	            LDA HEAP
.3a106f	e5 0c		sbc $080c	            SBC SCRATCH
.3a1071	85 c0		sta $08c0	            STA CURRBLOCK
.3a1073	e2 20		sep #$20	            SEP #$20
.3a1075	a5 bc		lda $08bc	            LDA HEAP+2
.3a1077	e9 00		sbc #$00	            SBC #0
.3a1079	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a107b	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a107e	e2 20		sep #$20	            SEP #$20
.3a1080	a5 ea		lda $08ea	            LDA TOFINDTYPE
.3a1082	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.3a1085	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1087	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.3a1089	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a108c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a108e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1091	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1093	c2 20		rep #$20	            REP #$20
.3a1095	a9 00 00	lda #$0000	            LDA #0
.3a1098	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a109a	c2 20		rep #$20	            REP #$20
.3a109c	18		clc		            CLC
.3a109d	a5 ba		lda $08ba	            LDA HEAP
.3a109f	69 01 00	adc #$0001	            ADC #1
.3a10a2	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.3a10a5	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.3a10a7	e2 20		sep #$20	            SEP #$20
.3a10a9	c8		iny		            INY
.3a10aa	c8		iny		            INY
.3a10ab	a5 bc		lda $08bc	            LDA HEAP+2
.3a10ad	69 00		adc #$00	            ADC #0
.3a10af	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a10b1	c2 20		rep #$20	            REP #$20
.3a10b3	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a10b5	85 b7		sta $08b7	            STA ALLOCATED
.3a10b7	e2 20		sep #$20	            SEP #$20
.3a10b9	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a10bb	85 b9		sta $08b9	            STA ALLOCATED+2
.3a10bd	c2 20		rep #$20	            REP #$20
.3a10bf	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.3a10c0	a5 c3		lda $08c3	            LDA CURRHEADER
.3a10c2	e9 01 00	sbc #$0001	            SBC #1
.3a10c5	85 ba		sta $08ba	            STA HEAP
.3a10c7	e2 20		sep #$20	            SEP #$20
.3a10c9	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a10cb	e9 00		sbc #$00	            SBC #0
.3a10cd	85 bc		sta $08bc	            STA HEAP+2
.3a10cf	2b		pld		            PLD
.3a10d0	28		plp		            PLP
.3a10d1	60		rts		            RTS
.3a10d2					ALLOCFREED
.3a10d2	08		php		            PHP
.3a10d3	0b		phd		            PHD
.3a10d4	08		php		            PHP
.3a10d5	c2 20		rep #$20	            REP #$20
.3a10d7	48		pha		            PHA
.3a10d8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a10db	5b		tcd		            TCD
.3a10dc	68		pla		            PLA
.3a10dd	28		plp		            PLP
.3a10de	c2 30		rep #$30	            REP #$30
.3a10e0	c2 20		rep #$20	            REP #$20
.3a10e2	a5 bd		lda $08bd	            LDA FREED
.3a10e4	85 c9		sta $08c9	            STA CURRFREED
.3a10e6	e2 20		sep #$20	            SEP #$20
.3a10e8	a5 bf		lda $08bf	            LDA FREED+2
.3a10ea	85 cb		sta $08cb	            STA CURRFREED+2
.3a10ec	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.3a10ee	d0 17		bne $3a1107	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a10f0	e2 20		sep #$20	            SEP #$20
.3a10f2	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a10f4	d0 11		bne $3a1107	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a10f6	c2 20		rep #$20	            REP #$20
.3a10f8	a9 00 00	lda #$0000	            LDA #<>0
.3a10fb	85 cf		sta $08cf	            STA LASTFREED
.3a10fd	e2 20		sep #$20	            SEP #$20
.3a10ff	a9 00		lda #$00	            LDA #`0
.3a1101	85 d1		sta $08d1	            STA LASTFREED+2
.3a1103	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.3a1104	28		plp		            PLP
.3a1105	18		clc		            CLC
.3a1106	60		rts		            RTS
.3a1107					has_block
.3a1107	c2 20		rep #$20	            REP #$20
.3a1109	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a110c	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a110e	85 cc		sta $08cc	            STA FREEDEND
.3a1110	e2 20		sep #$20	            SEP #$20
.3a1112	c8		iny		            INY
.3a1113	c8		iny		            INY
.3a1114	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1116	85 ce		sta $08ce	            STA FREEDEND+2
.3a1118	c2 20		rep #$20	            REP #$20
.3a111a	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.3a111b	a5 c9		lda $08c9	            LDA CURRFREED
.3a111d	65 8f		adc $088f	            ADC MCOUNT
.3a111f	85 0c		sta $080c	            STA SCRATCH
.3a1121	e2 20		sep #$20	            SEP #$20
.3a1123	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1125	69 00		adc #$00	            ADC #0
.3a1127	85 0e		sta $080e	            STA SCRATCH+2
.3a1129	c2 20		rep #$20	            REP #$20
.3a112b	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.3a112c	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.3a112e	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.3a1131	85 0c		sta $080c	            STA SCRATCH
.3a1133	e2 20		sep #$20	            SEP #$20
.3a1135	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1137	69 00		adc #$00	            ADC #0
.3a1139	85 0e		sta $080e	            STA SCRATCH+2
.3a113b	c2 20		rep #$20	            REP #$20
.3a113d	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.3a113f	c5 cc		cmp $08cc	            CMP FREEDEND
.3a1141	d0 28		bne $3a116b	            BNE not_exact               ; No: check if this block is bigger than needed
.3a1143	e2 20		sep #$20	            SEP #$20
.3a1145	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1147	c5 ce		cmp $08ce	            CMP FREEDEND+2
.3a1149	d0 20		bne $3a116b	            BNE not_exact
.3a114b	c2 20		rep #$20	            REP #$20
.3a114d	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.3a114f	d0 5d		bne $3a11ae	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.3a1151	e2 20		sep #$20	            SEP #$20
.3a1153	a5 d1		lda $08d1	            LDA LASTFREED+2
.3a1155	d0 57		bne $3a11ae	            BNE adj_last1
.3a1157	c2 20		rep #$20	            REP #$20
.3a1159	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a115c	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a115e	85 bd		sta $08bd	            STA FREED
.3a1160	e2 20		sep #$20	            SEP #$20
.3a1162	c8		iny		            INY
.3a1163	c8		iny		            INY
.3a1164	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1166	85 bf		sta $08bf	            STA FREED+2
.3a1168	4c 0f 12	jmp $3a120f	            JMP init_block              ; And return CURRFREED as our reallocated memory
.3a116b					not_exact
.3a116b	c2 20		rep #$20	            REP #$20
.3a116d	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.3a116f	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.3a1172	85 10		sta $0810	            STA SCRATCH2
.3a1174	e2 20		sep #$20	            SEP #$20
.3a1176	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1178	69 00		adc #$00	            ADC #0
.3a117a	85 12		sta $0812	            STA SCRATCH2+2
.3a117c	e2 20		sep #$20	            SEP #$20
.3a117e	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.3a1180	c5 10		cmp $0810	            CMP SCRATCH2
.3a1182	b0 3e		bcs $3a11c2	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.3a1184	90 08		bcc $3a118e	            BLT try_next
.3a1186	c2 20		rep #$20	            REP #$20
.3a1188	a5 c6		lda $08c6	            LDA CURREND
.3a118a	c5 10		cmp $0810	            CMP SCRATCH2
.3a118c	b0 34		bcs $3a11c2	            BGE has_room
.3a118e					try_next
.3a118e	c2 20		rep #$20	            REP #$20
.3a1190	a5 c9		lda $08c9	            LDA CURRFREED
.3a1192	85 cf		sta $08cf	            STA LASTFREED
.3a1194	e2 20		sep #$20	            SEP #$20
.3a1196	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1198	85 d1		sta $08d1	            STA LASTFREED+2
.3a119a	c2 20		rep #$20	            REP #$20
.3a119c	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a119f	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a11a1	85 c9		sta $08c9	            STA CURRFREED
.3a11a3	e2 20		sep #$20	            SEP #$20
.3a11a5	c8		iny		            INY
.3a11a6	c8		iny		            INY
.3a11a7	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a11a9	85 cb		sta $08cb	            STA CURRFREED+2
.3a11ab	4c ec 10	jmp $3a10ec	            JMP loop                                    ; And try the next header
.3a11ae					adj_last1
.3a11ae	c2 20		rep #$20	            REP #$20
.3a11b0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.3a11b3	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11b5	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a11b7	e2 20		sep #$20	            SEP #$20
.3a11b9	c8		iny		            INY
.3a11ba	c8		iny		            INY
.3a11bb	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11bd	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a11bf	4c 0f 12	jmp $3a120f	            JMP init_block              ; And get CURRFREED ready to return
.3a11c2					has_room
.3a11c2	c2 20		rep #$20	            REP #$20
.3a11c4	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.3a11c7	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11c9	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a11cb	e2 20		sep #$20	            SEP #$20
.3a11cd	c8		iny		            INY
.3a11ce	c8		iny		            INY
.3a11cf	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11d1	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a11d3	c2 20		rep #$20	            REP #$20
.3a11d5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.3a11d8	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11da	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a11dc	e2 20		sep #$20	            SEP #$20
.3a11de	c8		iny		            INY
.3a11df	c8		iny		            INY
.3a11e0	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11e2	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a11e4	c2 20		rep #$20	            REP #$20
.3a11e6	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.3a11e8	d0 14		bne $3a11fe	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.3a11ea	e2 20		sep #$20	            SEP #$20
.3a11ec	a5 cf		lda $08cf	            LDA LASTFREED
.3a11ee	d0 0e		bne $3a11fe	            BNE adj_last2
.3a11f0	c2 20		rep #$20	            REP #$20
.3a11f2	a5 0c		lda $080c	            LDA SCRATCH
.3a11f4	85 bd		sta $08bd	            STA FREED
.3a11f6	e2 20		sep #$20	            SEP #$20
.3a11f8	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11fa	85 bf		sta $08bf	            STA FREED+2
.3a11fc	80 11		bra $3a120f	            BRA init_block              ; ... and return the block we've sliced off
.3a11fe					adj_last2
.3a11fe	c2 20		rep #$20	            REP #$20
.3a1200	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.3a1203	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.3a1205	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.3a1207	e2 20		sep #$20	            SEP #$20
.3a1209	c8		iny		            INY
.3a120a	c8		iny		            INY
.3a120b	a5 0e		lda $080e	            LDA SCRATCH+2
.3a120d	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a120f					init_block
.3a120f	c2 20		rep #$20	            REP #$20
.3a1211	a5 c9		lda $08c9	            LDA CURRFREED
.3a1213	85 c3		sta $08c3	            STA CURRHEADER
.3a1215	e2 20		sep #$20	            SEP #$20
.3a1217	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1219	85 c5		sta $08c5	            STA CURRHEADER+2
.3a121b	c2 20		rep #$20	            REP #$20
.3a121d	a5 c3		lda $08c3	            LDA CURRHEADER
.3a121f	85 b7		sta $08b7	            STA ALLOCATED
.3a1221	e2 20		sep #$20	            SEP #$20
.3a1223	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1225	85 b9		sta $08b9	            STA ALLOCATED+2
.3a1227	c2 20		rep #$20	            REP #$20
.3a1229	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.3a122c	a5 0c		lda $080c	            LDA SCRATCH
.3a122e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1230	e2 20		sep #$20	            SEP #$20
.3a1232	c8		iny		            INY
.3a1233	c8		iny		            INY
.3a1234	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1236	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1238	c2 20		rep #$20	            REP #$20
.3a123a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.3a123d	a9 00 00	lda #$0000	            LDA #0
.3a1240	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1242	e2 20		sep #$20	            SEP #$20
.3a1244	c8		iny		            INY
.3a1245	c8		iny		            INY
.3a1246	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1248	e2 20		sep #$20	            SEP #$20
.3a124a	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.3a124c	e2 20		sep #$20	            SEP #$20
.3a124e	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.3a1251	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1253	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.3a1256	a9 00		lda #$00	            LDA #0
.3a1258	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a125a	2b		pld		done        PLD
.3a125b	28		plp		            PLP
.3a125c	38		sec		            SEC
.3a125d	60		rts		            RTS
.3a125e					HEAP_GETHED
.3a125e	08		php		            PHP
.3a125f	c2 20		rep #$20	            REP #$20
.3a1261	38		sec		            SEC
.3a1262	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1264	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.3a1267	85 c3		sta $08c3	            STA CURRHEADER
.3a1269	e2 20		sep #$20	            SEP #$20
.3a126b	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a126d	e9 00		sbc #$00	            SBC #0
.3a126f	85 c5		sta $08c5	            STA CURRHEADER+2
.3a1271	28		plp		            PLP
.3a1272	60		rts		            RTS
.3a1273					HEAP_ADDREF
.3a1273	08		php		            PHP
.3a1274	e2 20		sep #$20	            SEP #$20
.3a1276	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1278	f0 04		beq $3a127e	            BEQ chk_null
.3a127a	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a127c	b0 12		bcs $3a1290	            BGE out_of_bnds
.3a127e					chk_null
.3a127e	c2 20		rep #$20	            REP #$20
.3a1280	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1282	f0 0c		beq $3a1290	            BEQ out_of_bnds
.3a1284					is_ok
.3a1284	e2 20		sep #$20	            SEP #$20
.3a1286	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a1289	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a128b	1a		inc a		            INC A
.3a128c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a128e	28		plp		            PLP
.3a128f	60		rts		            RTS
.3a1290	00		brk #		out_of_bnds BRK
.3a1291	ea		nop		            NOP
.3a1292					HEAP_REMREF
.3a1292	08		php		            PHP
.3a1293	e2 20		sep #$20	            SEP #$20
.3a1295	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1297	f0 04		beq $3a129d	            BEQ chk_null
.3a1299	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a129b	b0 17		bcs $3a12b4	            BGE out_of_bnds
.3a129d					chk_null
.3a129d	c2 20		rep #$20	            REP #$20
.3a129f	a5 c3		lda $08c3	            LDA CURRHEADER
.3a12a1	f0 11		beq $3a12b4	            BEQ out_of_bnds
.3a12a3	e2 20		sep #$20	            SEP #$20
.3a12a5	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.3a12a8	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a12aa	3a		dec a		            DEC A
.3a12ab	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12ad	d0 03		bne $3a12b2	            BNE done            ; If it's still >0, we are done
.3a12af	20 b6 12	jsr $3a12b6	            JSR HEAP_FREE
.3a12b2	28		plp		done        PLP
.3a12b3	60		rts		            RTS
.3a12b4	00		brk #		out_of_bnds BRK
.3a12b5	ea		nop		            NOP
.3a12b6					HEAP_FREE
.3a12b6	08		php		            PHP
.3a12b7	c2 20		rep #$20	            REP #$20
.3a12b9	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.3a12bb	d0 21		bne $3a12de	            BNE has_objects
.3a12bd	e2 20		sep #$20	            SEP #$20
.3a12bf	a5 bf		lda $08bf	            LDA FREED+2
.3a12c1	d0 1b		bne $3a12de	            BNE has_objects
.3a12c3	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.3a12c5	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.3a12c7	c2 20		rep #$20	            REP #$20
.3a12c9	a5 c3		lda $08c3	            LDA CURRHEADER
.3a12cb	85 bd		sta $08bd	            STA FREED
.3a12cd	a9 00 00	lda #$0000	            LDA #0
.3a12d0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.3a12d3	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12d5	c8		iny		            INY
.3a12d6	c8		iny		            INY
.3a12d7	e2 20		sep #$20	            SEP #$20
.3a12d9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12db	4c 9d 13	jmp $3a139d	            JMP done
.3a12de					has_objects
.3a12de	e2 20		sep #$20	            SEP #$20
.3a12e0	a5 bf		lda $08bf	            LDA FREED+2
.3a12e2	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.3a12e4	90 28		bcc $3a130e	            BLT start_scan
.3a12e6	c2 20		rep #$20	            REP #$20
.3a12e8	a5 bd		lda $08bd	            LDA FREED
.3a12ea	c5 c3		cmp $08c3	            CMP CURRHEADER
.3a12ec	90 20		bcc $3a130e	            BLT start_scan
.3a12ee					ins_first
.3a12ee	c2 20		rep #$20	            REP #$20
.3a12f0	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.3a12f2	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a12f5	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12f7	e2 20		sep #$20	            SEP #$20
.3a12f9	c8		iny		            INY
.3a12fa	c8		iny		            INY
.3a12fb	a5 bf		lda $08bf	            LDA FREED+2
.3a12fd	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12ff	c2 20		rep #$20	            REP #$20
.3a1301	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1303	85 bd		sta $08bd	            STA FREED
.3a1305	e2 20		sep #$20	            SEP #$20
.3a1307	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1309	85 bf		sta $08bf	            STA FREED+2
.3a130b	4c 9d 13	jmp $3a139d	            JMP done
.3a130e					start_scan
.3a130e	c2 20		rep #$20	            REP #$20
.3a1310	a5 bd		lda $08bd	            LDA FREED
.3a1312	85 08		sta $0808	            STA INDEX
.3a1314	e2 20		sep #$20	            SEP #$20
.3a1316	a5 bf		lda $08bf	            LDA FREED+2
.3a1318	85 0a		sta $080a	            STA INDEX+2
.3a131a					loop
.3a131a	e2 20		sep #$20	            SEP #$20
.3a131c	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.3a131f	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1321	c5 c8		cmp $08c8	            CMP CURREND+2
.3a1323	90 32		bcc $3a1357	            BLT go_next             ; No: check the next spot
.3a1325	d0 0b		bne $3a1332	            BNE ins_next
.3a1327	c2 20		rep #$20	            REP #$20
.3a1329	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a132c	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a132e	c5 c6		cmp $08c6	            CMP CURREND
.3a1330	90 25		bcc $3a1357	            BLT go_next             ; No: check the next spot
.3a1332					ins_next
.3a1332	c2 20		rep #$20	            REP #$20
.3a1334	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.3a1337	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1339	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a133b	e2 20		sep #$20	            SEP #$20
.3a133d	c8		iny		            INY
.3a133e	c8		iny		            INY
.3a133f	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1341	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1343	c2 20		rep #$20	            REP #$20
.3a1345	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a1347	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a134a	97 08		sta [$0808],y	            STA [INDEX],Y
.3a134c	e2 20		sep #$20	            SEP #$20
.3a134e	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1350	c8		iny		            INY
.3a1351	c8		iny		            INY
.3a1352	97 08		sta [$0808],y	            STA [INDEX],Y
.3a1354	4c 9d 13	jmp $3a139d	            JMP done
.3a1357					go_next
.3a1357	c2 20		rep #$20	            REP #$20
.3a1359	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.3a135c	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a135e	d0 08		bne $3a1368	            BNE not_at_end          ; No: load up the next object
.3a1360	e2 20		sep #$20	            SEP #$20
.3a1362	c8		iny		            INY
.3a1363	c8		iny		            INY
.3a1364	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1366	f0 19		beq $3a1381	            BEQ at_end
.3a1368					not_at_end
.3a1368	c2 20		rep #$20	            REP #$20
.3a136a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.3a136d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a136f	85 0c		sta $080c	            STA SCRATCH
.3a1371	e2 20		sep #$20	            SEP #$20
.3a1373	c8		iny		            INY
.3a1374	c8		iny		            INY
.3a1375	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1377	85 0a		sta $080a	            STA INDEX+2
.3a1379	c2 20		rep #$20	            REP #$20
.3a137b	a5 0c		lda $080c	            LDA SCRATCH
.3a137d	85 08		sta $0808	            STA INDEX
.3a137f	80 99		bra $3a131a	            BRA loop
.3a1381					at_end
.3a1381	c2 20		rep #$20	            REP #$20
.3a1383	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a1385	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1388	97 08		sta [$0808],y	            STA [INDEX],Y
.3a138a	e2 20		sep #$20	            SEP #$20
.3a138c	c8		iny		            INY
.3a138d	c8		iny		            INY
.3a138e	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1390	97 08		sta [$0808],y	            STA [INDEX],Y
.3a1392	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.3a1394	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1396	c2 20		rep #$20	            REP #$20
.3a1398	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a139b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a139d					done
.3a139d	20 a2 13	jsr $3a13a2	            JSR COALLESCE
.3a13a0	28		plp		            PLP
.3a13a1	60		rts		            RTS
.3a13a2					COALLESCE
.3a13a2	08		php		            PHP
.3a13a3	c2 20		rep #$20	            REP #$20
.3a13a5	a5 bd		lda $08bd	            LDA FREED
.3a13a7	85 c3		sta $08c3	            STA CURRHEADER
.3a13a9	e2 20		sep #$20	            SEP #$20
.3a13ab	a5 bf		lda $08bf	            LDA FREED+2
.3a13ad	85 c5		sta $08c5	            STA CURRHEADER+2
.3a13af					next_head
.3a13af	c2 20		rep #$20	            REP #$20
.3a13b1	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.3a13b3	d0 09		bne $3a13be	            BNE check_next          ; No: check if NEXT is contiguous
.3a13b5	e2 20		sep #$20	            SEP #$20
.3a13b7	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a13b9	d0 03		bne $3a13be	            BNE check_next
.3a13bb	4c 45 14	jmp $3a1445	            JMP done                ; Yes: we're done
.3a13be					check_next
.3a13be	c2 20		rep #$20	            REP #$20
.3a13c0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13c3	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13c5	85 0c		sta $080c	            STA SCRATCH
.3a13c7	e2 20		sep #$20	            SEP #$20
.3a13c9	c8		iny		            INY
.3a13ca	c8		iny		            INY
.3a13cb	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13cd	85 0e		sta $080e	            STA SCRATCH+2
.3a13cf	c2 20		rep #$20	            REP #$20
.3a13d1	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a13d4	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13d6	85 10		sta $0810	            STA SCRATCH2
.3a13d8	e2 20		sep #$20	            SEP #$20
.3a13da	c8		iny		            INY
.3a13db	c8		iny		            INY
.3a13dc	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13de	85 12		sta $0812	            STA SCRATCH2+2
.3a13e0	c2 20		rep #$20	            REP #$20
.3a13e2	a5 0c		lda $080c	            LDA SCRATCH
.3a13e4	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.3a13e6	d0 08		bne $3a13f0	            BNE go_next             ; No: go to the next block
.3a13e8	e2 20		sep #$20	            SEP #$20
.3a13ea	a5 0e		lda $080e	            LDA SCRATCH+2
.3a13ec	c5 12		cmp $0812	            CMP SCRATCH2+2
.3a13ee	f0 1f		beq $3a140f	            BEQ combine             ; Yes: combine the two blocks
.3a13f0					go_next
.3a13f0	c2 20		rep #$20	            REP #$20
.3a13f2	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13f5	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13f7	85 0c		sta $080c	            STA SCRATCH
.3a13f9	e2 20		sep #$20	            SEP #$20
.3a13fb	c8		iny		            INY
.3a13fc	c8		iny		            INY
.3a13fd	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a13ff	85 0e		sta $080e	            STA SCRATCH+2
.3a1401	c2 20		rep #$20	            REP #$20
.3a1403	a5 0c		lda $080c	            LDA SCRATCH
.3a1405	85 c3		sta $08c3	            STA CURRHEADER
.3a1407	e2 20		sep #$20	            SEP #$20
.3a1409	a5 0e		lda $080e	            LDA SCRATCH+2
.3a140b	85 c5		sta $08c5	            STA CURRHEADER+2
.3a140d	80 a0		bra $3a13af	            BRA next_head                               ; And loop back to next_head
.3a140f					combine
.3a140f	c2 20		rep #$20	            REP #$20
.3a1411	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1414	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1416	85 0c		sta $080c	            STA SCRATCH
.3a1418	e2 20		sep #$20	            SEP #$20
.3a141a	c8		iny		            INY
.3a141b	c8		iny		            INY
.3a141c	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a141e	85 0e		sta $080e	            STA SCRATCH+2
.3a1420	c2 20		rep #$20	            REP #$20
.3a1422	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.3a1425	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1427	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1429	e2 20		sep #$20	            SEP #$20
.3a142b	c8		iny		            INY
.3a142c	c8		iny		            INY
.3a142d	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a142f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1431	c2 20		rep #$20	            REP #$20
.3a1433	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.3a1436	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1438	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a143a	e2 20		sep #$20	            SEP #$20
.3a143c	c8		iny		            INY
.3a143d	c8		iny		            INY
.3a143e	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1440	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1442	4c be 13	jmp $3a13be	            JMP check_next          ; And loop back to check_next
.3a1445	28		plp		done        PLP
.3a1446	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.3a1447					CLRTMPSTR
.3a1447	08		php		            PHP
.3a1448	c2 20		rep #$20	            REP #$20
.3a144a	64 16		stz $0816	            STZ STRPTR
.3a144c	64 18		stz $0818	            STZ STRPTR+2
.3a144e	28		plp		            PLP
.3a144f	60		rts		            RTS
.3a1450					TEMPSTRING
.3a1450	08		php		            PHP
.3a1451	c2 30		rep #$30	            REP #$30
.3a1453	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.3a1455	d0 16		bne $3a146d	            BNE add_256         ; No: add 256 to it
.3a1457	a5 18		lda $0818	            LDA STRPTR+2
.3a1459	d0 12		bne $3a146d	            BNE add_256
.3a145b	e2 20		sep #$20	            SEP #$20
.3a145d	64 16		stz $0816	            STZ STRPTR
.3a145f	a5 e2		lda $08e2	            LDA NEXTVAR+1
.3a1461	1a		inc a		            INC A
.3a1462	1a		inc a		            INC A
.3a1463	85 17		sta $0817	            STA STRPTR+1
.3a1465	a5 e3		lda $08e3	            LDA NEXTVAR+2
.3a1467	85 18		sta $0818	            STA STRPTR+2
.3a1469	64 19		stz $0819	            STZ STRPTR+3
.3a146b	80 07		bra $3a1474	            BRA chk_room
.3a146d					add_256
.3a146d	c2 20		rep #$20	            REP #$20
.3a146f	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.3a1471	1a		inc a		            INC A               ; Leave 256 bytes for it
.3a1472	85 17		sta $0817	            STA STRPTR+1
.3a1474					chk_room
.3a1474	c2 20		rep #$20	            REP #$20
.3a1476	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.3a1478	3a		dec a		            DEC A
.3a1479	c5 17		cmp $0817	            CMP STRPTR+1
.3a147b	f0 02		beq $3a147f	            BEQ no_room         ; If they have, throw an error
.3a147d	b0 1f		bcs $3a149e	            BGE done
.3a147f					no_room
.3a147f	08		php		            PHP
.3a1480	c2 20		rep #$20	            REP #$20
.3a1482	48		pha		            PHA
.3a1483	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1486	5b		tcd		            TCD
.3a1487	68		pla		            PLA
.3a1488	28		plp		            PLP
.3a1489	e2 20		sep #$20	            SEP #$20
.3a148b	a9 03		lda #$03	            LDA #ERR_MEMORY
.3a148d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1491	c2 20		rep #$20	            REP #$20
.3a1493	29 ff 00	and #$00ff	            AND #$00FF
.3a1496	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1499	e2 20		sep #$20	            SEP #$20
.3a149b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a149e	28		plp		done        PLP
.3a149f	60		rts		            RTS
.3a14a0					ITOS_DIGIT
.3a14a0	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.3a14a2	d0 05		bne $3a14a9	            BNE add_digit   ; No: go ahead and add it
.3a14a4	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.3a14a7	f0 05		beq $3a14ae	            BEQ done        ; Yes: ignore this leading 0
.3a14a9	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.3a14ab	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.3a14ad	c8		iny		            INY             ; And point to the next location
.3a14ae					done
.3a14ae	60		rts		            RTS
.3a14af					ITOS
.3a14af	08		php		            PHP
.3a14b0	c2 30		rep #$30	            REP #$30
.3a14b2	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.3a14b4	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.3a14b6	10 1a		bpl $3a14d2	            BPL start_cnvt
.3a14b8	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.3a14b9	a5 23		lda $0823	            LDA ARGUMENT1
.3a14bb	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a14be	69 01 00	adc #$0001	            ADC #1
.3a14c1	85 23		sta $0823	            STA ARGUMENT1
.3a14c3	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a14c5	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a14c8	69 00 00	adc #$0000	            ADC #0
.3a14cb	85 25		sta $0825	            STA ARGUMENT1+2
.3a14cd	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.3a14d0	85 0c		sta $080c	            STA SCRATCH
.3a14d2					start_cnvt
.3a14d2	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.3a14d4	64 12		stz $0812	            STZ SCRATCH2+2
.3a14d6	64 14		stz $0814	            STZ SCRATCH2+4
.3a14d8	a2 1f 00	ldx #$001f	            LDX #31
.3a14db	f8		sed		            SED                 ; Yes, we're really using BCD mode
.3a14dc	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.3a14de	26 25		rol $0825	            ROL ARGUMENT1+2
.3a14e0	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.3a14e2	65 10		adc $0810	            ADC SCRATCH2
.3a14e4	85 10		sta $0810	            STA SCRATCH2
.3a14e6	a5 12		lda $0812	            LDA SCRATCH2+2
.3a14e8	65 12		adc $0812	            ADC SCRATCH2+2
.3a14ea	85 12		sta $0812	            STA SCRATCH2+2
.3a14ec	a5 14		lda $0814	            LDA SCRATCH2+4
.3a14ee	65 14		adc $0814	            ADC SCRATCH2+4
.3a14f0	85 14		sta $0814	            STA SCRATCH2+4
.3a14f2	ca		dex		            DEX
.3a14f3	10 e7		bpl $3a14dc	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.3a14f5	d8		cld		            CLD                 ; Switch back out of BCD mode
.3a14f6	e2 20		sep #$20	            SEP #$20
.3a14f8	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a14fb	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.3a14fe	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.3a1500	f0 04		beq $3a1506	            BEQ is_pos          ; No: write a leading space
.3a1502	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.3a1504	80 02		bra $3a1508	            BRA wr_lead
.3a1506	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.3a1508	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.3a150a	c8		iny		            INY
.3a150b	a2 05 00	ldx #$0005	            LDX #5
.3a150e	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.3a1510	29 f0		and #$f0	            AND #$F0
.3a1512	4a		lsr a		            LSR A
.3a1513	4a		lsr a		            LSR A
.3a1514	4a		lsr a		            LSR A
.3a1515	4a		lsr a		            LSR A
.3a1516	20 a0 14	jsr $3a14a0	            JSR ITOS_DIGIT
.3a1519	b5 10		lda $0810,x	            LDA SCRATCH2,X
.3a151b	29 0f		and #$0f	            AND #$0F
.3a151d	20 a0 14	jsr $3a14a0	            JSR ITOS_DIGIT
.3a1520	ca		dex		            DEX
.3a1521	10 eb		bpl $3a150e	            BPL ascii_loop
.3a1523	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.3a1526	d0 0c		bne $3a1534	            BNE null_term       ; Yes: add a NULL to terminate
.3a1528	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.3a152a	87 16		sta [$0816]	            STA [STRPTR]
.3a152c	a0 01 00	ldy #$0001	            LDY #1
.3a152f	a9 30		lda #$30	            LDA #'0'
.3a1531	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1533	c8		iny		            INY
.3a1534	a9 00		lda #$00	null_term   LDA #0
.3a1536	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.3a1538	28		plp		done        PLP
.3a1539	60		rts		            RTS
.3a153a	00		brk #		fault       BRK
.3a153b	ea		nop		            NOP
.3a153c					STRLEN
.3a153c	08		php		            PHP
.3a153d	e2 20		sep #$20	            SEP #$20
.3a153f	c2 10		rep #$10	            REP #$10
.3a1541	a0 00 00	ldy #$0000	            LDY #0
.3a1544	bd 00 00	lda $3a0000,x	loop        LDA #0,B,X
.3a1547	f0 04		beq $3a154d	            BEQ done
.3a1549	e8		inx		            INX
.3a154a	c8		iny		            INY
.3a154b	80 f7		bra $3a1544	            BRA loop
.3a154d	28		plp		done        PLP
.3a154e	60		rts		            RTS
.3a154f					STRCMP
.3a154f	08		php		            PHP
.3a1550	0b		phd		            PHD
.3a1551	08		php		            PHP
.3a1552	c2 20		rep #$20	            REP #$20
.3a1554	48		pha		            PHA
.3a1555	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1558	5b		tcd		            TCD
.3a1559	68		pla		            PLA
.3a155a	28		plp		            PLP
.3a155b	e2 20		sep #$20	            SEP #$20
.3a155d	c2 10		rep #$10	            REP #$10
.3a155f	a0 00 00	ldy #$0000	            LDY #0
.3a1562	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.3a1564	d0 04		bne $3a156a	            BNE comp_mag            ; If not, check the magnitudes
.3a1566	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.3a1568	f0 25		beq $3a158f	            BEQ are_equal           ; If so, the strings are equal
.3a156a	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.3a156c	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.3a156e	90 12		bcc $3a1582	            BLT is_less             ; Check if character 1 < character 2
.3a1570	d0 03		bne $3a1575	            BNE is_greater          ; Check if character 1 > character 2
.3a1572	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.3a1573	80 ed		bra $3a1562	            BRA loop
.3a1575					is_greater
.3a1575	c2 20		rep #$20	            REP #$20
.3a1577	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.3a157a	85 23		sta $0823	            STA ARGUMENT1
.3a157c	e2 20		sep #$20	            SEP #$20
.3a157e	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1580	80 15		bra $3a1597	            BRA done
.3a1582					is_less
.3a1582	c2 20		rep #$20	            REP #$20
.3a1584	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.3a1587	85 23		sta $0823	            STA ARGUMENT1
.3a1589	e2 20		sep #$20	            SEP #$20
.3a158b	85 25		sta $0825	            STA ARGUMENT1+2
.3a158d	80 08		bra $3a1597	            BRA done
.3a158f					are_equal
.3a158f	c2 20		rep #$20	            REP #$20
.3a1591	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.3a1593	e2 20		sep #$20	            SEP #$20
.3a1595	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1597					done
.3a1597	e2 20		sep #$20	            SEP #$20
.3a1599	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a159b	85 27		sta $0827	            STA ARGTYPE1
.3a159d	2b		pld		            PLD
.3a159e	28		plp		            PLP
.3a159f	60		rts		            RTS
.3a15a0					STRCONCAT
.3a15a0	08		php		            PHP
.3a15a1	0b		phd		            PHD
.3a15a2	8b		phb		            PHB
.3a15a3	08		php		            PHP
.3a15a4	c2 20		rep #$20	            REP #$20
.3a15a6	48		pha		            PHA
.3a15a7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a15aa	5b		tcd		            TCD
.3a15ab	68		pla		            PLA
.3a15ac	28		plp		            PLP
.3a15ad	e2 20		sep #$20	            SEP #$20
.3a15af	c2 10		rep #$10	            REP #$10
.3a15b1	08		php		            PHP
.3a15b2	c2 20		rep #$20	            REP #$20
.3a15b4	48		pha		            PHA
.3a15b5	e2 20		sep #$20	            SEP #$20
.3a15b7	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a15b9	48		pha		            PHA
.3a15ba	ab		plb		            PLB
.3a15bb	c2 20		rep #$20	            REP #$20
.3a15bd	68		pla		            PLA
.3a15be	28		plp		            PLP
.3a15bf	a6 23		ldx $0823	            LDX ARGUMENT1
.3a15c1	20 3c 15	jsr $3a153c	            JSR STRLEN
.3a15c4	84 0c		sty $080c	            STY SCRATCH
.3a15c6	08		php		            PHP
.3a15c7	c2 20		rep #$20	            REP #$20
.3a15c9	48		pha		            PHA
.3a15ca	e2 20		sep #$20	            SEP #$20
.3a15cc	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a15ce	48		pha		            PHA
.3a15cf	ab		plb		            PLB
.3a15d0	c2 20		rep #$20	            REP #$20
.3a15d2	68		pla		            PLA
.3a15d3	28		plp		            PLP
.3a15d4	a6 29		ldx $0829	            LDX ARGUMENT2
.3a15d6	20 3c 15	jsr $3a153c	            JSR STRLEN
.3a15d9	c2 20		rep #$20	            REP #$20
.3a15db	98		tya		            TYA
.3a15dc	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.3a15dd	65 0c		adc $080c	            ADC SCRATCH
.3a15df	aa		tax		            TAX
.3a15e0	e2 20		sep #$20	            SEP #$20
.3a15e2	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.3a15e4	20 22 10	jsr $3a1022	            JSR ALLOC
.3a15e7	c2 20		rep #$20	            REP #$20
.3a15e9	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.3a15eb	85 08		sta $0808	            STA INDEX
.3a15ed	e2 20		sep #$20	            SEP #$20
.3a15ef	a5 b9		lda $08b9	            LDA ALLOCATED+2
.3a15f1	85 0a		sta $080a	            STA INDEX+2
.3a15f3	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.3a15f6	08		php		            PHP
.3a15f7	c2 20		rep #$20	            REP #$20
.3a15f9	48		pha		            PHA
.3a15fa	e2 20		sep #$20	            SEP #$20
.3a15fc	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a15fe	48		pha		            PHA
.3a15ff	ab		plb		            PLB
.3a1600	c2 20		rep #$20	            REP #$20
.3a1602	68		pla		            PLA
.3a1603	28		plp		            PLP
.3a1604	a6 23		ldx $0823	            LDX ARGUMENT1
.3a1606	bd 00 00	lda $3a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.3a1609	f0 06		beq $3a1611	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.3a160b	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a160d	e8		inx		            INX                     ; Point to the next characters
.3a160e	c8		iny		            INY
.3a160f	80 f5		bra $3a1606	            BRA loop1               ; And do again
.3a1611					copy_2
.3a1611	e2 20		sep #$20	            SEP #$20
.3a1613	08		php		            PHP
.3a1614	c2 20		rep #$20	            REP #$20
.3a1616	48		pha		            PHA
.3a1617	e2 20		sep #$20	            SEP #$20
.3a1619	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a161b	48		pha		            PHA
.3a161c	ab		plb		            PLB
.3a161d	c2 20		rep #$20	            REP #$20
.3a161f	68		pla		            PLA
.3a1620	28		plp		            PLP
.3a1621	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1623	bd 00 00	lda $3a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.3a1626	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a1628	f0 04		beq $3a162e	            BEQ terminate           ; Is it null? Yes: move on to the next string
.3a162a	e8		inx		            INX                     ; Point to the next characters
.3a162b	c8		iny		            INY
.3a162c	80 f5		bra $3a1623	            BRA loop2               ; And do again
.3a162e					terminate
.3a162e	c2 20		rep #$20	            REP #$20
.3a1630	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.3a1632	85 23		sta $0823	            STA ARGUMENT1
.3a1634	e2 20		sep #$20	            SEP #$20
.3a1636	a5 0a		lda $080a	            LDA INDEX+2
.3a1638	85 25		sta $0825	            STA ARGUMENT1+2
.3a163a	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.3a163c	85 27		sta $0827	            STA ARGTYPE1
.3a163e	ab		plb		            PLB
.3a163f	2b		pld		            PLD
.3a1640	28		plp		            PLP
.3a1641	60		rts		            RTS
.3a1642					STRCPY
.3a1642	da		phx		            PHX
.3a1643	5a		phy		            PHY
.3a1644	08		php		            PHP
.3a1645	0b		phd		            PHD
.3a1646	8b		phb		            PHB
.3a1647	08		php		            PHP
.3a1648	c2 20		rep #$20	            REP #$20
.3a164a	48		pha		            PHA
.3a164b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a164e	5b		tcd		            TCD
.3a164f	68		pla		            PLA
.3a1650	28		plp		            PLP
.3a1651	c2 20		rep #$20	            REP #$20
.3a1653	a5 0a		lda $080a	            LDA INDEX+2
.3a1655	48		pha		            PHA
.3a1656	a5 08		lda $0808	            LDA INDEX
.3a1658	48		pha		            PHA
.3a1659	c2 30		rep #$30	            REP #$30
.3a165b	08		php		            PHP
.3a165c	c2 20		rep #$20	            REP #$20
.3a165e	48		pha		            PHA
.3a165f	e2 20		sep #$20	            SEP #$20
.3a1661	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1663	48		pha		            PHA
.3a1664	ab		plb		            PLB
.3a1665	c2 20		rep #$20	            REP #$20
.3a1667	68		pla		            PLA
.3a1668	28		plp		            PLP
.3a1669	a6 23		ldx $0823	            LDX ARGUMENT1
.3a166b	20 3c 15	jsr $3a153c	            JSR STRLEN
.3a166e	98		tya		            TYA
.3a166f	aa		tax		            TAX
.3a1670	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.3a1671	e2 20		sep #$20	            SEP #$20
.3a1673	a9 02		lda #$02	            LDA #TYPE_STRING
.3a1675	20 22 10	jsr $3a1022	            JSR ALLOC
.3a1678	c2 20		rep #$20	            REP #$20
.3a167a	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a167c	85 08		sta $0808	            STA INDEX
.3a167e	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1680	85 0a		sta $080a	            STA INDEX+2
.3a1682	a0 00 00	ldy #$0000	            LDY #0
.3a1685	e2 20		sep #$20	            SEP #$20
.3a1687	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.3a1689	97 08		sta [$0808],y	            STA [INDEX],Y
.3a168b	f0 03		beq $3a1690	            BEQ ret_copy
.3a168d	c8		iny		            INY
.3a168e	80 f7		bra $3a1687	            BRA loop
.3a1690					ret_copy
.3a1690	c2 20		rep #$20	            REP #$20
.3a1692	a5 08		lda $0808	            LDA INDEX
.3a1694	85 23		sta $0823	            STA ARGUMENT1
.3a1696	a5 0a		lda $080a	            LDA INDEX+2
.3a1698	85 25		sta $0825	            STA ARGUMENT1+2
.3a169a	c2 20		rep #$20	            REP #$20
.3a169c	68		pla		            PLA
.3a169d	85 08		sta $0808	            STA INDEX
.3a169f	68		pla		            PLA
.3a16a0	85 0a		sta $080a	            STA INDEX+2
.3a16a2	ab		plb		            PLB
.3a16a3	2b		pld		            PLD
.3a16a4	28		plp		            PLP
.3a16a5	7a		ply		            PLY
.3a16a6	fa		plx		            PLX
.3a16a7	60		rts		            RTS
.3a16a8					STRSUBSTR
.3a16a8	08		php		            PHP
.3a16a9	e2 20		sep #$20	            SEP #$20
.3a16ab	c2 10		rep #$10	            REP #$10
.3a16ad	a0 00 00	ldy #$0000	            LDY #0
.3a16b0	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.3a16b2	f0 05		beq $3a16b9	            BEQ counted
.3a16b4	c8		iny		            INY
.3a16b5	80 f9		bra $3a16b0	            BRA count_loop
.3a16b7	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.3a16b9					counted
.3a16b9	c2 30		rep #$30	            REP #$30
.3a16bb	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.3a16bd	90 13		bcc $3a16d2	            BLT ret_empty           ; Yes: return empty string
.3a16bf	f0 11		beq $3a16d2	            BEQ ret_empty
.3a16c1	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.3a16c3	30 0d		bmi $3a16d2	            BMI ret_empty
.3a16c5	f0 0b		beq $3a16d2	            BEQ ret_empty           ; Yes: return the empty string
.3a16c7	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.3a16c9	b0 12		bcs $3a16dd	            BGE do_slice            ; Yes: go ahead and get the substring
.3a16cb	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.3a16cd	d0 0e		bne $3a16dd	            BNE do_slice            ; No: do a slice
.3a16cf	4c 26 17	jmp $3a1726	            JMP done                ; Yes: just return the source string
.3a16d2					ret_empty
.3a16d2	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a16d5	e2 20		sep #$20	            SEP #$20
.3a16d7	a9 00		lda #$00	            LDA #0
.3a16d9	87 16		sta [$0816]	            STA [STRPTR]
.3a16db	80 39		bra $3a1716	            BRA finish_copy
.3a16dd					do_slice
.3a16dd	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a16e0	c2 30		rep #$30	            REP #$30
.3a16e2	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.3a16e3	a5 23		lda $0823	            LDA ARGUMENT1
.3a16e5	65 29		adc $0829	            ADC ARGUMENT2
.3a16e7	85 23		sta $0823	            STA ARGUMENT1
.3a16e9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a16eb	69 00 00	adc #$0000	            ADC #0
.3a16ee	85 25		sta $0825	            STA ARGUMENT1+2
.3a16f0	a0 00 00	ldy #$0000	            LDY #0
.3a16f3					copy_loop
.3a16f3	e2 20		sep #$20	            SEP #$20
.3a16f5	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.3a16f7	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a16f9	f0 1b		beq $3a1716	            BEQ finish_copy         ; If it is a NULL, we're done
.3a16fb	c2 20		rep #$20	            REP #$20
.3a16fd	18		clc		            CLC                     ; Move to the next character
.3a16fe	a5 23		lda $0823	            LDA ARGUMENT1
.3a1700	69 01 00	adc #$0001	            ADC #1
.3a1703	85 23		sta $0823	            STA ARGUMENT1
.3a1705	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1707	69 00 00	adc #$0000	            ADC #0
.3a170a	85 25		sta $0825	            STA ARGUMENT1+2
.3a170c	c8		iny		            INY
.3a170d	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.3a170f	d0 e2		bne $3a16f3	            BNE copy_loop           ; No: copy the next byte
.3a1711	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.3a1714	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1716					finish_copy
.3a1716	c2 20		rep #$20	            REP #$20
.3a1718	a5 16		lda $0816	            LDA STRPTR
.3a171a	85 23		sta $0823	            STA ARGUMENT1
.3a171c	a5 18		lda $0818	            LDA STRPTR+2
.3a171e	85 25		sta $0825	            STA ARGUMENT1+2
.3a1720	e2 20		sep #$20	            SEP #$20
.3a1722	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a1724	85 27		sta $0827	            STA ARGTYPE1
.3a1726					done
.3a1726	28		plp		            PLP
.3a1727	60		rts		            RTS
.3a1728					OP_STR_LT
.3a1728	08		php		            PHP
.3a1729	c2 30		rep #$30	            REP #$30
.3a172b	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a172e	a5 23		lda $0823	            LDA ARGUMENT1
.3a1730	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a1733	d0 05		bne $3a173a	            BNE ret_false               ; No: return false
.3a1735					ret_true
.3a1735	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a1738	80 03		bra $3a173d	            BRA done
.3a173a					ret_false
.3a173a	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a173d	28		plp		done        PLP
.3a173e	60		rts		            RTS
.3a173f					OP_STR_GT
.3a173f	08		php		            PHP
.3a1740	c2 30		rep #$30	            REP #$30
.3a1742	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a1745	a5 23		lda $0823	            LDA ARGUMENT1
.3a1747	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a174a	d0 05		bne $3a1751	            BNE ret_false               ; No: return false
.3a174c					ret_true
.3a174c	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a174f	80 03		bra $3a1754	            BRA done
.3a1751					ret_false
.3a1751	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a1754	28		plp		done        PLP
.3a1755	60		rts		            RTS
.3a1756					OP_STR_EQ
.3a1756	08		php		            PHP
.3a1757	c2 30		rep #$30	            REP #$30
.3a1759	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a175c	a5 23		lda $0823	            LDA ARGUMENT1
.3a175e	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a1761	d0 05		bne $3a1768	            BNE ret_false               ; No: return false
.3a1763					ret_true
.3a1763	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a1766	80 03		bra $3a176b	            BRA done
.3a1768					ret_false
.3a1768	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a176b	28		plp		done        PLP
.3a176c	60		rts		            RTS
.3a176d					OP_STR_NE
.3a176d	08		php		            PHP
.3a176e	c2 30		rep #$30	            REP #$30
.3a1770	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a1773	a5 23		lda $0823	            LDA ARGUMENT1
.3a1775	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a1778	f0 05		beq $3a177f	            BEQ ret_false               ; Yes: return false
.3a177a					ret_true
.3a177a	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a177d	80 03		bra $3a1782	            BRA done
.3a177f					ret_false
.3a177f	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a1782	28		plp		done        PLP
.3a1783	60		rts		            RTS
.3a1784					OP_STR_GTE
.3a1784	08		php		            PHP
.3a1785	c2 30		rep #$30	            REP #$30
.3a1787	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a178a	a5 23		lda $0823	            LDA ARGUMENT1
.3a178c	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a178f	f0 05		beq $3a1796	            BEQ ret_false               ; Yes: return false
.3a1791					ret_true
.3a1791	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a1794	80 03		bra $3a1799	            BRA done
.3a1796					ret_false
.3a1796	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a1799	28		plp		done        PLP
.3a179a	60		rts		            RTS
.3a179b					OP_STR_LTE
.3a179b	08		php		            PHP
.3a179c	c2 30		rep #$30	            REP #$30
.3a179e	20 4f 15	jsr $3a154f	            JSR STRCMP
.3a17a1	a5 23		lda $0823	            LDA ARGUMENT1
.3a17a3	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a17a6	f0 05		beq $3a17ad	            BEQ ret_false               ; Yes: return false
.3a17a8					ret_true
.3a17a8	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a17ab	80 03		bra $3a17b0	            BRA done
.3a17ad					ret_false
.3a17ad	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a17b0	28		plp		done        PLP
.3a17b1	60		rts		            RTS
.3a17b2					STR_NORMAL
.3a17b2	08		php		            PHP
.3a17b3	e2 20		sep #$20	            SEP #$20
.3a17b5	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.3a17b7	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a17b9	d0 1d		bne $3a17d8	            BNE done                ; No: return it
.3a17bb	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.3a17bd	d0 19		bne $3a17d8	            BNE done
.3a17bf	a5 24		lda $0824	            LDA ARGUMENT1+1
.3a17c1	d0 15		bne $3a17d8	            BNE done
.3a17c3	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a17c5	d0 11		bne $3a17d8	            BNE done                ; No: return it
.3a17c7	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a17ca	a9 00		lda #$00	            LDA #0
.3a17cc	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.3a17ce	c2 20		rep #$20	            REP #$20
.3a17d0	a5 16		lda $0816	            LDA STRPTR
.3a17d2	85 23		sta $0823	            STA ARGUMENT1
.3a17d4	a5 18		lda $0818	            LDA STRPTR+2
.3a17d6	85 25		sta $0825	            STA ARGUMENT1+2
.3a17d8	28		plp		done        PLP
.3a17d9	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.3a17da					LISTPROG
.3a17da	48		pha		            PHA
.3a17db	5a		phy		            PHY
.3a17dc	0b		phd		            PHD
.3a17dd	08		php		            PHP
.3a17de	08		php		            PHP
.3a17df	c2 20		rep #$20	            REP #$20
.3a17e1	48		pha		            PHA
.3a17e2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a17e5	5b		tcd		            TCD
.3a17e6	68		pla		            PLA
.3a17e7	28		plp		            PLP
.3a17e8	c2 30		rep #$30	            REP #$30
.3a17ea	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a17ed	85 00		sta $0800	            STA BIP
.3a17ef	85 1a		sta $081a	            STA CURLINE
.3a17f1	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a17f4	85 02		sta $0802	            STA BIP+2
.3a17f6	85 1c		sta $081c	            STA CURLINE+2
.3a17f8	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.3a17fc	b0 20		bcs $3a181e	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.3a17fe	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a1801	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a1803	f0 0f		beq $3a1814	            BEQ done
.3a1805	c5 55		cmp $0855	            CMP MARG1
.3a1807	90 10		bcc $3a1819	            BLT skip_line
.3a1809	c5 59		cmp $0859	            CMP MARG2
.3a180b	f0 02		beq $3a180f	            BEQ print_line
.3a180d	b0 05		bcs $3a1814	            BGE done
.3a180f					print_line
.3a180f	20 3d 18	jsr $3a183d	            JSR LISTLINE
.3a1812	80 e4		bra $3a17f8	            BRA list_loop
.3a1814	28		plp		done        PLP
.3a1815	2b		pld		            PLD
.3a1816	7a		ply		            PLY
.3a1817	68		pla		            PLA
.3a1818	60		rts		            RTS
.3a1819					skip_line
.3a1819	20 49 21	jsr $3a2149	            JSR NEXTLINE
.3a181c	80 da		bra $3a17f8	            BRA list_loop           ; And try again
.3a181e					throw_break
.3a181e	08		php		            PHP
.3a181f	c2 20		rep #$20	            REP #$20
.3a1821	48		pha		            PHA
.3a1822	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1825	5b		tcd		            TCD
.3a1826	68		pla		            PLA
.3a1827	28		plp		            PLP
.3a1828	e2 20		sep #$20	            SEP #$20
.3a182a	a9 01		lda #$01	            LDA #ERR_BREAK
.3a182c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1830	c2 20		rep #$20	            REP #$20
.3a1832	29 ff 00	and #$00ff	            AND #$00FF
.3a1835	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1838	e2 20		sep #$20	            SEP #$20
.3a183a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a183d					LISTLINE
.3a183d	08		php		            PHP
.3a183e	c2 30		rep #$30	            REP #$30
.3a1840	85 23		sta $0823	            STA ARGUMENT1
.3a1842	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1844	20 af 14	jsr $3a14af	            JSR ITOS
.3a1847	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a1849	1a		inc a		            INC A
.3a184a	85 23		sta $0823	            STA ARGUMENT1
.3a184c	a5 18		lda $0818	            LDA STRPTR+2
.3a184e	85 25		sta $0825	            STA ARGUMENT1+2
.3a1850	20 02 45	jsr $3a4502	            JSR PR_STRING
.3a1853	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.3a1854	a5 1a		lda $081a	            LDA CURLINE
.3a1856	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a1859	85 00		sta $0800	            STA BIP
.3a185b	a5 1c		lda $081c	            LDA CURLINE+2
.3a185d	69 00 00	adc #$0000	            ADC #0
.3a1860	85 02		sta $0802	            STA BIP+2
.3a1862	e2 20		sep #$20	            SEP #$20
.3a1864	a9 20		lda #$20	            LDA #CHAR_SP
.3a1866	20 18 00	jsr $3a0018	            JSR PRINTC
.3a1869	c2 20		rep #$20	            REP #$20
.3a186b					loop
.3a186b	20 7c 18	jsr $3a187c	            JSR LISTBYTE
.3a186e	90 fb		bcc $3a186b	            BCC loop
.3a1870	e2 20		sep #$20	            SEP #$20
.3a1872	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a1874	20 18 00	jsr $3a0018	            JSR PRINTC
.3a1877	20 49 21	jsr $3a2149	            JSR NEXTLINE
.3a187a	28		plp		            PLP
.3a187b	60		rts		            RTS
.3a187c					LISTBYTE
.3a187c	08		php		            PHP
.3a187d	0b		phd		            PHD
.3a187e	8b		phb		            PHB
.3a187f	08		php		            PHP
.3a1880	c2 20		rep #$20	            REP #$20
.3a1882	48		pha		            PHA
.3a1883	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1886	5b		tcd		            TCD
.3a1887	68		pla		            PLA
.3a1888	28		plp		            PLP
.3a1889	08		php		            PHP
.3a188a	e2 20		sep #$20	            SEP #$20
.3a188c	48		pha		            PHA
.3a188d	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a188f	48		pha		            PHA
.3a1890	ab		plb		            PLB
.3a1891	68		pla		            PLA
.3a1892	28		plp		            PLP
.3a1893	e2 20		sep #$20	            SEP #$20
.3a1895	c2 10		rep #$10	            REP #$10
.3a1897	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.3a1899	f0 3a		beq $3a18d5	            BEQ end_of_line     ; If it's 0, return with C set
.3a189b	30 05		bmi $3a18a2	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.3a189d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a18a0	80 29		bra $3a18cb	            BRA done            ; And return
.3a18a2					is_token
.3a18a2	c2 20		rep #$20	            REP #$20
.3a18a4	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.3a18a7	0a		asl a		            ASL A               ; In the token table
.3a18a8	0a		asl a		            ASL A
.3a18a9	0a		asl a		            ASL A
.3a18aa	18		clc		            CLC
.3a18ab	69 52 0c	adc #$0c52	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.3a18ae	85 08		sta $0808	            STA INDEX
.3a18b0	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a18b3	69 00 00	adc #$0000	            ADC #0
.3a18b6	85 0a		sta $080a	            STA INDEX+2
.3a18b8					pr_default
.3a18b8	08		php		            PHP
.3a18b9	e2 20		sep #$20	            SEP #$20
.3a18bb	48		pha		            PHA
.3a18bc	a9 3a		lda #$3a	            LDA #`TOKENS
.3a18be	48		pha		            PHA
.3a18bf	ab		plb		            PLB
.3a18c0	68		pla		            PLA
.3a18c1	28		plp		            PLP
.3a18c2	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a18c5	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a18c7	aa		tax		            TAX
.3a18c8	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a18cb					done
.3a18cb	c2 20		rep #$20	            REP #$20
.3a18cd	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a18d0	ab		plb		            PLB
.3a18d1	2b		pld		            PLD
.3a18d2	28		plp		            PLP
.3a18d3	18		clc		            CLC
.3a18d4	60		rts		            RTS
.3a18d5	ab		plb		end_of_line PLB
.3a18d6	2b		pld		            PLD
.3a18d7	28		plp		            PLP
.3a18d8	38		sec		            SEC
.3a18d9	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.3a18da					INITEVALSP
.3a18da	08		php		            PHP
.3a18db	c2 20		rep #$20	            REP #$20
.3a18dd	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.3a18e0	85 1f		sta $081f	            STA ARGUMENTSP
.3a18e2	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.3a18e5	85 21		sta $0821	            STA OPERATORSP
.3a18e7	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a18ea	85 23		sta $0823	            STA ARGUMENT1
.3a18ec	85 25		sta $0825	            STA ARGUMENT1+2
.3a18ee	85 29		sta $0829	            STA ARGUMENT2
.3a18f0	85 2b		sta $082b	            STA ARGUMENT2+2
.3a18f2	e2 20		sep #$20	            SEP #$20
.3a18f4	85 27		sta $0827	            STA ARGTYPE1
.3a18f6	85 2d		sta $082d	            STA ARGTYPE2
.3a18f8	28		plp		            PLP
.3a18f9	60		rts		            RTS
.3a18fa					PHARGUMENT
.3a18fa	08		php		            PHP
.3a18fb	0b		phd		            PHD
.3a18fc	8b		phb		            PHB
.3a18fd	08		php		            PHP
.3a18fe	c2 20		rep #$20	            REP #$20
.3a1900	48		pha		            PHA
.3a1901	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1904	5b		tcd		            TCD
.3a1905	68		pla		            PLA
.3a1906	28		plp		            PLP
.3a1907	08		php		            PHP
.3a1908	e2 20		sep #$20	            SEP #$20
.3a190a	48		pha		            PHA
.3a190b	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a190d	48		pha		            PHA
.3a190e	ab		plb		            PLB
.3a190f	68		pla		            PLA
.3a1910	28		plp		            PLP
.3a1911	c2 30		rep #$30	            REP #$30
.3a1913	5a		phy		            PHY
.3a1914	a4 1f		ldy $081f	            LDY ARGUMENTSP
.3a1916	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a1919	99 00 00	sta $0000,y	            STA #0,B,Y
.3a191c	bd 02 00	lda $0002,x	            LDA #2,B,X
.3a191f	99 02 00	sta $0002,y	            STA #2,B,Y
.3a1922	e2 20		sep #$20	            SEP #$20
.3a1924	bd 04 00	lda $0004,x	            LDA #4,B,X
.3a1927	99 04 00	sta $0004,y	            STA #4,B,Y
.3a192a	c2 20		rep #$20	            REP #$20
.3a192c	38		sec		            SEC
.3a192d	98		tya		            TYA
.3a192e	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.3a1931	85 1f		sta $081f	            STA ARGUMENTSP
.3a1933	7a		ply		            PLY
.3a1934	ab		plb		            PLB
.3a1935	2b		pld		            PLD
.3a1936	28		plp		            PLP
.3a1937	60		rts		            RTS
.3a1938					PLARGUMENT
.3a1938	08		php		            PHP
.3a1939	0b		phd		            PHD
.3a193a	8b		phb		            PHB
.3a193b	08		php		            PHP
.3a193c	c2 20		rep #$20	            REP #$20
.3a193e	48		pha		            PHA
.3a193f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1942	5b		tcd		            TCD
.3a1943	68		pla		            PLA
.3a1944	28		plp		            PLP
.3a1945	08		php		            PHP
.3a1946	e2 20		sep #$20	            SEP #$20
.3a1948	48		pha		            PHA
.3a1949	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a194b	48		pha		            PHA
.3a194c	ab		plb		            PLB
.3a194d	68		pla		            PLA
.3a194e	28		plp		            PLP
.3a194f	c2 30		rep #$30	            REP #$30
.3a1951	5a		phy		            PHY
.3a1952	18		clc		            CLC
.3a1953	a5 1f		lda $081f	            LDA ARGUMENTSP
.3a1955	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.3a1958	85 1f		sta $081f	            STA ARGUMENTSP
.3a195a	a8		tay		            TAY
.3a195b	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a195e	9d 00 00	sta $0000,x	            STA #0,B,X
.3a1961	b9 02 00	lda $0002,y	            LDA #2,B,Y
.3a1964	9d 02 00	sta $0002,x	            STA #2,B,X
.3a1967	e2 20		sep #$20	            SEP #$20
.3a1969	b9 04 00	lda $0004,y	            LDA #4,B,Y
.3a196c	9d 04 00	sta $0004,x	            STA #4,B,X
.3a196f	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a1972	7a		ply		            PLY
.3a1973	ab		plb		            PLB
.3a1974	2b		pld		            PLD
.3a1975	28		plp		            PLP
.3a1976	60		rts		            RTS
.3a1977					PHOPERATOR
.3a1977	08		php		            PHP
.3a1978	0b		phd		            PHD
.3a1979	8b		phb		            PHB
.3a197a	08		php		            PHP
.3a197b	c2 20		rep #$20	            REP #$20
.3a197d	48		pha		            PHA
.3a197e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1981	5b		tcd		            TCD
.3a1982	68		pla		            PLA
.3a1983	28		plp		            PLP
.3a1984	08		php		            PHP
.3a1985	e2 20		sep #$20	            SEP #$20
.3a1987	48		pha		            PHA
.3a1988	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a198a	48		pha		            PHA
.3a198b	ab		plb		            PLB
.3a198c	68		pla		            PLA
.3a198d	28		plp		            PLP
.3a198e	e2 20		sep #$20	            SEP #$20
.3a1990	c2 10		rep #$10	            REP #$10
.3a1992	5a		phy		            PHY
.3a1993	a4 21		ldy $0821	            LDY OPERATORSP
.3a1995	99 00 00	sta $0000,y	            STA #0,B,Y
.3a1998	88		dey		            DEY
.3a1999	84 21		sty $0821	            STY OPERATORSP
.3a199b	7a		ply		done        PLY
.3a199c	ab		plb		            PLB
.3a199d	2b		pld		            PLD
.3a199e	28		plp		            PLP
.3a199f	60		rts		            RTS
.3a19a0					PLOPERATOR
.3a19a0	08		php		            PHP
.3a19a1	0b		phd		            PHD
.3a19a2	8b		phb		            PHB
.3a19a3	08		php		            PHP
.3a19a4	c2 20		rep #$20	            REP #$20
.3a19a6	48		pha		            PHA
.3a19a7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a19aa	5b		tcd		            TCD
.3a19ab	68		pla		            PLA
.3a19ac	28		plp		            PLP
.3a19ad	08		php		            PHP
.3a19ae	e2 20		sep #$20	            SEP #$20
.3a19b0	48		pha		            PHA
.3a19b1	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a19b3	48		pha		            PHA
.3a19b4	ab		plb		            PLB
.3a19b5	68		pla		            PLA
.3a19b6	28		plp		            PLP
.3a19b7	e2 20		sep #$20	            SEP #$20
.3a19b9	c2 10		rep #$10	            REP #$10
.3a19bb	5a		phy		            PHY
.3a19bc	a4 21		ldy $0821	            LDY OPERATORSP
.3a19be	c8		iny		            INY
.3a19bf	84 21		sty $0821	            STY OPERATORSP
.3a19c1	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a19c4	c2 20		rep #$20	            REP #$20
.3a19c6	29 ff 00	and #$00ff	            AND #$00FF
.3a19c9	7a		ply		            PLY
.3a19ca	ab		plb		            PLB
.3a19cb	2b		pld		            PLD
.3a19cc	28		plp		            PLP
.3a19cd	60		rts		            RTS
.3a19ce					OPENPARAMS
.3a19ce	08		php		            PHP
.3a19cf	e2 20		sep #$20	            SEP #$20
.3a19d1	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a19d3	20 77 19	jsr $3a1977	            JSR PHOPERATOR
.3a19d6	28		plp		            PLP
.3a19d7	60		rts		            RTS
.3a19d8					CLOSEPARAMS
.3a19d8	5a		phy		            PHY
.3a19d9	08		php		            PHP
.3a19da	8b		phb		            PHB
.3a19db	08		php		            PHP
.3a19dc	e2 20		sep #$20	            SEP #$20
.3a19de	48		pha		            PHA
.3a19df	a9 00		lda #$00	            LDA #0
.3a19e1	48		pha		            PHA
.3a19e2	ab		plb		            PLB
.3a19e3	68		pla		            PLA
.3a19e4	28		plp		            PLP
.3a19e5	e2 20		sep #$20	            SEP #$20
.3a19e7	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.3a19e9	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a19ec	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.3a19ee	d0 08		bne $3a19f8	            BNE error           ; No: there's a problem
.3a19f0	c2 20		rep #$20	            REP #$20
.3a19f2	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.3a19f4	ab		plb		            PLB
.3a19f5	28		plp		            PLP
.3a19f6	7a		ply		            PLY
.3a19f7	60		rts		            RTS
.3a19f8					error
.3a19f8	08		php		            PHP
.3a19f9	c2 20		rep #$20	            REP #$20
.3a19fb	48		pha		            PHA
.3a19fc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a19ff	5b		tcd		            TCD
.3a1a00	68		pla		            PLA
.3a1a01	28		plp		            PLP
.3a1a02	e2 20		sep #$20	            SEP #$20
.3a1a04	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1a06	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1a0a	c2 20		rep #$20	            REP #$20
.3a1a0c	29 ff 00	and #$00ff	            AND #$00FF
.3a1a0f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1a12	e2 20		sep #$20	            SEP #$20
.3a1a14	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1a17					OPHIGHPREC
.3a1a17	48		pha		            PHA
.3a1a18	08		php		            PHP
.3a1a19	0b		phd		            PHD
.3a1a1a	8b		phb		            PHB
.3a1a1b	08		php		            PHP
.3a1a1c	c2 20		rep #$20	            REP #$20
.3a1a1e	48		pha		            PHA
.3a1a1f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a22	5b		tcd		            TCD
.3a1a23	68		pla		            PLA
.3a1a24	28		plp		            PLP
.3a1a25	08		php		            PHP
.3a1a26	e2 20		sep #$20	            SEP #$20
.3a1a28	48		pha		            PHA
.3a1a29	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1a2b	48		pha		            PHA
.3a1a2c	ab		plb		            PLB
.3a1a2d	68		pla		            PLA
.3a1a2e	28		plp		            PLP
.3a1a2f	e2 20		sep #$20	            SEP #$20
.3a1a31	a4 21		ldy $0821	            LDY OPERATORSP
.3a1a33	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.3a1a36	f0 11		beq $3a1a49	            BEQ is_false            ; Yes: return false
.3a1a38	20 b1 0b	jsr $3a0bb1	            JSR TOKPRECED
.3a1a3b	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.3a1a3d	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.3a1a40	20 b1 0b	jsr $3a0bb1	            JSR TOKPRECED
.3a1a43	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.3a1a45	f0 02		beq $3a1a49	            BEQ is_false            ; A = SCRATCH, return false
.3a1a47	90 08		bcc $3a1a51	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.3a1a49					is_false
.3a1a49	c2 20		rep #$20	            REP #$20
.3a1a4b	ab		plb		            PLB
.3a1a4c	2b		pld		            PLD
.3a1a4d	28		plp		            PLP
.3a1a4e	68		pla		            PLA
.3a1a4f	18		clc		            CLC
.3a1a50	60		rts		            RTS
.3a1a51					is_true
.3a1a51	c2 20		rep #$20	            REP #$20
.3a1a53	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.3a1a54	2b		pld		            PLD
.3a1a55	28		plp		            PLP
.3a1a56	68		pla		            PLA
.3a1a57	38		sec		            SEC
.3a1a58	60		rts		            RTS
.3a1a59					EVALNUMBER
.3a1a59	4c 2c 08	jmp $3a082c	            JMP PARSEINT
.3a1a5c					ARR_GETIDX
.3a1a5c	08		php		            PHP
.3a1a5d	e2 20		sep #$20	            SEP #$20
.3a1a5f	a9 00		lda #$00	            LDA #0
.3a1a61	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.3a1a65	a2 01 00	ldx #$0001	            LDX #1
.3a1a68					eval_index
.3a1a68	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a1a6b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a1a6e	c2 20		rep #$20	            REP #$20
.3a1a70	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.3a1a72	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.3a1a76	e2 20		sep #$20	            SEP #$20
.3a1a78	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.3a1a7c	1a		inc a		            INC A
.3a1a7d	30 3e		bmi $3a1abd	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.3a1a7f	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.3a1a83	e8		inx		            INX
.3a1a84	e8		inx		            INX
.3a1a85	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a1a88	e2 20		sep #$20	            SEP #$20
.3a1a8a	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a1a8c	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.3a1a8e	f0 09		beq $3a1a99	            BEQ clean_op        ; Yes: cleanup the argument stack
.3a1a90	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.3a1a92	d0 0a		bne $3a1a9e	            BNE syntax_err      ; No: throw a syntax error
.3a1a94					skip_comma
.3a1a94	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1a97	80 cf		bra $3a1a68	            BRA eval_index      ; And grab the next index
.3a1a99					clean_op
.3a1a99	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1a9c	28		plp		            PLP
.3a1a9d	60		rts		            RTS
.3a1a9e					syntax_err
.3a1a9e	08		php		            PHP
.3a1a9f	c2 20		rep #$20	            REP #$20
.3a1aa1	48		pha		            PHA
.3a1aa2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1aa5	5b		tcd		            TCD
.3a1aa6	68		pla		            PLA
.3a1aa7	28		plp		            PLP
.3a1aa8	e2 20		sep #$20	            SEP #$20
.3a1aaa	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1aac	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1ab0	c2 20		rep #$20	            REP #$20
.3a1ab2	29 ff 00	and #$00ff	            AND #$00FF
.3a1ab5	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1ab8	e2 20		sep #$20	            SEP #$20
.3a1aba	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1abd					arg_err
.3a1abd	08		php		            PHP
.3a1abe	c2 20		rep #$20	            REP #$20
.3a1ac0	48		pha		            PHA
.3a1ac1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1ac4	5b		tcd		            TCD
.3a1ac5	68		pla		            PLA
.3a1ac6	28		plp		            PLP
.3a1ac7	e2 20		sep #$20	            SEP #$20
.3a1ac9	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a1acb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1acf	c2 20		rep #$20	            REP #$20
.3a1ad1	29 ff 00	and #$00ff	            AND #$00FF
.3a1ad4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1ad7	e2 20		sep #$20	            SEP #$20
.3a1ad9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1adc					EVALREF
.3a1adc	08		php		            PHP
.3a1add					get_name
.3a1add	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a1ae0	90 47		bcc $3a1b29	            BCC syntax_err      ; If we didn't find a name, thrown an error
.3a1ae2	e2 20		sep #$20	            SEP #$20
.3a1ae4	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.3a1ae6	29 80		and #$80	            AND #$80            ; Is it an array?
.3a1ae8	d0 06		bne $3a1af0	            BNE is_array        ; Yes: look for the indexes
.3a1aea	20 c8 50	jsr $3a50c8	            JSR VAR_REF
.3a1aed	4c 27 1b	jmp $3a1b27	            JMP done
.3a1af0					is_array
.3a1af0	20 3a 50	jsr $3a503a	            JSR VAR_FIND
.3a1af3	90 53		bcc $3a1b48	            BCC notfound
.3a1af5	c2 20		rep #$20	            REP #$20
.3a1af7	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1af9	48		pha		            PHA
.3a1afa	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1afc	48		pha		            PHA
.3a1afd	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.3a1b00	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a1b02	85 c0		sta $08c0	            STA CURRBLOCK
.3a1b04	e2 20		sep #$20	            SEP #$20
.3a1b06	c8		iny		            INY
.3a1b07	c8		iny		            INY
.3a1b08	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1b0a	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1b0c	e2 20		sep #$20	            SEP #$20
.3a1b0e	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.3a1b10	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a1b13	20 ce 19	jsr $3a19ce	            JSR OPENPARAMS
.3a1b16					            PHARRIDX
.3a1b16	20 5c 1a	jsr $3a1a5c	            JSR ARR_GETIDX
.3a1b19	20 9e 67	jsr $3a679e	            JSR ARR_REF
.3a1b1c					            PLARRIDX
.3a1b1c	20 d8 19	jsr $3a19d8	            JSR CLOSEPARAMS
.3a1b1f	c2 20		rep #$20	            REP #$20
.3a1b21	68		pla		            PLA
.3a1b22	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1b24	68		pla		            PLA
.3a1b25	85 c0		sta $08c0	            STA CURRBLOCK
.3a1b27	28		plp		done        PLP
.3a1b28	60		rts		            RTS
.3a1b29					syntax_err
.3a1b29	08		php		            PHP
.3a1b2a	c2 20		rep #$20	            REP #$20
.3a1b2c	48		pha		            PHA
.3a1b2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b30	5b		tcd		            TCD
.3a1b31	68		pla		            PLA
.3a1b32	28		plp		            PLP
.3a1b33	e2 20		sep #$20	            SEP #$20
.3a1b35	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1b37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b3b	c2 20		rep #$20	            REP #$20
.3a1b3d	29 ff 00	and #$00ff	            AND #$00FF
.3a1b40	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1b43	e2 20		sep #$20	            SEP #$20
.3a1b45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b48					notfound
.3a1b48	08		php		            PHP
.3a1b49	c2 20		rep #$20	            REP #$20
.3a1b4b	48		pha		            PHA
.3a1b4c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b4f	5b		tcd		            TCD
.3a1b50	68		pla		            PLA
.3a1b51	28		plp		            PLP
.3a1b52	e2 20		sep #$20	            SEP #$20
.3a1b54	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a1b56	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b5a	c2 20		rep #$20	            REP #$20
.3a1b5c	29 ff 00	and #$00ff	            AND #$00FF
.3a1b5f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1b62	e2 20		sep #$20	            SEP #$20
.3a1b64	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b67					EVALSTRING
.3a1b67	08		php		            PHP
.3a1b68	0b		phd		            PHD
.3a1b69	08		php		            PHP
.3a1b6a	c2 20		rep #$20	            REP #$20
.3a1b6c	48		pha		            PHA
.3a1b6d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1b70	5b		tcd		            TCD
.3a1b71	68		pla		            PLA
.3a1b72	28		plp		            PLP
.3a1b73	e2 20		sep #$20	            SEP #$20
.3a1b75	c2 10		rep #$10	            REP #$10
.3a1b77	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1b7a	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.3a1b7d	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.3a1b7f	f0 24		beq $3a1ba5	            BEQ error           ; If it's end-of-line, throw an error
.3a1b81	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.3a1b83	f0 03		beq $3a1b88	            BEQ found_end       ; Yes: Y should be the length
.3a1b85	c8		iny		            INY
.3a1b86	80 f5		bra $3a1b7d	            BRA count_loop
.3a1b88	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.3a1b8a	e2 20		sep #$20	            SEP #$20
.3a1b8c	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.3a1b8e	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.3a1b90	e8		inx		            INX
.3a1b91	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a1b94	a0 00 00	ldy #$0000	            LDY #0
.3a1b97	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.3a1b99	f0 29		beq $3a1bc4	            BEQ done            ; Yes: we're done
.3a1b9b	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.3a1b9d	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.3a1b9f	c8		iny		            INY
.3a1ba0	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1ba3	80 f2		bra $3a1b97	            BRA copy_loop       ; And try the next character
.3a1ba5					error
.3a1ba5	08		php		            PHP
.3a1ba6	c2 20		rep #$20	            REP #$20
.3a1ba8	48		pha		            PHA
.3a1ba9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1bac	5b		tcd		            TCD
.3a1bad	68		pla		            PLA
.3a1bae	28		plp		            PLP
.3a1baf	e2 20		sep #$20	            SEP #$20
.3a1bb1	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1bb3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1bb7	c2 20		rep #$20	            REP #$20
.3a1bb9	29 ff 00	and #$00ff	            AND #$00FF
.3a1bbc	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a1bbf	e2 20		sep #$20	            SEP #$20
.3a1bc1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1bc4	a9 00		lda #$00	done        LDA #0
.3a1bc6	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1bc8	c2 20		rep #$20	            REP #$20
.3a1bca	a5 16		lda $0816	            LDA STRPTR
.3a1bcc	85 23		sta $0823	            STA ARGUMENT1
.3a1bce	a5 18		lda $0818	            LDA STRPTR+2
.3a1bd0	85 25		sta $0825	            STA ARGUMENT1+2
.3a1bd2	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.3a1bd5	85 27		sta $0827	            STA ARGTYPE1
.3a1bd7	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1bda	2b		pld		            PLD
.3a1bdb	28		plp		            PLP
.3a1bdc	60		rts		            RTS
.3a1bdd					EVAL_FUNC
.3a1bdd	08		php		            PHP
.3a1bde	e2 20		sep #$20	            SEP #$20
.3a1be0	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.3a1be2	c2 20		rep #$20	            REP #$20
.3a1be4	29 ff 00	and #$00ff	            AND #$00FF
.3a1be7	20 db 0b	jsr $3a0bdb	            JSR TOKEVAL
.3a1bea	85 2f		sta $082f	            STA JMP16PTR
.3a1bec	20 ce 19	jsr $3a19ce	            JSR OPENPARAMS
.3a1bef	08		php		            PHP
.3a1bf0	e2 20		sep #$20	            SEP #$20
.3a1bf2	48		pha		            PHA
.3a1bf3	a9 00		lda #$00	            LDA #0
.3a1bf5	48		pha		            PHA
.3a1bf6	ab		plb		            PLB
.3a1bf7	68		pla		            PLA
.3a1bf8	28		plp		            PLP
.3a1bf9	20 01 1c	jsr $3a1c01	            JSR OPSTUB
.3a1bfc	20 d8 19	jsr $3a19d8	            JSR CLOSEPARAMS
.3a1bff	28		plp		            PLP
.3a1c00	60		rts		            RTS
.3a1c01					OPSTUB
.3a1c01	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1c04	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1c07					PROCESSOP
.3a1c07	48		pha		            PHA
.3a1c08	08		php		            PHP
.3a1c09	0b		phd		            PHD
.3a1c0a	8b		phb		            PHB
.3a1c0b	08		php		            PHP
.3a1c0c	c2 20		rep #$20	            REP #$20
.3a1c0e	48		pha		            PHA
.3a1c0f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c12	5b		tcd		            TCD
.3a1c13	68		pla		            PLA
.3a1c14	28		plp		            PLP
.3a1c15	c2 30		rep #$30	            REP #$30
.3a1c17	20 a0 19	jsr $3a19a0	            JSR PLOPERATOR
.3a1c1a	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.3a1c1d	f0 37		beq $3a1c56	            BEQ bad_token       ; No: it's a bad token
.3a1c1f	48		pha		            PHA
.3a1c20	20 db 0b	jsr $3a0bdb	            JSR TOKEVAL
.3a1c23	85 2f		sta $082f	            STA JMP16PTR
.3a1c25	68		pla		            PLA
.3a1c26	20 28 0c	jsr $3a0c28	            JSR TOKARITY
.3a1c29	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.3a1c2c	f0 08		beq $3a1c36	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.3a1c2e	c2 30		rep #$30	            REP #$30
.3a1c30	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.3a1c33	20 38 19	jsr $3a1938	            JSR PLARGUMENT
.3a1c36					pull_arg1
.3a1c36	c2 30		rep #$30	            REP #$30
.3a1c38	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.3a1c3b	20 38 19	jsr $3a1938	            JSR PLARGUMENT
.3a1c3e	08		php		            PHP
.3a1c3f	e2 20		sep #$20	            SEP #$20
.3a1c41	48		pha		            PHA
.3a1c42	a9 00		lda #$00	            LDA #0
.3a1c44	48		pha		            PHA
.3a1c45	ab		plb		            PLB
.3a1c46	68		pla		            PLA
.3a1c47	28		plp		            PLP
.3a1c48	20 58 1c	jsr $3a1c58	            JSR OPSTUB
.3a1c4b	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.3a1c4e	20 fa 18	jsr $3a18fa	            JSR PHARGUMENT
.3a1c51	ab		plb		            PLB
.3a1c52	2b		pld		            PLD
.3a1c53	28		plp		            PLP
.3a1c54	68		pla		            PLA
.3a1c55	60		rts		            RTS
.3a1c56	00		brk #		bad_token   BRK
.3a1c57	ea		nop		            NOP
.3a1c58	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1c5b					EVALEXPR
.3a1c5b	08		php		            PHP
.3a1c5c	08		php		            PHP
.3a1c5d	c2 20		rep #$20	            REP #$20
.3a1c5f	48		pha		            PHA
.3a1c60	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c63	5b		tcd		            TCD
.3a1c64	68		pla		            PLA
.3a1c65	28		plp		            PLP
.3a1c66	08		php		            PHP
.3a1c67	e2 20		sep #$20	            SEP #$20
.3a1c69	48		pha		            PHA
.3a1c6a	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1c6c	48		pha		            PHA
.3a1c6d	ab		plb		            PLB
.3a1c6e	68		pla		            PLA
.3a1c6f	28		plp		            PLP
.3a1c70	c2 10		rep #$10	            REP #$10
.3a1c72	da		phx		            PHX
.3a1c73					get_char
.3a1c73	e2 20		sep #$20	            SEP #$20
.3a1c75	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.3a1c77	d0 03		bne $3a1c7c	            BNE else1
.3a1c79	4c 1e 1d	jmp $3a1d1e	            JMP proc_stack      ; Handle end of line, if we see it
.3a1c7c	30 33		bmi $3a1cb1	else1       BMI is_token        ; If MSB is set, it's a token
.3a1c7e	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.3a1c80	d0 03		bne $3a1c85	            BNE else2
.3a1c82	4c 18 1d	jmp $3a1d18	            JMP next_char       ; Yes: Skip to the next character
.3a1c85	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.3a1c87	b0 04		bcs $3a1c8d	            BCS else3           ; No: treat as the end of the line
.3a1c89	c9 30		cmp #$30	            CMP #'0'
.3a1c8b	b0 56		bcs $3a1ce3	            BCS is_digit
.3a1c8d	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.3a1c8f	f0 52		beq $3a1ce3	            BEQ is_digit
.3a1c91	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.3a1c93	d0 03		bne $3a1c98	            BNE else4
.3a1c95	4c 31 1d	jmp $3a1d31	            JMP is_string       ; Yes: process the string
.3a1c98	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.3a1c9a	b0 07		bcs $3a1ca3	            BCS check_lc        ; No: check for lower case
.3a1c9c	c9 41		cmp #$41	            CMP #'A'
.3a1c9e	90 03		bcc $3a1ca3	            BCC check_lc
.3a1ca0	4c 3d 1d	jmp $3a1d3d	            JMP is_alpha
.3a1ca3	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.3a1ca5	b0 07		bcs $3a1cae	            BCS else5           ; No: treat as the end of the line
.3a1ca7	c9 61		cmp #$61	            CMP #'a'
.3a1ca9	90 03		bcc $3a1cae	            BCC else5
.3a1cab	4c 3d 1d	jmp $3a1d3d	            JMP is_alpha
.3a1cae	4c 1e 1d	jmp $3a1d1e	else5       JMP proc_stack
.3a1cb1	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.3a1cb3	f0 40		beq $3a1cf5	            BEQ is_lparen       ; Yes: handle the LPAREN
.3a1cb5	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.3a1cb7	f0 41		beq $3a1cfa	            BEQ is_rparen       ; Yes: handle the RPAREN
.3a1cb9	20 fe 0b	jsr $3a0bfe	            JSR TOKTYPE
.3a1cbc	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.3a1cbe	d0 0c		bne $3a1ccc	            BNE chk_op          ; No: check if it's an operator
.3a1cc0	20 dd 1b	jsr $3a1bdd	            JSR EVAL_FUNC
.3a1cc3	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1cc6	20 fa 18	jsr $3a18fa	            JSR PHARGUMENT
.3a1cc9	4c 73 1c	jmp $3a1c73	            JMP get_char
.3a1ccc	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.3a1cce	d0 4e		bne $3a1d1e	            BNE proc_stack      ; No: we're finished processing
.3a1cd0	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.3a1cd2	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.3a1cd4	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1cd7	f0 05		beq $3a1cde	            BEQ push_op         ; Yes: push the operator
.3a1cd9	20 17 1a	jsr $3a1a17	            JSR OPHIGHPREC
.3a1cdc	b0 12		bcs $3a1cf0	            BCS process1        ; No: we should process the top operator
.3a1cde					push_op
.3a1cde	20 77 19	jsr $3a1977	            JSR PHOPERATOR
.3a1ce1	80 35		bra $3a1d18	            BRA next_char       ; And go to the next character
.3a1ce3					is_digit
.3a1ce3	c2 20		rep #$20	            REP #$20
.3a1ce5	20 e9 58	jsr $3a58e9	            JSR PARSENUM
.3a1ce8	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.3a1ceb	20 fa 18	jsr $3a18fa	            JSR PHARGUMENT
.3a1cee	80 83		bra $3a1c73	            BRA get_char
.3a1cf0					process1
.3a1cf0	20 07 1c	jsr $3a1c07	            JSR PROCESSOP
.3a1cf3	80 dd		bra $3a1cd2	            BRA chk_prec        ; And check what to do with the current operator
.3a1cf5					is_lparen
.3a1cf5	20 77 19	jsr $3a1977	            JSR PHOPERATOR
.3a1cf8	80 1e		bra $3a1d18	            BRA next_char
.3a1cfa					is_rparen
.3a1cfa	e2 20		sep #$20	            SEP #$20
.3a1cfc	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.3a1cfe	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.3a1d01	f0 46		beq $3a1d49	            BEQ done            ; Yes: we're done evaluating things
.3a1d03	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.3a1d05	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1d08	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.3a1d0a	f0 3d		beq $3a1d49	            BEQ done            ; Yes: treat it as an empty stack
.3a1d0c	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.3a1d0e	f0 05		beq $3a1d15	            BEQ done_rparen     ; Yes: we're finished processing
.3a1d10	20 07 1c	jsr $3a1c07	            JSR PROCESSOP
.3a1d13	80 ee		bra $3a1d03	            BRA paren_loop
.3a1d15					done_rparen
.3a1d15	20 a0 19	jsr $3a19a0	            JSR PLOPERATOR
.3a1d18					next_char
.3a1d18	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a1d1b	4c 73 1c	jmp $3a1c73	            JMP get_char
.3a1d1e					proc_stack
.3a1d1e	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.3a1d20	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1d23	b0 24		bcs $3a1d49	            BGE done            ; Yes: return to the caller
.3a1d25	bd 01 00	lda $0001,x	            LDA #1,B,X
.3a1d28	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.3a1d2a	f0 1d		beq $3a1d49	            BEQ done            ; Yes: treat as end of expression
.3a1d2c	20 07 1c	jsr $3a1c07	            JSR PROCESSOP
.3a1d2f	80 ed		bra $3a1d1e	            BRA proc_stack
.3a1d31					is_string
.3a1d31	20 67 1b	jsr $3a1b67	            JSR EVALSTRING
.3a1d34	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1d37	20 fa 18	jsr $3a18fa	            JSR PHARGUMENT
.3a1d3a	4c 73 1c	jmp $3a1c73	            JMP get_char
.3a1d3d					is_alpha
.3a1d3d	20 dc 1a	jsr $3a1adc	            JSR EVALREF
.3a1d40	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1d43	20 fa 18	jsr $3a18fa	            JSR PHARGUMENT
.3a1d46	4c 73 1c	jmp $3a1c73	            JMP get_char
.3a1d49	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.3a1d4c	20 38 19	jsr $3a1938	            JSR PLARGUMENT
.3a1d4f					real_done
.3a1d4f	fa		plx		            PLX
.3a1d50	28		plp		            PLP
.3a1d51	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.3a1d52					INITRETURN
.3a1d52	08		php		                PHP
.3a1d53	0b		phd		                PHD
.3a1d54	8b		phb		                PHB
.3a1d55	08		php		            PHP
.3a1d56	e2 20		sep #$20	            SEP #$20
.3a1d58	48		pha		            PHA
.3a1d59	a9 00		lda #$00	            LDA #0
.3a1d5b	48		pha		            PHA
.3a1d5c	ab		plb		            PLB
.3a1d5d	68		pla		            PLA
.3a1d5e	28		plp		            PLP
.3a1d5f	08		php		            PHP
.3a1d60	c2 20		rep #$20	            REP #$20
.3a1d62	48		pha		            PHA
.3a1d63	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1d66	5b		tcd		            TCD
.3a1d67	68		pla		            PLA
.3a1d68	28		plp		            PLP
.3a1d69	c2 30		rep #$30	            REP #$30
.3a1d6b	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.3a1d6e	85 33		sta $0833	                STA RETURNSP
.3a1d70	ab		plb		                PLB
.3a1d71	2b		pld		                PLD
.3a1d72	28		plp		                PLP
.3a1d73	60		rts		            RTS
.3a1d74					PHRETURN
.3a1d74	08		php		                PHP
.3a1d75	0b		phd		                PHD
.3a1d76	08		php		            PHP
.3a1d77	c2 20		rep #$20	            REP #$20
.3a1d79	48		pha		            PHA
.3a1d7a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1d7d	5b		tcd		            TCD
.3a1d7e	68		pla		            PLA
.3a1d7f	28		plp		            PLP
.3a1d80	c2 30		rep #$30	            REP #$30
.3a1d82	92 33		sta ($0833)	                STA (RETURNSP)
.3a1d84	c6 33		dec $0833	                DEC RETURNSP
.3a1d86	c6 33		dec $0833	                DEC RETURNSP
.3a1d88	2b		pld		                PLD
.3a1d89	28		plp		                PLP
.3a1d8a	60		rts		            RTS
.3a1d8b					PHRETURNB
.3a1d8b	08		php		                PHP
.3a1d8c	c2 30		rep #$30	            REP #$30
.3a1d8e	29 ff 00	and #$00ff	                AND #$00FF
.3a1d91	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a1d94	28		plp		                PLP
.3a1d95	60		rts		            RTS
.3a1d96					PLRETURN
.3a1d96	08		php		                PHP
.3a1d97	0b		phd		                PHD
.3a1d98	08		php		            PHP
.3a1d99	c2 20		rep #$20	            REP #$20
.3a1d9b	48		pha		            PHA
.3a1d9c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1d9f	5b		tcd		            TCD
.3a1da0	68		pla		            PLA
.3a1da1	28		plp		            PLP
.3a1da2	c2 30		rep #$30	            REP #$30
.3a1da4	e6 33		inc $0833	                INC RETURNSP
.3a1da6	e6 33		inc $0833	                INC RETURNSP
.3a1da8	b2 33		lda ($0833)	                LDA (RETURNSP)
.3a1daa	2b		pld		                PLD
.3a1dab	28		plp		                PLP
.3a1dac	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.3a1dad					SET_ERRERL
.3a1dad	8b		phb		                PHB
.3a1dae	0b		phd		                PHD
.3a1daf	08		php		                PHP
.3a1db0	08		php		            PHP
.3a1db1	c2 20		rep #$20	            REP #$20
.3a1db3	48		pha		            PHA
.3a1db4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1db7	5b		tcd		            TCD
.3a1db8	68		pla		            PLA
.3a1db9	28		plp		            PLP
.3a1dba	08		php		            PHP
.3a1dbb	e2 20		sep #$20	            SEP #$20
.3a1dbd	48		pha		            PHA
.3a1dbe	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1dc0	48		pha		            PHA
.3a1dc1	ab		plb		            PLB
.3a1dc2	68		pla		            PLA
.3a1dc3	28		plp		            PLP
.3a1dc4	c2 20		rep #$20	            REP #$20
.3a1dc6	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1dc8	a9 00 00	lda #$0000	                LDA #0
.3a1dcb	85 25		sta $0825	                STA ARGUMENT1+2
.3a1dcd	e2 20		sep #$20	            SEP #$20
.3a1dcf	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1dd1	85 27		sta $0827	                STA ARGTYPE1
.3a1dd3	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1dd5	a9 3a		lda #$3a	                LDA #`err_name
.3a1dd7	85 e9		sta $08e9	                STA TOFIND+2
.3a1dd9	c2 20		rep #$20	            REP #$20
.3a1ddb	a9 07 1e	lda #$1e07	                LDA #<>err_name
.3a1dde	85 e7		sta $08e7	                STA TOFIND
.3a1de0	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a1de3	c2 20		rep #$20	            REP #$20
.3a1de5	a5 d7		lda $08d7	                LDA LINENUM
.3a1de7	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1de9	a5 d9		lda $08d9	                LDA LINENUM+2
.3a1deb	85 25		sta $0825	                STA ARGUMENT1+2
.3a1ded	e2 20		sep #$20	            SEP #$20
.3a1def	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1df1	85 27		sta $0827	                STA ARGTYPE1
.3a1df3	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1df5	a9 3a		lda #$3a	                LDA #`erl_name
.3a1df7	85 e9		sta $08e9	                STA TOFIND+2
.3a1df9	c2 20		rep #$20	            REP #$20
.3a1dfb	a9 0b 1e	lda #$1e0b	                LDA #<>erl_name
.3a1dfe	85 e7		sta $08e7	                STA TOFIND
.3a1e00	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a1e03	28		plp		                PLP
.3a1e04	2b		pld		                PLD
.3a1e05	ab		plb		                PLB
.3a1e06	60		rts		            RTS
>3a1e07	45 52 52 00			err_name        .null "ERR"
>3a1e0b	45 52 4c 00			erl_name        .null "ERL"
.3a1e0f					ON_ERROR
.3a1e0f	e2 20		sep #$20	            SEP #$20
.3a1e11	c2 10		rep #$10	            REP #$10
.3a1e13	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a1e16	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.3a1e1a	0a		asl a		            ASL A
.3a1e1b	c2 20		rep #$20	            REP #$20
.3a1e1d	29 ff 00	and #$00ff	            AND #$00FF
.3a1e20	a8		tay		            TAY
.3a1e21	08		php		            PHP
.3a1e22	e2 20		sep #$20	            SEP #$20
.3a1e24	48		pha		            PHA
.3a1e25	a9 3a		lda #$3a	            LDA #`ERRORMSG
.3a1e27	48		pha		            PHA
.3a1e28	ab		plb		            PLB
.3a1e29	68		pla		            PLA
.3a1e2a	28		plp		            PLP
.3a1e2b	be 61 1e	ldx $3a1e61,y	            LDX ERRORMSG,Y
.3a1e2e	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a1e31	c2 20		rep #$20	            REP #$20
.3a1e33	a5 d7		lda $08d7	            LDA LINENUM
.3a1e35	f0 27		beq $3a1e5e	            BEQ skip_at
.3a1e37	a2 91 1e	ldx #$1e91	            LDX #<>MSG_AT           ; If so... print " AT "
.3a1e3a	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a1e3d	08		php		            PHP
.3a1e3e	e2 20		sep #$20	            SEP #$20
.3a1e40	48		pha		            PHA
.3a1e41	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1e43	48		pha		            PHA
.3a1e44	ab		plb		            PLB
.3a1e45	68		pla		            PLA
.3a1e46	28		plp		            PLP
.3a1e47	c2 20		rep #$20	            REP #$20
.3a1e49	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.3a1e4d	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.3a1e51	a9 00 00	lda #$0000	            LDA #0
.3a1e54	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.3a1e58	20 20 45	jsr $3a4520	            JSR PR_INTEGER
.3a1e5b	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a1e5e					skip_at
.3a1e5e	4c 0f 27	jmp $3a270f	            JMP INTERACT
>3a1e61	95 1e				ERRORMSG    .word <>MSG_OK
>3a1e63	98 1e				            .word <>MSG_BREAK
>3a1e65	9e 1e				            .word <>MSG_SYNTAX
>3a1e67	ab 1e				            .word <>MSG_MEMORY
>3a1e69	b9 1e				            .word <>MSG_TYPE
>3a1e6b	c7 1e				            .word <>MSG_NOTFND
>3a1e6d	da 1e				            .word <>MSG_NOLINE
>3a1e6f	f0 1e				            .word <>MSG_UNDFLOW
>3a1e71	00 1f				            .word <>MSG_OVRFLOW
>3a1e73	0f 1f				            .word <>MSG_RANGE
>3a1e75	1c 1f				            .word <>MSG_ARG
>3a1e77	2d 1f				            .word <>MSG_NOFILE
>3a1e79	3c 1f				            .word <>MSG_NAN
>3a1e7b	49 1f				            .word <>MSG_OVERFLOW
>3a1e7d	57 1f				            .word <>MSG_UNDERFLOW
>3a1e7f	66 1f				            .word <>MSG_DIV0
>3a1e81	77 1f				            .word <>MSG_DIRECTORY
>3a1e83	90 1f				            .word <>MSG_LOAD
>3a1e85	a4 1f				            .word <>MSG_SAVE
>3a1e87	b8 1f				            .word <>MSG_DELETE
>3a1e89	ce 1f				            .word <>MSG_FILENOTFND
>3a1e8b	e2 1f				            .word <>MSG_DIRNOTWRITE
>3a1e8d	fd 1f				            .word <>MSG_NOTCOPIED
>3a1e8f	15 20				            .word <>MSG_DOMAIN
>3a1e91	20 61 74 00			MSG_AT          .null " at"
>3a1e95	4f 4b 00			MSG_OK          .null "OK"
>3a1e98	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>3a1e9e	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>3a1ea6	72 72 6f 72 00
>3a1eab	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>3a1eb3	65 6d 6f 72 79 00
>3a1eb9	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>3a1ec1	6d 61 74 63 68 00
>3a1ec7	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>3a1ecf	20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1eda	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>3a1ee2	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1ef0	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>3a1ef8	64 65 72 66 6c 6f 77 00
>3a1f00	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>3a1f08	65 72 66 6c 6f 77 00
>3a1f0f	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>3a1f17	61 6e 67 65 00
>3a1f1c	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>3a1f24	61 72 67 75 6d 65 6e 74 00
>3a1f2d	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>3a1f35	20 66 6f 75 6e 64 00
>3a1f3c	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>3a1f44	6d 62 65 72 00
>3a1f49	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>3a1f51	72 66 6c 6f 77 00
>3a1f57	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>3a1f5f	65 72 66 6c 6f 77 00
>3a1f66	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>3a1f6e	20 62 79 20 7a 65 72 6f 00
>3a1f77	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>3a1f7f	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>3a1f8f	00
>3a1f90	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>3a1f98	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>3a1fa4	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>3a1fac	6f 20 73 61 76 65 20 66 69 6c 65 00
>3a1fb8	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>3a1fc0	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>3a1fce	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>3a1fd6	74 20 66 69 6e 64 20 66 69 6c 65 00
>3a1fe2	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>3a1fea	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>3a1ffa	72 79 00
>3a1ffd	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>3a2005	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>3a2015	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>3a201d	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.3a202d					SETINTERACT
.3a202d	08		php		            PHP
.3a202e	0b		phd		            PHD
.3a202f	08		php		            PHP
.3a2030	c2 20		rep #$20	            REP #$20
.3a2032	48		pha		            PHA
.3a2033	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2036	5b		tcd		            TCD
.3a2037	68		pla		            PLA
.3a2038	28		plp		            PLP
.3a2039	e2 20		sep #$20	            SEP #$20
.3a203b	a9 00		lda #$00	            LDA #ST_INTERACT
.3a203d	85 d2		sta $08d2	            STA STATE
.3a203f	2b		pld		            PLD
.3a2040	28		plp		            PLP
.3a2041	60		rts		            RTS
.3a2042					CLRINTERP
.3a2042	0b		phd		            PHD
.3a2043	08		php		            PHP
.3a2044	08		php		            PHP
.3a2045	c2 20		rep #$20	            REP #$20
.3a2047	48		pha		            PHA
.3a2048	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a204b	5b		tcd		            TCD
.3a204c	68		pla		            PLA
.3a204d	28		plp		            PLP
.3a204e	08		php		            PHP
.3a204f	c2 20		rep #$20	            REP #$20
.3a2051	a9 0f 1e	lda #$1e0f	            LDA #<>ON_ERROR
.3a2054	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.3a2058	e2 20		sep #$20	            SEP #$20
.3a205a	a9 3a		lda #$3a	            LDA #`ON_ERROR
.3a205c	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.3a2060	28		plp		            PLP
.3a2061	20 c7 43	jsr $3a43c7	            JSR S_CLR
.3a2064	20 08 3f	jsr $3a3f08	            JSR S_RESTORE
.3a2067	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.3a2069	28		plp		            PLP
.3a206a	2b		pld		            PLD
.3a206b	60		rts		            RTS
.3a206c					INCBIP
.3a206c	08		php		            PHP
.3a206d	0b		phd		            PHD
.3a206e	08		php		            PHP
.3a206f	c2 20		rep #$20	            REP #$20
.3a2071	48		pha		            PHA
.3a2072	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2075	5b		tcd		            TCD
.3a2076	68		pla		            PLA
.3a2077	28		plp		            PLP
.3a2078	c2 20		rep #$20	            REP #$20
.3a207a	18		clc		            CLC
.3a207b	a5 00		lda $0800	            LDA BIP
.3a207d	69 01 00	adc #$0001	            ADC #1
.3a2080	85 00		sta $0800	            STA BIP
.3a2082	e2 20		sep #$20	            SEP #$20
.3a2084	a5 02		lda $0802	            LDA BIP+2
.3a2086	69 00		adc #$00	            ADC #0
.3a2088	85 02		sta $0802	            STA BIP+2
.3a208a	2b		pld		            PLD
.3a208b	28		plp		            PLP
.3a208c	60		rts		            RTS
.3a208d					SKIPWS
.3a208d	08		php		            PHP
.3a208e	0b		phd		            PHD
.3a208f	08		php		            PHP
.3a2090	c2 20		rep #$20	            REP #$20
.3a2092	48		pha		            PHA
.3a2093	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2096	5b		tcd		            TCD
.3a2097	68		pla		            PLA
.3a2098	28		plp		            PLP
.3a2099	e2 20		sep #$20	            SEP #$20
.3a209b	a7 00		lda [$0800]	loop        LDA [BIP]
.3a209d	f0 0f		beq $3a20ae	            BEQ done            ; If character is 0, we've reached the end of the line
.3a209f	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.3a20a1	f0 06		beq $3a20a9	            BEQ skip_char
.3a20a3	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.3a20a5	f0 02		beq $3a20a9	            BEQ skip_char
.3a20a7	80 05		bra $3a20ae	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.3a20a9					skip_char
.3a20a9	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a20ac	80 ed		bra $3a209b	            BRA loop
.3a20ae	2b		pld		done        PLD
.3a20af	28		plp		            PLP
.3a20b0	60		rts		            RTS
.3a20b1					SKIPSTMT
.3a20b1	08		php		            PHP
.3a20b2	e2 20		sep #$20	            SEP #$20
.3a20b4	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.3a20b6	f0 09		beq $3a20c1	            BEQ done            ; Is it EOL? Yes, we're done
.3a20b8	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.3a20ba	f0 05		beq $3a20c1	            BEQ done            ; Yes, we're done
.3a20bc	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a20bf	80 f3		bra $3a20b4	            BRA loop            ; and check it...
.3a20c1	28		plp		done        PLP
.3a20c2	60		rts		            RTS
.3a20c3					SKIPTOTOK
.3a20c3	08		php		            PHP
.3a20c4	e2 20		sep #$20	            SEP #$20
.3a20c6	64 36		stz $0836	            STZ NESTING
.3a20c8	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.3a20ca	f0 19		beq $3a20e5	            BEQ end_of_line     ; EOL? Yes: move to the next line
.3a20cc	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.3a20ce	f0 2c		beq $3a20fc	            BEQ check_depth     ; Yes: check the depth
.3a20d0	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.3a20d2	f0 1e		beq $3a20f2	            BEQ inc_nesting     ; Yes: increment NESTING
.3a20d4	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.3a20d6	f0 1a		beq $3a20f2	            BEQ inc_nesting     ; Yes: increment NESTING
.3a20d8	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.3a20da	f0 1a		beq $3a20f6	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a20dc	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.3a20de	f0 16		beq $3a20f6	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a20e0					incloop
.3a20e0	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a20e3	80 e3		bra $3a20c8	            BRA loop            ; and keep scanning
.3a20e5					end_of_line
.3a20e5	20 49 21	jsr $3a2149	            JSR NEXTLINE
.3a20e8	c2 20		rep #$20	            REP #$20
.3a20ea	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.3a20ec	f0 1d		beq $3a210b	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.3a20ee	e2 20		sep #$20	            SEP #$20
.3a20f0	80 d6		bra $3a20c8	            BRA loop            ; And keep scanning
.3a20f2					inc_nesting
.3a20f2	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.3a20f4	80 ea		bra $3a20e0	            BRA incloop
.3a20f6					dec_nesting
.3a20f6	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.3a20f8	30 30		bmi $3a212a	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.3a20fa	80 e4		bra $3a20e0	            BRA incloop
.3a20fc					check_depth
.3a20fc	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.3a20fe	30 06		bmi $3a2106	            BMI found           ; No: just return that we found the token
.3a2100	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.3a2102	f0 02		beq $3a2106	            BEQ found           ; If it's zero, we found our token
.3a2104	80 da		bra $3a20e0	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.3a2106					found
.3a2106	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a2109	28		plp		            PLP
.3a210a	60		rts		            RTS
.3a210b					syntax_err1
.3a210b	08		php		            PHP
.3a210c	c2 20		rep #$20	            REP #$20
.3a210e	48		pha		            PHA
.3a210f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2112	5b		tcd		            TCD
.3a2113	68		pla		            PLA
.3a2114	28		plp		            PLP
.3a2115	e2 20		sep #$20	            SEP #$20
.3a2117	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a2119	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a211d	c2 20		rep #$20	            REP #$20
.3a211f	29 ff 00	and #$00ff	            AND #$00FF
.3a2122	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2125	e2 20		sep #$20	            SEP #$20
.3a2127	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a212a					syntax_err2
.3a212a	08		php		            PHP
.3a212b	c2 20		rep #$20	            REP #$20
.3a212d	48		pha		            PHA
.3a212e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2131	5b		tcd		            TCD
.3a2132	68		pla		            PLA
.3a2133	28		plp		            PLP
.3a2134	e2 20		sep #$20	            SEP #$20
.3a2136	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a2138	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a213c	c2 20		rep #$20	            REP #$20
.3a213e	29 ff 00	and #$00ff	            AND #$00FF
.3a2141	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2144	e2 20		sep #$20	            SEP #$20
.3a2146	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2149					NEXTLINE
.3a2149	08		php		            PHP
.3a214a	c2 30		rep #$30	            REP #$30
.3a214c	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a214f	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.3a2151	85 0c		sta $080c	            STA SCRATCH
.3a2153	18		clc		            CLC                 ; Compute the new CURLINE
.3a2154	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.3a2156	65 0c		adc $080c	            ADC SCRATCH
.3a2158	85 1a		sta $081a	            STA CURLINE
.3a215a	a5 1c		lda $081c	            LDA CURLINE+2
.3a215c	69 00 00	adc #$0000	            ADC #0
.3a215f	85 1c		sta $081c	            STA CURLINE+2
.3a2161	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.3a2164	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.3a2166	85 d7		sta $08d7	            STA LINENUM
.3a2168	18		clc		            CLC                 ; Point BIP to the first character of the line
.3a2169	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.3a216b	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a216e	85 00		sta $0800	            STA BIP
.3a2170	a5 1c		lda $081c	            LDA CURLINE+2
.3a2172	69 00 00	adc #$0000	            ADC #0
.3a2175	85 02		sta $0802	            STA BIP+2
.3a2177	28		plp		            PLP
.3a2178	60		rts		            RTS
.3a2179					EXPECT_TOK
.3a2179	08		php		            PHP
.3a217a	e2 20		sep #$20	            SEP #$20
.3a217c	48		pha		            PHA
.3a217d	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a2180	68		pla		            PLA
.3a2181	e2 20		sep #$20	            SEP #$20
.3a2183	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.3a2185	d0 08		bne $3a218f	            BNE syntax_err      ; Throw a syntax error
.3a2187	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a218a	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a218d	28		plp		            PLP
.3a218e	60		rts		            RTS
.3a218f					syntax_err
.3a218f	08		php		            PHP
.3a2190	c2 20		rep #$20	            REP #$20
.3a2192	48		pha		            PHA
.3a2193	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2196	5b		tcd		            TCD
.3a2197	68		pla		            PLA
.3a2198	28		plp		            PLP
.3a2199	e2 20		sep #$20	            SEP #$20
.3a219b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a219d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a21a1	c2 20		rep #$20	            REP #$20
.3a21a3	29 ff 00	and #$00ff	            AND #$00FF
.3a21a6	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a21a9	e2 20		sep #$20	            SEP #$20
.3a21ab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a21ae					OPT_TOK
.3a21ae	08		php		            PHP
.3a21af	e2 20		sep #$20	            SEP #$20
.3a21b1	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a21b4	e2 20		sep #$20	            SEP #$20
.3a21b6	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.3a21b8	f0 10		beq $3a21ca	            BEQ ret_false       ; If end-of-line, return false
.3a21ba	c9 3a		cmp #$3a	            CMP #':'
.3a21bc	f0 0c		beq $3a21ca	            BEQ ret_false       ; If colon, return false
.3a21be	c5 37		cmp $0837	            CMP TARGETTOK
.3a21c0	f0 05		beq $3a21c7	            BEQ ret_true        ; If matches, return true
.3a21c2	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a21c5	80 ef		bra $3a21b6	            BRA loop
.3a21c7	28		plp		ret_true    PLP
.3a21c8	38		sec		            SEC
.3a21c9	60		rts		            RTS
.3a21ca	28		plp		ret_false   PLP
.3a21cb	18		clc		            CLC
.3a21cc	60		rts		            RTS
.3a21cd					PEEK_TOK
.3a21cd	5a		phy		            PHY
.3a21ce	08		php		            PHP
.3a21cf	e2 20		sep #$20	            SEP #$20
.3a21d1	a0 00 00	ldy #$0000	            LDY #0
.3a21d4	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.3a21d6	f0 0d		beq $3a21e5	            BEQ done
.3a21d8	c9 3a		cmp #$3a	            CMP #':'
.3a21da	f0 07		beq $3a21e3	            BEQ ret_null
.3a21dc	c9 20		cmp #$20	            CMP #CHAR_SP
.3a21de	d0 05		bne $3a21e5	            BNE done
.3a21e0	c8		iny		            INY
.3a21e1	80 f1		bra $3a21d4	            BRA loop
.3a21e3	a9 00		lda #$00	ret_null    LDA #0
.3a21e5	28		plp		done        PLP
.3a21e6	7a		ply		            PLY
.3a21e7	60		rts		            RTS
.3a21e8					EXECSTMT
.3a21e8	08		php		            PHP
.3a21e9	0b		phd		            PHD
.3a21ea	8b		phb		            PHB
.3a21eb	08		php		            PHP
.3a21ec	c2 20		rep #$20	            REP #$20
.3a21ee	48		pha		            PHA
.3a21ef	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a21f2	5b		tcd		            TCD
.3a21f3	68		pla		            PLA
.3a21f4	28		plp		            PLP
.3a21f5	20 da 18	jsr $3a18da	            JSR INITEVALSP
.3a21f8	e2 20		sep #$20	            SEP #$20
.3a21fa	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.3a21fc	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.3a21fe	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.3a2202	b0 4b		bcs $3a224f	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.3a2204	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.3a2206	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.3a2208	d0 03		bne $3a220d	            BNE eat_ws
.3a220a	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a220d					eat_ws
.3a220d	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a2210	a7 00		lda [$0800]	            LDA [BIP]
.3a2212	d0 03		bne $3a2217	            BNE else
.3a2214	4c 99 22	jmp $3a2299	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.3a2217					else
.3a2217	20 36 04	jsr $3a0436	            JSR ISALPHA
.3a221a	b0 52		bcs $3a226e	            BCS is_variable     ; Yes: we may have a LET statement
.3a221c	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.3a221e	10 10		bpl $3a2230	            BPL error           ; Yes: it's a syntax error
.3a2220	20 fe 0b	jsr $3a0bfe	            JSR TOKTYPE
.3a2223	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.3a2225	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.3a2227	d0 03		bne $3a222c	            BNE else2
.3a2229	4c 87 22	jmp $3a2287	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.3a222c	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.3a222e	f0 51		beq $3a2281	            BEQ is_interact
.3a2230					error
.3a2230	08		php		            PHP
.3a2231	c2 20		rep #$20	            REP #$20
.3a2233	48		pha		            PHA
.3a2234	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2237	5b		tcd		            TCD
.3a2238	68		pla		            PLA
.3a2239	28		plp		            PLP
.3a223a	e2 20		sep #$20	            SEP #$20
.3a223c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a223e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2242	c2 20		rep #$20	            REP #$20
.3a2244	29 ff 00	and #$00ff	            AND #$00FF
.3a2247	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a224a	e2 20		sep #$20	            SEP #$20
.3a224c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a224f					throw_break
.3a224f	08		php		            PHP
.3a2250	c2 20		rep #$20	            REP #$20
.3a2252	48		pha		            PHA
.3a2253	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2256	5b		tcd		            TCD
.3a2257	68		pla		            PLA
.3a2258	28		plp		            PLP
.3a2259	e2 20		sep #$20	            SEP #$20
.3a225b	a9 01		lda #$01	            LDA #ERR_BREAK
.3a225d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2261	c2 20		rep #$20	            REP #$20
.3a2263	29 ff 00	and #$00ff	            AND #$00FF
.3a2266	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2269	e2 20		sep #$20	            SEP #$20
.3a226b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a226e					is_variable
.3a226e	20 d1 43	jsr $3a43d1	            JSR S_LET
.3a2271	4c 99 22	jmp $3a2299	            JMP done
.3a2274					STSTUB
.3a2274	08		php		            PHP
.3a2275	e2 20		sep #$20	            SEP #$20
.3a2277	48		pha		            PHA
.3a2278	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a227a	48		pha		            PHA
.3a227b	ab		plb		            PLB
.3a227c	68		pla		            PLA
.3a227d	28		plp		            PLP
.3a227e	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a2281	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.3a2283	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.3a2285	d0 a9		bne $3a2230	            BNE error           ; If not, it's an error
.3a2287					ok_to_exec
.3a2287	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.3a2289	20 db 0b	jsr $3a0bdb	            JSR TOKEVAL
.3a228c	c2 20		rep #$20	            REP #$20
.3a228e	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.3a2290	20 da 18	jsr $3a18da	            JSR INITEVALSP
.3a2293	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a2296	20 74 22	jsr $3a2274	            JSR STSTUB
.3a2299	ab		plb		done        PLB
.3a229a	2b		pld		            PLD
.3a229b	28		plp		            PLP
.3a229c	60		rts		            RTS
.3a229d					EXECCMD
.3a229d	08		php		            PHP
.3a229e	58		cli		            CLI
.3a229f	20 2d 20	jsr $3a202d	            JSR SETINTERACT
.3a22a2	20 52 1d	jsr $3a1d52	            JSR INITRETURN
.3a22a5	e2 20		sep #$20	            SEP #$20
.3a22a7	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a22aa	c2 20		rep #$20	            REP #$20
.3a22ac	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a22ae	85 00		sta $0800	            STA BIP
.3a22b0	a5 1c		lda $081c	            LDA CURLINE+2
.3a22b2	85 02		sta $0802	            STA BIP+2
.3a22b4	4c de 22	jmp $3a22de	            JMP exec_loop
.3a22b7	08		php		EXECLINE    PHP
.3a22b8	c2 20		rep #$20	            REP #$20
.3a22ba	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.3a22bd	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a22bf	85 d7		sta $08d7	            STA LINENUM
.3a22c1	20 47 14	jsr $3a1447	            JSR CLRTMPSTR
.3a22c4	e2 20		sep #$20	            SEP #$20
.3a22c6	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.3a22c8	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.3a22ca	f0 12		beq $3a22de	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.3a22cc	c2 20		rep #$20	            REP #$20
.3a22ce	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a22cf	a5 1a		lda $081a	            LDA CURLINE
.3a22d1	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a22d4	85 00		sta $0800	            STA BIP
.3a22d6	e2 20		sep #$20	            SEP #$20
.3a22d8	a5 1c		lda $081c	            LDA CURLINE+2
.3a22da	69 00		adc #$00	            ADC #0
.3a22dc	85 02		sta $0802	            STA BIP+2
.3a22de					exec_loop
.3a22de	c2 20		rep #$20	            REP #$20
.3a22e0	20 e8 21	jsr $3a21e8	            JSR EXECSTMT
.3a22e3	e2 20		sep #$20	            SEP #$20
.3a22e5	a5 dc		lda $08dc	            LDA EXECACTION
.3a22e7	c9 03		cmp #$03	            CMP #EXEC_RETURN
.3a22e9	f0 f3		beq $3a22de	            BEQ exec_loop
.3a22eb	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.3a22ed	d0 31		bne $3a2320	            BNE exec_done
.3a22ef	e2 20		sep #$20	            SEP #$20
.3a22f1	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a22f4	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.3a22f6	f0 28		beq $3a2320	            BEQ exec_done               ; If it's NULL, we're done
.3a22f8	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.3a22fa	f0 1f		beq $3a231b	            BEQ skip_loop               ; Skip over it and try to execute the next one
.3a22fc	08		php		            PHP
.3a22fd	c2 20		rep #$20	            REP #$20
.3a22ff	48		pha		            PHA
.3a2300	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2303	5b		tcd		            TCD
.3a2304	68		pla		            PLA
.3a2305	28		plp		            PLP
.3a2306	e2 20		sep #$20	            SEP #$20
.3a2308	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a230a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a230e	c2 20		rep #$20	            REP #$20
.3a2310	29 ff 00	and #$00ff	            AND #$00FF
.3a2313	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2316	e2 20		sep #$20	            SEP #$20
.3a2318	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a231b					skip_loop
.3a231b	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a231e	80 be		bra $3a22de	            BRA exec_loop               ; And try to execute another statement
.3a2320					exec_done
.3a2320	28		plp		            PLP
.3a2321	60		rts		            RTS
.3a2322					EXECPROGRAM
.3a2322	08		php		            PHP
.3a2323	58		cli		            CLI
.3a2324	e2 20		sep #$20	            SEP #$20
.3a2326	a9 80		lda #$80	            LDA #ST_RUNNING
.3a2328	85 d2		sta $08d2	            STA STATE
.3a232a	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a232d	20 52 1d	jsr $3a1d52	            JSR INITRETURN
.3a2330	c2 30		rep #$30	            REP #$30
.3a2332	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.3a2334	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.3a2337	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.3a2339	f0 29		beq $3a2364	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.3a233b	20 b7 22	jsr $3a22b7	            JSR EXECLINE
.3a233e	e2 20		sep #$20	            SEP #$20
.3a2340	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.3a2342	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.3a2344	f0 1e		beq $3a2364	            BEQ done
.3a2346	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.3a2348	f0 ea		beq $3a2334	            BEQ exec_loop
.3a234a	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.3a234c	f0 e6		beq $3a2334	            BEQ exec_loop
.3a234e	c2 20		rep #$20	            REP #$20
.3a2350	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a2353	18		clc		            CLC
.3a2354	a5 1a		lda $081a	            LDA CURLINE
.3a2356	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.3a2358	85 1a		sta $081a	            STA CURLINE
.3a235a	e2 20		sep #$20	            SEP #$20
.3a235c	a5 1c		lda $081c	            LDA CURLINE+2
.3a235e	69 00		adc #$00	            ADC #0
.3a2360	85 1c		sta $081c	            STA CURLINE+2
.3a2362	80 d0		bra $3a2334	            BRA exec_loop               ; And try to execute that line
.3a2364					done
.3a2364	e2 20		sep #$20	            SEP #$20
.3a2366	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.3a2368	85 d2		sta $08d2	            STA STATE
.3a236a	28		plp		            PLP
.3a236b	60		rts		            RTS
.3a236c					FINDLINE
.3a236c	08		php		            PHP
.3a236d	c2 30		rep #$30	            REP #$30
.3a236f	c2 20		rep #$20	            REP #$20
.3a2371	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.3a2374	85 08		sta $0808	            STA INDEX
.3a2376	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a2379	85 0a		sta $080a	            STA INDEX+2
.3a237b	c2 20		rep #$20	            REP #$20
.3a237d	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.3a2380	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a2382	f0 31		beq $3a23b5	            BEQ ret_false               ; If new line number is 0, we got to the
.3a2384	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.3a2386	f0 1e		beq $3a23a6	            BEQ found
.3a2388	b0 2b		bcs $3a23b5	            BGE ret_false               ; If the line number > target line number, the line is not present
.3a238a					next_line
.3a238a	c2 20		rep #$20	            REP #$20
.3a238c	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.3a238f	18		clc		            CLC
.3a2390	a5 08		lda $0808	            LDA INDEX
.3a2392	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2394	85 0c		sta $080c	            STA SCRATCH
.3a2396	e2 20		sep #$20	            SEP #$20
.3a2398	a5 0a		lda $080a	            LDA INDEX+2
.3a239a	69 00		adc #$00	            ADC #0
.3a239c	85 0a		sta $080a	            STA INDEX+2
.3a239e	c2 20		rep #$20	            REP #$20
.3a23a0	a5 0c		lda $080c	            LDA SCRATCH
.3a23a2	85 08		sta $0808	            STA INDEX
.3a23a4	80 d7		bra $3a237d	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.3a23a6					found
.3a23a6	c2 20		rep #$20	            REP #$20
.3a23a8	a5 08		lda $0808	            LDA INDEX
.3a23aa	85 1a		sta $081a	            STA CURLINE
.3a23ac	e2 20		sep #$20	            SEP #$20
.3a23ae	a5 0a		lda $080a	            LDA INDEX+2
.3a23b0	85 1c		sta $081c	            STA CURLINE+2
.3a23b2	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.3a23b3	38		sec		            SEC
.3a23b4	60		rts		            RTS
.3a23b5	28		plp		ret_false   PLP
.3a23b6	18		clc		            CLC
.3a23b7	60		rts		            RTS
.3a23b8					MVPROGDN
.3a23b8	08		php		            PHP
.3a23b9					mvd_loop
.3a23b9	e2 20		sep #$20	            SEP #$20
.3a23bb	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a23bd	87 08		sta [$0808]	            STA [INDEX]
.3a23bf	c2 20		rep #$20	            REP #$20
.3a23c1	a5 0c		lda $080c	            LDA SCRATCH
.3a23c3	c5 00		cmp $0800	            CMP BIP
.3a23c5	d0 08		bne $3a23cf	            BNE increment
.3a23c7	e2 20		sep #$20	            SEP #$20
.3a23c9	a5 0e		lda $080e	            LDA SCRATCH+2
.3a23cb	c5 02		cmp $0802	            CMP BIP+2
.3a23cd	f0 26		beq $3a23f5	            BEQ done            ; Yes: return
.3a23cf					increment
.3a23cf	c2 20		rep #$20	            REP #$20
.3a23d1	18		clc		            CLC
.3a23d2	a5 0c		lda $080c	            LDA SCRATCH
.3a23d4	69 01 00	adc #$0001	            ADC #1
.3a23d7	85 0c		sta $080c	            STA SCRATCH
.3a23d9	e2 20		sep #$20	            SEP #$20
.3a23db	a5 0e		lda $080e	            LDA SCRATCH+2
.3a23dd	69 00		adc #$00	            ADC #0
.3a23df	85 0e		sta $080e	            STA SCRATCH+2
.3a23e1	c2 20		rep #$20	            REP #$20
.3a23e3	18		clc		            CLC
.3a23e4	a5 08		lda $0808	            LDA INDEX
.3a23e6	69 01 00	adc #$0001	            ADC #1
.3a23e9	85 08		sta $0808	            STA INDEX
.3a23eb	e2 20		sep #$20	            SEP #$20
.3a23ed	a5 0a		lda $080a	            LDA INDEX+2
.3a23ef	69 00		adc #$00	            ADC #0
.3a23f1	85 0a		sta $080a	            STA INDEX+2
.3a23f3	80 c4		bra $3a23b9	            BRA mvd_loop        ; And try again
.3a23f5	28		plp		done        PLP
.3a23f6	60		rts		            RTS
.3a23f7					MVPROGUP
.3a23f7	08		php		            PHP
.3a23f8					mvu_loop
.3a23f8	e2 20		sep #$20	            SEP #$20
.3a23fa	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a23fc	87 08		sta [$0808]	            STA [INDEX]
.3a23fe	c2 20		rep #$20	            REP #$20
.3a2400	a5 0c		lda $080c	            LDA SCRATCH
.3a2402	c5 00		cmp $0800	            CMP BIP
.3a2404	d0 06		bne $3a240c	            BNE decrement
.3a2406	a5 0e		lda $080e	            LDA SCRATCH+2
.3a2408	c5 02		cmp $0802	            CMP BIP+2
.3a240a	f0 26		beq $3a2432	            BEQ done            ; Yes: return
.3a240c					decrement
.3a240c	c2 20		rep #$20	            REP #$20
.3a240e	38		sec		            SEC
.3a240f	a5 0c		lda $080c	            LDA SCRATCH
.3a2411	e9 01 00	sbc #$0001	            SBC #1
.3a2414	85 0c		sta $080c	            STA SCRATCH
.3a2416	e2 20		sep #$20	            SEP #$20
.3a2418	a5 0e		lda $080e	            LDA SCRATCH+2
.3a241a	e9 00		sbc #$00	            SBC #0
.3a241c	85 0e		sta $080e	            STA SCRATCH+2
.3a241e	c2 20		rep #$20	            REP #$20
.3a2420	38		sec		            SEC
.3a2421	a5 08		lda $0808	            LDA INDEX
.3a2423	e9 01 00	sbc #$0001	            SBC #1
.3a2426	85 08		sta $0808	            STA INDEX
.3a2428	e2 20		sep #$20	            SEP #$20
.3a242a	a5 0a		lda $080a	            LDA INDEX+2
.3a242c	e9 00		sbc #$00	            SBC #0
.3a242e	85 0a		sta $080a	            STA INDEX+2
.3a2430	80 c6		bra $3a23f8	            BRA mvu_loop        ; And try again
.3a2432	28		plp		done        PLP
.3a2433	60		rts		            RTS
.3a2434					DELLINE
.3a2434	08		php		            PHP
.3a2435	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.3a2438	c2 20		rep #$20	            REP #$20
.3a243a	18		clc		            CLC
.3a243b	a5 08		lda $0808	            LDA INDEX
.3a243d	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a243f	85 0c		sta $080c	            STA SCRATCH
.3a2441	e2 20		sep #$20	            SEP #$20
.3a2443	a5 0a		lda $080a	            LDA INDEX+2
.3a2445	69 00		adc #$00	            ADC #0
.3a2447	85 0e		sta $080e	            STA SCRATCH+2
.3a2449	c2 20		rep #$20	            REP #$20
.3a244b	18		clc		            CLC
.3a244c	a5 d9		lda $08d9	            LDA LASTLINE
.3a244e	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2451	85 00		sta $0800	            STA BIP
.3a2453	e2 20		sep #$20	            SEP #$20
.3a2455	a5 db		lda $08db	            LDA LASTLINE+2
.3a2457	69 00		adc #$00	            ADC #0
.3a2459	85 02		sta $0802	            STA BIP+2
.3a245b	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.3a245e	c2 20		rep #$20	            REP #$20
.3a2460	38		sec		            SEC
.3a2461	a5 d9		lda $08d9	            LDA LASTLINE
.3a2463	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.3a2465	85 d9		sta $08d9	            STA LASTLINE
.3a2467	e2 20		sep #$20	            SEP #$20
.3a2469	a5 db		lda $08db	            LDA LASTLINE+2
.3a246b	e9 00		sbc #$00	            SBC #0
.3a246d	85 db		sta $08db	            STA LASTLINE+2
.3a246f	20 b8 23	jsr $3a23b8	            JSR MVPROGDN
.3a2472					done
.3a2472	20 c7 43	jsr $3a43c7	            JSR S_CLR
.3a2475	28		plp		            PLP
.3a2476	60		rts		            RTS
.3a2477					APPLINE
.3a2477	08		php		            PHP
.3a2478	08		php		            PHP
.3a2479	c2 20		rep #$20	            REP #$20
.3a247b	48		pha		            PHA
.3a247c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a247f	5b		tcd		            TCD
.3a2480	68		pla		            PLA
.3a2481	28		plp		            PLP
.3a2482	c2 30		rep #$30	            REP #$30
.3a2484	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.3a2487	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a2489	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.3a248a	a5 d9		lda $08d9	            LDA LASTLINE
.3a248c	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a248f	85 08		sta $0808	            STA INDEX
.3a2491	e2 20		sep #$20	            SEP #$20
.3a2493	a5 db		lda $08db	            LDA LASTLINE+2
.3a2495	69 00		adc #$00	            ADC #0
.3a2497	85 0a		sta $080a	            STA INDEX+2
.3a2499	e2 20		sep #$20	            SEP #$20
.3a249b	a0 00 00	ldy #$0000	            LDY #0
.3a249e	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.3a24a0	97 08		sta [$0808],y	            STA [INDEX],Y
.3a24a2	f0 03		beq $3a24a7	            BEQ copy_done
.3a24a4	c8		iny		            INY
.3a24a5	80 f7		bra $3a249e	            BRA copy_loop
.3a24a7					copy_done
.3a24a7	c2 20		rep #$20	            REP #$20
.3a24a9	98		tya		            TYA
.3a24aa	18		clc		            CLC
.3a24ab	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.3a24ae	85 0c		sta $080c	            STA SCRATCH
.3a24b0	c2 20		rep #$20	            REP #$20
.3a24b2	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.3a24b5	a5 0c		lda $080c	            LDA SCRATCH
.3a24b7	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a24b9	c2 20		rep #$20	            REP #$20
.3a24bb	18		clc		            CLC
.3a24bc	a5 d9		lda $08d9	            LDA LASTLINE
.3a24be	65 0c		adc $080c	            ADC SCRATCH
.3a24c0	85 0c		sta $080c	            STA SCRATCH
.3a24c2	e2 20		sep #$20	            SEP #$20
.3a24c4	a5 db		lda $08db	            LDA LASTLINE+2
.3a24c6	69 00		adc #$00	            ADC #0
.3a24c8	85 db		sta $08db	            STA LASTLINE+2
.3a24ca	c2 20		rep #$20	            REP #$20
.3a24cc	a5 0c		lda $080c	            LDA SCRATCH
.3a24ce	85 d9		sta $08d9	            STA LASTLINE
.3a24d0	c2 20		rep #$20	            REP #$20
.3a24d2	a0 00 00	ldy #$0000	            LDY #0
.3a24d5	a9 00 00	lda #$0000	            LDA #0
.3a24d8	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.3a24da	c8		iny		            INY
.3a24db	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.3a24de	d0 f8		bne $3a24d8	            BNE blank_loop
.3a24e0	20 c7 43	jsr $3a43c7	            JSR S_CLR
.3a24e3	28		plp		            PLP
.3a24e4	60		rts		            RTS
.3a24e5					FINDINSPT
.3a24e5	0b		phd		            PHD
.3a24e6	08		php		            PHP
.3a24e7	08		php		            PHP
.3a24e8	c2 20		rep #$20	            REP #$20
.3a24ea	48		pha		            PHA
.3a24eb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a24ee	5b		tcd		            TCD
.3a24ef	68		pla		            PLA
.3a24f0	28		plp		            PLP
.3a24f1	c2 30		rep #$30	            REP #$30
.3a24f3	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a24f6	85 08		sta $0808	            STA INDEX
.3a24f8	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a24fb	85 0a		sta $080a	            STA INDEX+2
.3a24fd	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.3a2500	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a2502	f0 1d		beq $3a2521	            BEQ found_end           ; Got to end without finding it
.3a2504	c5 d7		cmp $08d7	            CMP LINENUM
.3a2506	f0 25		beq $3a252d	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.3a2508	b0 1d		bcs $3a2527	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.3a250a	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a250d	18		clc		            CLC                     ; Move INDEX to the next line
.3a250e	a5 08		lda $0808	            LDA INDEX
.3a2510	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2512	85 0c		sta $080c	            STA SCRATCH
.3a2514	a5 0a		lda $080a	            LDA INDEX+2
.3a2516	69 00 00	adc #$0000	            ADC #0
.3a2519	85 0a		sta $080a	            STA INDEX+2
.3a251b	a5 0c		lda $080c	            LDA SCRATCH
.3a251d	85 08		sta $0808	            STA INDEX
.3a251f	80 dc		bra $3a24fd	            BRA loop                ; And check that line
.3a2521	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.3a2524	28		plp		            PLP
.3a2525	2b		pld		            PLD
.3a2526	60		rts		            RTS
.3a2527	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.3a252a	28		plp		            PLP                     ; But that it wasn't already there
.3a252b	2b		pld		            PLD
.3a252c	60		rts		            RTS
.3a252d	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.3a2530	28		plp		            PLP
.3a2531	2b		pld		            PLD
.3a2532	60		rts		            RTS
.3a2533					INSLINE
.3a2533	08		php		            PHP
.3a2534	c2 30		rep #$30	            REP #$30
.3a2536	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.3a2539	85 10		sta $0810	            STA SCRATCH2
.3a253b	a0 00 00	ldy #$0000	            LDY #0
.3a253e					count_loop
.3a253e	e2 20		sep #$20	            SEP #$20
.3a2540	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.3a2542	f0 07		beq $3a254b	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.3a2544	c2 20		rep #$20	            REP #$20
.3a2546	e6 10		inc $0810	            INC SCRATCH2
.3a2548	c8		iny		            INY
.3a2549	80 f3		bra $3a253e	            BRA count_loop      ; Count and continue
.3a254b					shift_prog
.3a254b	c2 20		rep #$20	            REP #$20
.3a254d	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.3a254f	85 00		sta $0800	            STA BIP
.3a2551	a5 0a		lda $080a	            LDA INDEX+2
.3a2553	85 02		sta $0802	            STA BIP+2
.3a2555	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.3a2556	a5 d9		lda $08d9	            LDA LASTLINE
.3a2558	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a255b	85 0c		sta $080c	            STA SCRATCH
.3a255d	a5 db		lda $08db	            LDA LASTLINE+2
.3a255f	69 00 00	adc #$0000	            ADC #0
.3a2562	85 0e		sta $080e	            STA SCRATCH+2
.3a2564	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.3a2565	a5 d9		lda $08d9	            LDA LASTLINE
.3a2567	65 10		adc $0810	            ADC SCRATCH2
.3a2569	85 d9		sta $08d9	            STA LASTLINE
.3a256b	a5 db		lda $08db	            LDA LASTLINE+2
.3a256d	69 00 00	adc #$0000	            ADC #0
.3a2570	85 db		sta $08db	            STA LASTLINE+2
.3a2572	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.3a2573	a5 d9		lda $08d9	            LDA LASTLINE
.3a2575	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2578	85 08		sta $0808	            STA INDEX
.3a257a	a5 db		lda $08db	            LDA LASTLINE+2
.3a257c	69 00 00	adc #$0000	            ADC #0
.3a257f	85 0a		sta $080a	            STA INDEX+2
.3a2581	20 f7 23	jsr $3a23f7	            JSR MVPROGUP
.3a2584	c2 20		rep #$20	            REP #$20
.3a2586	a5 10		lda $0810	            LDA SCRATCH2
.3a2588	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a258b	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.3a258d	a5 d7		lda $08d7	            LDA LINENUM
.3a258f	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a2592	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.3a2594	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.3a2595	a5 00		lda $0800	            LDA BIP
.3a2597	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a259a	85 00		sta $0800	            STA BIP
.3a259c	a5 02		lda $0802	            LDA BIP+2
.3a259e	69 00 00	adc #$0000	            ADC #0
.3a25a1	85 02		sta $0802	            STA BIP+2
.3a25a3	a0 00 00	ldy #$0000	            LDY #0
.3a25a6	e2 20		sep #$20	            SEP #$20
.3a25a8	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.3a25aa	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.3a25ac	f0 03		beq $3a25b1	            BEQ done            ; If it was end-of-line byte, we're done
.3a25ae	c8		iny		            INY
.3a25af	80 f7		bra $3a25a8	            BRA copy_loop       ; Otherwise, continue with the next
.3a25b1					done
.3a25b1	20 c7 43	jsr $3a43c7	            JSR S_CLR
.3a25b4	28		plp		            PLP
.3a25b5	60		rts		            RTS
.3a25b6					ADDLINE
.3a25b6	08		php		            PHP
.3a25b7	c2 30		rep #$30	            REP #$30
.3a25b9	85 d7		sta $08d7	            STA LINENUM
.3a25bb	20 e5 24	jsr $3a24e5	            JSR FINDINSPT
.3a25be	c9 00 00	cmp #$0000	            CMP #0
.3a25c1	f0 2c		beq $3a25ef	            BEQ do_append       ; End-of-program found, add the line to the end
.3a25c3	c9 01 00	cmp #$0001	            CMP #1
.3a25c6	f0 22		beq $3a25ea	            BEQ do_insert       ; Spot was found: insertion required
.3a25c8	c2 20		rep #$20	            REP #$20
.3a25ca	a5 08		lda $0808	            LDA INDEX
.3a25cc	48		pha		            PHA
.3a25cd	a5 0a		lda $080a	            LDA INDEX+2
.3a25cf	48		pha		            PHA
.3a25d0	20 34 24	jsr $3a2434	            JSR DELLINE
.3a25d3	68		pla		            PLA
.3a25d4	85 0a		sta $080a	            STA INDEX+2
.3a25d6	68		pla		            PLA
.3a25d7	85 08		sta $0808	            STA INDEX
.3a25d9	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.3a25db	85 00		sta $0800	            STA BIP
.3a25dd	a5 1c		lda $081c	            LDA CURLINE+2
.3a25df	85 02		sta $0802	            STA BIP+2
.3a25e1	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a25e4	e2 20		sep #$20	            SEP #$20
.3a25e6	a7 00		lda [$0800]	            LDA [BIP]
.3a25e8	f0 0a		beq $3a25f4	            BEQ done            ; If not, we're done
.3a25ea					do_insert
.3a25ea	20 33 25	jsr $3a2533	            JSR INSLINE
.3a25ed	80 05		bra $3a25f4	            BRA done
.3a25ef	a5 d7		lda $08d7	do_append   LDA LINENUM
.3a25f1	20 77 24	jsr $3a2477	            JSR APPLINE
.3a25f4	28		plp		done        PLP
.3a25f5	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.3a25f6					EXPANDLINE
.3a25f6	0b		phd		                PHD
.3a25f7	08		php		                PHP
.3a25f8	08		php		            PHP
.3a25f9	c2 20		rep #$20	            REP #$20
.3a25fb	48		pha		            PHA
.3a25fc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a25ff	5b		tcd		            TCD
.3a2600	68		pla		            PLA
.3a2601	28		plp		            PLP
.3a2602	e2 20		sep #$20	            SEP #$20
.3a2604	c2 10		rep #$10	            REP #$10
.3a2606	a2 00 00	ldx #$0000	                LDX #0
.3a2609	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.3a260c	f0 03		beq $3a2611	                BEQ save_size
.3a260e	e8		inx		                INX
.3a260f	80 f8		bra $3a2609	                BRA count_loop
.3a2611	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.3a2613	c2 30		rep #$30	            REP #$30
.3a2615	8a		txa		                TXA
.3a2616	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.3a2619	90 12		bcc $3a262d	                BLT start_copy              ; No: just replace the whole string
.3a261b	3a		dec a		                DEC A
.3a261c	18		clc		                CLC
.3a261d	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.3a2620	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.3a2621	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.3a2622	65 8f		adc $088f	                ADC MCOUNT
.3a2624	a8		tay		                TAY
.3a2625	a5 0c		lda $080c	                LDA SCRATCH
.3a2627	3a		dec a		                DEC A
.3a2628	8b		phb		                PHB
.3a2629	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.3a262c	ab		plb		                PLB
.3a262d					start_copy
.3a262d	c2 20		rep #$20	            REP #$20
.3a262f	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.3a2631	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.3a2634	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.3a2636	8b		phb		                PHB
.3a2637	54 00 3a	mvn #$3a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.3a263a	ab		plb		                PLB
.3a263b	e2 20		sep #$20	            SEP #$20
.3a263d	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.3a263f	c9 02		cmp #$02	                CMP #2
.3a2641	90 18		bcc $3a265b	                BLT done
.3a2643	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.3a2645	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.3a2647	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a264a	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.3a264b	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.3a264e	d0 fa		bne $3a264a	                BNE skip_to_end
.3a2650	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.3a2652	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a2655	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.3a2657	e8		inx		                INX
.3a2658	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a265b	28		plp		done            PLP
.3a265c	2b		pld		                PLD
.3a265d	60		rts		            RTS
.3a265e					PREPROCESS
.3a265e	da		phx		                PHX
.3a265f	5a		phy		                PHY
.3a2660	8b		phb		                PHB
.3a2661	0b		phd		                PHD
.3a2662	08		php		                PHP
.3a2663	08		php		            PHP
.3a2664	c2 20		rep #$20	            REP #$20
.3a2666	48		pha		            PHA
.3a2667	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a266a	5b		tcd		            TCD
.3a266b	68		pla		            PLA
.3a266c	28		plp		            PLP
.3a266d	e2 20		sep #$20	            SEP #$20
.3a266f	c2 10		rep #$10	            REP #$10
.3a2671	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.3a2674	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.3a2676	f0 0a		beq $3a2682	                BEQ expand_dir          ; Yes: expand the DIR command into place
.3a2678	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.3a267a	f0 17		beq $3a2693	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.3a267c	28		plp		done            PLP
.3a267d	2b		pld		                PLD
.3a267e	ab		plb		                PLB
.3a267f	7a		ply		                PLY
.3a2680	fa		plx		                PLX
.3a2681	60		rts		            RTS
.3a2682					expand_dir
.3a2682	c2 20		rep #$20	            REP #$20
.3a2684	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.3a2687	85 8f		sta $088f	                STA MCOUNT
.3a2689	a9 a4 26	lda #$26a4	                LDA #<>dir_text         ; Set pointer to substitution value
.3a268c	85 55		sta $0855	                STA MARG1
.3a268e	20 f6 25	jsr $3a25f6	            JSR EXPANDLINE
.3a2691	80 e9		bra $3a267c	                BRA done
.3a2693					expand_brun
.3a2693	c2 20		rep #$20	            REP #$20
.3a2695	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.3a2698	85 8f		sta $088f	                STA MCOUNT
.3a269a	a9 a8 26	lda #$26a8	                LDA #<>brun_text        ; Set pointer to substitution value
.3a269d	85 55		sta $0855	                STA MARG1
.3a269f	20 f6 25	jsr $3a25f6	            JSR EXPANDLINE
.3a26a2	80 d8		bra $3a267c	                BRA done
>3a26a4	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>3a26a8	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.3a26ad					PRREADY
.3a26ad	8b		phb		                PHB
.3a26ae	08		php		                PHP
.3a26af	20 cc 01	jsr $3a01cc	            JSR ENSURETEXT
.3a26b2	08		php		            PHP
.3a26b3	e2 20		sep #$20	            SEP #$20
.3a26b5	48		pha		            PHA
.3a26b6	a9 3a		lda #$3a	            LDA #`MPROMPT
.3a26b8	48		pha		            PHA
.3a26b9	ab		plb		            PLB
.3a26ba	68		pla		            PLA
.3a26bb	28		plp		            PLP
.3a26bc	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.3a26bf	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a26c2	28		plp		                PLP
.3a26c3	ab		plb		                PLB
.3a26c4	60		rts		            RTS
.3a26c5					IREADLINE
.3a26c5	08		php		                PHP
.3a26c6	e2 30		sep #$30	            SEP #$30
.3a26c8	a9 01		lda #$01	                LDA #1
.3a26ca	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a26cd					read_loop
.3a26cd	20 db 00	jsr $3a00db	            JSR GETKEYE
.3a26d0	c9 00		cmp #$00	                CMP #0
.3a26d2	f0 f9		beq $3a26cd	                BEQ read_loop
.3a26d4	c9 0d		cmp #$0d	                CMP #CHAR_CR
.3a26d6	f0 02		beq $3a26da	                BEQ done
.3a26d8	80 f3		bra $3a26cd	                BRA read_loop
.3a26da	28		plp		done            PLP
.3a26db	60		rts		            RTS
.3a26dc					PROCESS
.3a26dc	0b		phd		                PHD
.3a26dd	08		php		                PHP
.3a26de	08		php		            PHP
.3a26df	c2 20		rep #$20	            REP #$20
.3a26e1	48		pha		            PHA
.3a26e2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a26e5	5b		tcd		            TCD
.3a26e6	68		pla		            PLA
.3a26e7	28		plp		            PLP
.3a26e8	c2 30		rep #$30	            REP #$30
.3a26ea	64 d7		stz $08d7	                STZ LINENUM
.3a26ec	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.3a26ef	85 1a		sta $081a	                STA CURLINE
.3a26f1	a9 00 00	lda #$0000	                LDA #`CURLINE
.3a26f4	85 1c		sta $081c	                STA CURLINE+2
.3a26f6	20 f0 08	jsr $3a08f0	            JSR TOKENIZE
.3a26f9	c2 20		rep #$20	            REP #$20
.3a26fb	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.3a26fd	d0 05		bne $3a2704	                BNE update_line         ; Yes: attempt to add it to the program
.3a26ff	20 9d 22	jsr $3a229d	            JSR EXECCMD
.3a2702	80 07		bra $3a270b	                BRA done
.3a2704					update_line
.3a2704	20 b6 25	jsr $3a25b6	            JSR ADDLINE
.3a2707	28		plp		no_prompt       PLP
.3a2708	2b		pld		                PLD
.3a2709	38		sec		                SEC
.3a270a	60		rts		            RTS
.3a270b	28		plp		done            PLP
.3a270c	2b		pld		                PLD
.3a270d	18		clc		                CLC
.3a270e	60		rts		            RTS
.3a270f					INTERACT
.3a270f	c2 30		rep #$30	            REP #$30
.3a2711	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.3a2714	9a		txs		                TXS
.3a2715					ready_loop
.3a2715	20 ad 26	jsr $3a26ad	            JSR PRREADY
.3a2718					no_ready_loop
.3a2718	20 08 00	jsr $3a0008	            JSR READLINE
.3a271b	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a271e	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.3a2722	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.3a2725	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a2728	20 5e 26	jsr $3a265e	            JSR PREPROCESS
.3a272b	20 dc 26	jsr $3a26dc	            JSR PROCESS
.3a272e	b0 e8		bcs $3a2718	                BCS no_ready_loop
.3a2730	80 e3		bra $3a2715	                BRA ready_loop
>3ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.3a2732					OP_PLUS
.3a2732	08		php		            PHP
.3a2733	e2 20		sep #$20	            SEP #$20
.3a2735	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a2738	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a273a	f0 2c		beq $3a2768	            BEQ is_integer
.3a273c	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a273e	f0 2d		beq $3a276d	            BEQ is_float
.3a2740	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2742	f0 1f		beq $3a2763	            BEQ is_string
.3a2744					type_error
.3a2744	08		php		            PHP
.3a2745	c2 20		rep #$20	            REP #$20
.3a2747	48		pha		            PHA
.3a2748	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a274b	5b		tcd		            TCD
.3a274c	68		pla		            PLA
.3a274d	28		plp		            PLP
.3a274e	e2 20		sep #$20	            SEP #$20
.3a2750	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2752	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2756	c2 20		rep #$20	            REP #$20
.3a2758	29 ff 00	and #$00ff	            AND #$00FF
.3a275b	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a275e	e2 20		sep #$20	            SEP #$20
.3a2760	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2763					is_string
.3a2763	20 a0 15	jsr $3a15a0	            JSR STRCONCAT
.3a2766	80 08		bra $3a2770	            BRA done
.3a2768					is_integer
.3a2768	20 19 53	jsr $3a5319	            JSR OP_INT_ADD
.3a276b	80 03		bra $3a2770	            BRA done
.3a276d					is_float
.3a276d	20 88 55	jsr $3a5588	            JSR OP_FP_ADD
.3a2770	28		plp		done        PLP
.3a2771	60		rts		            RTS
.3a2772					OP_MINUS
.3a2772	08		php		            PHP
.3a2773	e2 20		sep #$20	            SEP #$20
.3a2775	20 a9 07	jsr $3a07a9	            JSR ASS_ARGS_NUM
.3a2778	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a277a	f0 23		beq $3a279f	            BEQ is_integer
.3a277c	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a277e	f0 24		beq $3a27a4	            BEQ is_float
.3a2780					type_error
.3a2780	08		php		            PHP
.3a2781	c2 20		rep #$20	            REP #$20
.3a2783	48		pha		            PHA
.3a2784	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2787	5b		tcd		            TCD
.3a2788	68		pla		            PLA
.3a2789	28		plp		            PLP
.3a278a	e2 20		sep #$20	            SEP #$20
.3a278c	a9 04		lda #$04	            LDA #ERR_TYPE
.3a278e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2792	c2 20		rep #$20	            REP #$20
.3a2794	29 ff 00	and #$00ff	            AND #$00FF
.3a2797	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a279a	e2 20		sep #$20	            SEP #$20
.3a279c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a279f					is_integer
.3a279f	20 2b 53	jsr $3a532b	            JSR OP_INT_SUB
.3a27a2	80 03		bra $3a27a7	            BRA done
.3a27a4					is_float
.3a27a4	20 7d 55	jsr $3a557d	            JSR OP_FP_SUB
.3a27a7	28		plp		done        PLP
.3a27a8	60		rts		            RTS
.3a27a9					OP_MULTIPLY
.3a27a9	08		php		            PHP
.3a27aa	e2 20		sep #$20	            SEP #$20
.3a27ac	20 a9 07	jsr $3a07a9	            JSR ASS_ARGS_NUM
.3a27af	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27b1	f0 23		beq $3a27d6	            BEQ is_integer
.3a27b3	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27b5	f0 24		beq $3a27db	            BEQ is_float
.3a27b7					type_error
.3a27b7	08		php		            PHP
.3a27b8	c2 20		rep #$20	            REP #$20
.3a27ba	48		pha		            PHA
.3a27bb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27be	5b		tcd		            TCD
.3a27bf	68		pla		            PLA
.3a27c0	28		plp		            PLP
.3a27c1	e2 20		sep #$20	            SEP #$20
.3a27c3	a9 04		lda #$04	            LDA #ERR_TYPE
.3a27c5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a27c9	c2 20		rep #$20	            REP #$20
.3a27cb	29 ff 00	and #$00ff	            AND #$00FF
.3a27ce	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a27d1	e2 20		sep #$20	            SEP #$20
.3a27d3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a27d6					is_integer
.3a27d6	20 3d 53	jsr $3a533d	            JSR OP_INT_MUL
.3a27d9	80 03		bra $3a27de	            BRA done
.3a27db					is_float
.3a27db	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a27de	28		plp		done        PLP
.3a27df	60		rts		            RTS
.3a27e0					OP_DIVIDE
.3a27e0	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a27e3	20 44 07	jsr $3a0744	            JSR ASS_ARG2_FLOAT
.3a27e6	20 d3 55	jsr $3a55d3	            JSR OP_FP_DIV
.3a27e9	60		rts		            RTS
.3a27ea					OP_MOD
.3a27ea	a5 23		lda $0823	            LDA ARGUMENT1
.3a27ec	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.3a27f0	a5 29		lda $0829	            LDA ARGUMENT2
.3a27f2	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.3a27f6	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.3a27fa	85 23		sta $0823	            STA ARGUMENT1
.3a27fc	60		rts		            RTS
.3a27fd					OP_POW
.3a27fd	08		php		            PHP
.3a27fe	c2 30		rep #$30	            REP #$30
.3a2800	48		pha		            PHA
.3a2801	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a2804	a5 2d		lda $082d	            LDA ARGTYPE2
.3a2806	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.3a2809	d0 0d		bne $3a2818	            BNE flt_exp
.3a280b	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a280d	d0 09		bne $3a2818	            BNE flt_exp
.3a280f	da		phx		            PHX
.3a2810	a6 29		ldx $0829	            LDX ARGUMENT2
.3a2812	20 f1 62	jsr $3a62f1	            JSR Q_FP_POW_INT
.3a2815	fa		plx		            PLX
.3a2816	80 1c		bra $3a2834	            BRA done
.3a2818					flt_exp
.3a2818	20 44 07	jsr $3a0744	            JSR ASS_ARG2_FLOAT
.3a281b	c2 20		rep #$20	            REP #$20
.3a281d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a281f	48		pha		            PHA
.3a2820	a5 29		lda $0829	            LDA ARGUMENT2
.3a2822	48		pha		            PHA
.3a2823	20 7c 61	jsr $3a617c	            JSR FP_LN
.3a2826	c2 20		rep #$20	            REP #$20
.3a2828	68		pla		            PLA
.3a2829	85 29		sta $0829	            STA ARGUMENT2
.3a282b	68		pla		            PLA
.3a282c	85 2b		sta $082b	            STA ARGUMENT2+2
.3a282e	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a2831	20 5b 63	jsr $3a635b	            JSR FP_EXP
.3a2834	68		pla		done        PLA
.3a2835	28		plp		            PLP
.3a2836	60		rts		            RTS
.3a2837					OP_AND
.3a2837	08		php		            PHP
.3a2838	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a283b	20 d6 05	jsr $3a05d6	            JSR ASS_ARG2_INT
.3a283e	c2 20		rep #$20	            REP #$20
.3a2840	a5 23		lda $0823	            LDA ARGUMENT1
.3a2842	25 29		and $0829	            AND ARGUMENT2
.3a2844	85 23		sta $0823	            STA ARGUMENT1
.3a2846	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a2848	25 2b		and $082b	            AND ARGUMENT2+2
.3a284a	85 25		sta $0825	            STA ARGUMENT1+2
.3a284c	28		plp		            PLP
.3a284d	60		rts		            RTS
.3a284e					OP_OR
.3a284e	08		php		            PHP
.3a284f	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a2852	20 d6 05	jsr $3a05d6	            JSR ASS_ARG2_INT
.3a2855	c2 20		rep #$20	            REP #$20
.3a2857	a5 23		lda $0823	            LDA ARGUMENT1
.3a2859	05 29		ora $0829	            ORA ARGUMENT2
.3a285b	85 23		sta $0823	            STA ARGUMENT1
.3a285d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a285f	05 2b		ora $082b	            ORA ARGUMENT2+2
.3a2861	85 25		sta $0825	            STA ARGUMENT1+2
.3a2863	28		plp		done        PLP
.3a2864	60		rts		            RTS
.3a2865					OP_NOT
.3a2865	08		php		            PHP
.3a2866	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a2869	c2 20		rep #$20	            REP #$20
.3a286b	a5 23		lda $0823	            LDA ARGUMENT1
.3a286d	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a2870	85 23		sta $0823	            STA ARGUMENT1
.3a2872	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a2874	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a2877	85 25		sta $0825	            STA ARGUMENT1+2
.3a2879	28		plp		done        PLP
.3a287a	60		rts		            RTS
.3a287b					OP_LT
.3a287b	08		php		            PHP
.3a287c	e2 20		sep #$20	            SEP #$20
.3a287e	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a2881	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2883	f0 2c		beq $3a28b1	            BEQ is_integer
.3a2885	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2887	f0 2d		beq $3a28b6	            BEQ is_float
.3a2889	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a288b	f0 1f		beq $3a28ac	            BEQ is_string
.3a288d					type_error
.3a288d	08		php		            PHP
.3a288e	c2 20		rep #$20	            REP #$20
.3a2890	48		pha		            PHA
.3a2891	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2894	5b		tcd		            TCD
.3a2895	68		pla		            PLA
.3a2896	28		plp		            PLP
.3a2897	e2 20		sep #$20	            SEP #$20
.3a2899	a9 04		lda #$04	            LDA #ERR_TYPE
.3a289b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a289f	c2 20		rep #$20	            REP #$20
.3a28a1	29 ff 00	and #$00ff	            AND #$00FF
.3a28a4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a28a7	e2 20		sep #$20	            SEP #$20
.3a28a9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a28ac					is_string
.3a28ac	20 28 17	jsr $3a1728	            JSR OP_STR_LT
.3a28af	80 08		bra $3a28b9	            BRA done
.3a28b1					is_integer
.3a28b1	20 3e 54	jsr $3a543e	            JSR OP_INT_LT
.3a28b4	80 03		bra $3a28b9	            BRA done
.3a28b6					is_float
.3a28b6	20 b3 5b	jsr $3a5bb3	            JSR OP_FP_LT
.3a28b9	28		plp		done        PLP
.3a28ba	60		rts		            RTS
.3a28bb					OP_GT
.3a28bb	08		php		            PHP
.3a28bc	e2 20		sep #$20	            SEP #$20
.3a28be	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a28c1	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a28c3	f0 2c		beq $3a28f1	            BEQ is_integer
.3a28c5	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a28c7	f0 2d		beq $3a28f6	            BEQ is_float
.3a28c9	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a28cb	f0 1f		beq $3a28ec	            BEQ is_string
.3a28cd					type_error
.3a28cd	08		php		            PHP
.3a28ce	c2 20		rep #$20	            REP #$20
.3a28d0	48		pha		            PHA
.3a28d1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a28d4	5b		tcd		            TCD
.3a28d5	68		pla		            PLA
.3a28d6	28		plp		            PLP
.3a28d7	e2 20		sep #$20	            SEP #$20
.3a28d9	a9 04		lda #$04	            LDA #ERR_TYPE
.3a28db	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a28df	c2 20		rep #$20	            REP #$20
.3a28e1	29 ff 00	and #$00ff	            AND #$00FF
.3a28e4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a28e7	e2 20		sep #$20	            SEP #$20
.3a28e9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a28ec					is_string
.3a28ec	20 3f 17	jsr $3a173f	            JSR OP_STR_GT
.3a28ef	80 08		bra $3a28f9	            BRA done
.3a28f1					is_integer
.3a28f1	20 5f 54	jsr $3a545f	            JSR OP_INT_GT
.3a28f4	80 03		bra $3a28f9	            BRA done
.3a28f6					is_float
.3a28f6	20 c8 5b	jsr $3a5bc8	            JSR OP_FP_GT
.3a28f9	28		plp		done        PLP
.3a28fa	60		rts		            RTS
.3a28fb					OP_EQ
.3a28fb	08		php		            PHP
.3a28fc	e2 20		sep #$20	            SEP #$20
.3a28fe	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a2901	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2903	f0 2c		beq $3a2931	            BEQ is_integer
.3a2905	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2907	f0 2d		beq $3a2936	            BEQ is_float
.3a2909	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a290b	f0 1f		beq $3a292c	            BEQ is_string
.3a290d					type_error
.3a290d	08		php		            PHP
.3a290e	c2 20		rep #$20	            REP #$20
.3a2910	48		pha		            PHA
.3a2911	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2914	5b		tcd		            TCD
.3a2915	68		pla		            PLA
.3a2916	28		plp		            PLP
.3a2917	e2 20		sep #$20	            SEP #$20
.3a2919	a9 04		lda #$04	            LDA #ERR_TYPE
.3a291b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a291f	c2 20		rep #$20	            REP #$20
.3a2921	29 ff 00	and #$00ff	            AND #$00FF
.3a2924	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2927	e2 20		sep #$20	            SEP #$20
.3a2929	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a292c					is_string
.3a292c	20 56 17	jsr $3a1756	            JSR OP_STR_EQ
.3a292f	80 08		bra $3a2939	            BRA done
.3a2931					is_integer
.3a2931	20 8c 54	jsr $3a548c	            JSR OP_INT_EQ
.3a2934	80 03		bra $3a2939	            BRA done
.3a2936					is_float
.3a2936	20 dd 5b	jsr $3a5bdd	            JSR OP_FP_EQ
.3a2939	28		plp		done        PLP
.3a293a	60		rts		            RTS
.3a293b					OP_NE
.3a293b	08		php		            PHP
.3a293c	e2 20		sep #$20	            SEP #$20
.3a293e	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a2941	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2943	f0 2c		beq $3a2971	            BEQ is_integer
.3a2945	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2947	f0 2d		beq $3a2976	            BEQ is_float
.3a2949	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a294b	f0 1f		beq $3a296c	            BEQ is_string
.3a294d					type_error
.3a294d	08		php		            PHP
.3a294e	c2 20		rep #$20	            REP #$20
.3a2950	48		pha		            PHA
.3a2951	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2954	5b		tcd		            TCD
.3a2955	68		pla		            PLA
.3a2956	28		plp		            PLP
.3a2957	e2 20		sep #$20	            SEP #$20
.3a2959	a9 04		lda #$04	            LDA #ERR_TYPE
.3a295b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a295f	c2 20		rep #$20	            REP #$20
.3a2961	29 ff 00	and #$00ff	            AND #$00FF
.3a2964	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2967	e2 20		sep #$20	            SEP #$20
.3a2969	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a296c					is_string
.3a296c	20 6d 17	jsr $3a176d	            JSR OP_STR_NE
.3a296f	80 08		bra $3a2979	            BRA done
.3a2971					is_integer
.3a2971	20 aa 54	jsr $3a54aa	            JSR OP_INT_NE
.3a2974	80 03		bra $3a2979	            BRA done
.3a2976					is_float
.3a2976	20 1c 5c	jsr $3a5c1c	            JSR OP_FP_NE
.3a2979	28		plp		done        PLP
.3a297a	60		rts		            RTS
.3a297b					OP_GTE
.3a297b	08		php		            PHP
.3a297c	e2 20		sep #$20	            SEP #$20
.3a297e	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a2981	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2983	f0 2c		beq $3a29b1	            BEQ is_integer
.3a2985	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2987	f0 2d		beq $3a29b6	            BEQ is_float
.3a2989	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a298b	f0 1f		beq $3a29ac	            BEQ is_string
.3a298d					type_error
.3a298d	08		php		            PHP
.3a298e	c2 20		rep #$20	            REP #$20
.3a2990	48		pha		            PHA
.3a2991	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2994	5b		tcd		            TCD
.3a2995	68		pla		            PLA
.3a2996	28		plp		            PLP
.3a2997	e2 20		sep #$20	            SEP #$20
.3a2999	a9 04		lda #$04	            LDA #ERR_TYPE
.3a299b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a299f	c2 20		rep #$20	            REP #$20
.3a29a1	29 ff 00	and #$00ff	            AND #$00FF
.3a29a4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a29a7	e2 20		sep #$20	            SEP #$20
.3a29a9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a29ac					is_string
.3a29ac	20 84 17	jsr $3a1784	            JSR OP_STR_GTE
.3a29af	80 08		bra $3a29b9	            BRA done
.3a29b1					is_integer
.3a29b1	20 c8 54	jsr $3a54c8	            JSR OP_INT_GTE
.3a29b4	80 03		bra $3a29b9	            BRA done
.3a29b6					is_float
.3a29b6	20 07 5c	jsr $3a5c07	            JSR OP_FP_GTE
.3a29b9	28		plp		done        PLP
.3a29ba	60		rts		            RTS
.3a29bb					OP_LTE
.3a29bb	08		php		            PHP
.3a29bc	e2 20		sep #$20	            SEP #$20
.3a29be	20 f7 07	jsr $3a07f7	            JSR ASS_ARGS_NUMSTR
.3a29c1	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a29c3	f0 2c		beq $3a29f1	            BEQ is_integer
.3a29c5	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a29c7	f0 2d		beq $3a29f6	            BEQ is_float
.3a29c9	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a29cb	f0 1f		beq $3a29ec	            BEQ is_string
.3a29cd					type_error
.3a29cd	08		php		            PHP
.3a29ce	c2 20		rep #$20	            REP #$20
.3a29d0	48		pha		            PHA
.3a29d1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a29d4	5b		tcd		            TCD
.3a29d5	68		pla		            PLA
.3a29d6	28		plp		            PLP
.3a29d7	e2 20		sep #$20	            SEP #$20
.3a29d9	a9 04		lda #$04	            LDA #ERR_TYPE
.3a29db	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a29df	c2 20		rep #$20	            REP #$20
.3a29e1	29 ff 00	and #$00ff	            AND #$00FF
.3a29e4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a29e7	e2 20		sep #$20	            SEP #$20
.3a29e9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a29ec					is_string
.3a29ec	20 9b 17	jsr $3a179b	            JSR OP_STR_LTE
.3a29ef	80 08		bra $3a29f9	            BRA done
.3a29f1					is_integer
.3a29f1	20 f5 54	jsr $3a54f5	            JSR OP_INT_LTE
.3a29f4	80 03		bra $3a29f9	            BRA done
.3a29f6					is_float
.3a29f6	20 f2 5b	jsr $3a5bf2	            JSR OP_FP_LTE
.3a29f9	28		plp		done        PLP
.3a29fa	60		rts		            RTS
.3a29fb					OP_NEGATIVE
.3a29fb	08		php		                PHP
.3a29fc	e2 20		sep #$20	            SEP #$20
.3a29fe	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.3a2a00	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a2a02	f0 2d		beq $3a2a31	                BEQ int_negate              ; If integer: negate the integer
.3a2a04	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a2a06	f0 1f		beq $3a2a27	                BEQ float_negate            ; If floating point: negate the floating point
.3a2a08					type_error
.3a2a08	08		php		            PHP
.3a2a09	c2 20		rep #$20	            REP #$20
.3a2a0b	48		pha		            PHA
.3a2a0c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a0f	5b		tcd		            TCD
.3a2a10	68		pla		            PLA
.3a2a11	28		plp		            PLP
.3a2a12	e2 20		sep #$20	            SEP #$20
.3a2a14	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a16	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a1a	c2 20		rep #$20	            REP #$20
.3a2a1c	29 ff 00	and #$00ff	            AND #$00FF
.3a2a1f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2a22	e2 20		sep #$20	            SEP #$20
.3a2a24	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a27					float_negate
.3a2a27	e2 20		sep #$20	            SEP #$20
.3a2a29	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.3a2a2b	49 80		eor #$80	                EOR #$80
.3a2a2d	85 26		sta $0826	                STA ARGUMENT1+3
.3a2a2f	80 16		bra $3a2a47	                BRA done
.3a2a31					int_negate
.3a2a31	c2 20		rep #$20	            REP #$20
.3a2a33	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.3a2a35	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2a38	85 23		sta $0823	                STA ARGUMENT1
.3a2a3a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2a3c	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2a3f	85 25		sta $0825	                STA ARGUMENT1+2
.3a2a41	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.3a2a43	d0 02		bne $3a2a47	                BNE done
.3a2a45	e6 25		inc $0825	                INC ARGUMENT1+2
.3a2a47					done
.3a2a47	28		plp		                PLP
.3a2a48	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>3af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>3af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>3af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>3af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>3af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>3af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>3af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>3af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>3af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.3a2a49					S_SETTIME
.3a2a49	08		php		                PHP
.3a2a4a	e2 20		sep #$20	            SEP #$20
.3a2a4c	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2a4f	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2a52	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2a55	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2a57	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2a58	0a		asl a		                ASL A
.3a2a59	0a		asl a		                ASL A
.3a2a5a	0a		asl a		                ASL A
.3a2a5b	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2a5d	48		pha		                PHA
.3a2a5e	a9 2c		lda #$2c	                LDA #','
.3a2a60	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2a63	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2a66	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2a69	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2a6c	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2a6e	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2a6f	0a		asl a		                ASL A
.3a2a70	0a		asl a		                ASL A
.3a2a71	0a		asl a		                ASL A
.3a2a72	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2a74	48		pha		                PHA
.3a2a75	a9 2c		lda #$2c	                LDA #','
.3a2a77	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2a7a	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2a7d	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2a80	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2a83	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2a85	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2a86	0a		asl a		                ASL A
.3a2a87	0a		asl a		                ASL A
.3a2a88	0a		asl a		                ASL A
.3a2a89	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2a8b	48		pha		                PHA
.3a2a8c	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2a90	09 0c		ora #$0c	                ORA #%00001100
.3a2a92	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2a96	68		pla		                PLA                     ; And seconds to the RTC
.3a2a97	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.3a2a9b	68		pla		                PLA                     ; Minutes...
.3a2a9c	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.3a2aa0	68		pla		                PLA                     ; Save the hour...
.3a2aa1	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.3a2aa5	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2aa9	29 f7		and #$f7	                AND #%11110111
.3a2aab	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2aaf	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a2ab2	28		plp		                PLP
.3a2ab3	60		rts		            RTS
.3a2ab4					S_SETDATE
.3a2ab4	08		php		                PHP
.3a2ab5	e2 20		sep #$20	            SEP #$20
.3a2ab7	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2aba	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2abd	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2ac0	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2ac2	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2ac3	0a		asl a		                ASL A
.3a2ac4	0a		asl a		                ASL A
.3a2ac5	0a		asl a		                ASL A
.3a2ac6	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2ac8	48		pha		                PHA
.3a2ac9	a9 2c		lda #$2c	                LDA #','
.3a2acb	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2ace	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2ad1	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2ad4	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2ad7	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2ad9	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2ada	0a		asl a		                ASL A
.3a2adb	0a		asl a		                ASL A
.3a2adc	0a		asl a		                ASL A
.3a2add	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2adf	48		pha		                PHA
.3a2ae0	a9 2c		lda #$2c	                LDA #','
.3a2ae2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2ae5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2ae8	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a2aeb	20 38 05	jsr $3a0538	            JSR DIVINT100
.3a2aee	c2 20		rep #$20	            REP #$20
.3a2af0	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.3a2af2	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.3a2af4	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.3a2af6	85 23		sta $0823	                STA ARGUMENT1
.3a2af8	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2afb	e2 20		sep #$20	            SEP #$20
.3a2afd	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2aff	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b00	0a		asl a		                ASL A
.3a2b01	0a		asl a		                ASL A
.3a2b02	0a		asl a		                ASL A
.3a2b03	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b05	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.3a2b06	c2 20		rep #$20	            REP #$20
.3a2b08	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.3a2b0a	85 23		sta $0823	                STA ARGUMENT1
.3a2b0c	20 02 05	jsr $3a0502	            JSR DIVINT10
.3a2b0f	e2 20		sep #$20	            SEP #$20
.3a2b11	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b13	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b14	0a		asl a		                ASL A
.3a2b15	0a		asl a		                ASL A
.3a2b16	0a		asl a		                ASL A
.3a2b17	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b19	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.3a2b1a	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2b1e	09 0c		ora #$0c	                ORA #%00001100
.3a2b20	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b24	68		pla		                PLA                     ; Set the century
.3a2b25	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.3a2b29	68		pla		                PLA                     ; And year to the RTC
.3a2b2a	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.3a2b2e	68		pla		                PLA                     ; Month...
.3a2b2f	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.3a2b33	68		pla		                PLA                     ; Save the day...
.3a2b34	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.3a2b38	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2b3c	29 f7		and #$f7	                AND #%11110111
.3a2b3e	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b42	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a2b45	28		plp		                PLP
.3a2b46	60		rts		            RTS
.3a2b47					S_TEXTCOLOR
.3a2b47	08		php		                PHP
.3a2b48					locals
>0001					L_FOREGROUND    .byte ?
.3a2b48	e2 20		sep #$20	            SEP #$20
.3a2b4a	48		pha		            PHA
.3a2b4b	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2b4e	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2b51	e2 20		sep #$20	            SEP #$20
.3a2b53	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.3a2b55	29 0f		and #$0f	                AND #$0F
.3a2b57	0a		asl a		                ASL A
.3a2b58	0a		asl a		                ASL A
.3a2b59	0a		asl a		                ASL A
.3a2b5a	0a		asl a		                ASL A
.3a2b5b	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.3a2b5d	a9 2c		lda #$2c	                LDA #','
.3a2b5f	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2b62	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2b65	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2b68	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.3a2b6a	29 0f		and #$0f	                AND #$0F
.3a2b6c	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.3a2b6e	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.3a2b72	e2 20		sep #$20	            SEP #$20
.3a2b74	68		pla		            PLA
.3a2b75	28		plp		                PLP
.3a2b76	60		rts		            RTS
.3a2b77					S_SETBGCOLOR
.3a2b77	08		php		                PHP
.3a2b78					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2b78	c2 20		rep #$20	            REP #$20
.3a2b7a	f4 00 00	pea #$0000	            PEA #0
.3a2b7d	e2 20		sep #$20	            SEP #$20
.3a2b7f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2b82	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2b85	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2b87	83 01		sta $01,s	                STA L_RED
.3a2b89	a9 2c		lda #$2c	                LDA #','
.3a2b8b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2b8e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2b91	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2b94	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2b96	83 02		sta $02,s	                STA L_GREEN
.3a2b98	a9 2c		lda #$2c	                LDA #','
.3a2b9a	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2b9d	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2ba0	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2ba3	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.3a2ba5	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.3a2ba9	a3 02		lda $02,s	                LDA L_GREEN
.3a2bab	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.3a2baf	a3 01		lda $01,s	                LDA L_RED
.3a2bb1	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.3a2bb5	c2 20		rep #$20	            REP #$20
.3a2bb7	68		pla		            PLA
.3a2bb8	28		plp		                PLP
.3a2bb9	60		rts		            RTS
.3a2bba					S_SETBORDER
.3a2bba	08		php		                PHP
.3a2bbb					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2bbb	c2 20		rep #$20	            REP #$20
.3a2bbd	f4 00 00	pea #$0000	            PEA #0
.3a2bc0	e2 20		sep #$20	            SEP #$20
.3a2bc2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2bc5	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a2bc8	a5 23		lda $0823	                LDA ARGUMENT1
.3a2bca	f0 16		beq $3a2be2	                BEQ hide_border
.3a2bcc	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.3a2bce	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2bd2	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.3a2bd4	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.3a2bd8	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.3a2bdc	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2be0	80 0a		bra $3a2bec	                BRA get_color
.3a2be2	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.3a2be4	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2be8	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2bec	a9 2c		lda #$2c	get_color       LDA #','
.3a2bee	85 37		sta $0837	                STA TARGETTOK
.3a2bf0	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a2bf3	90 39		bcc $3a2c2e	                BCC done                    ; No: we're done
.3a2bf5	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a2bf8	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2bfb	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2bfe	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2c00	83 01		sta $01,s	                STA L_RED
.3a2c02	a9 2c		lda #$2c	                LDA #','
.3a2c04	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c07	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c0a	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c0d	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2c0f	83 02		sta $02,s	                STA L_GREEN
.3a2c11	a9 2c		lda #$2c	                LDA #','
.3a2c13	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c16	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c19	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c1c	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c1e	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.3a2c22	a3 02		lda $02,s	                LDA L_GREEN
.3a2c24	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.3a2c28	a3 01		lda $01,s	                LDA L_RED
.3a2c2a	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.3a2c2e					done
.3a2c2e	c2 20		rep #$20	            REP #$20
.3a2c30	68		pla		            PLA
.3a2c31	28		plp		                PLP
.3a2c32	60		rts		            RTS
.3a2c33					S_SETCOLOR
.3a2c33	08		php		                PHP
.3a2c34					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.3a2c34	c2 20		rep #$20	            REP #$20
.3a2c36	3b		tsc		            TSC
.3a2c37	38		sec		            SEC
.3a2c38	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.3a2c3b	1b		tcs		            TCS
.3a2c3c	e2 20		sep #$20	            SEP #$20
.3a2c3e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c41	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c44	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c46	c9 0a		cmp #$0a	                CMP #10             ; And in range
.3a2c48	90 1f		bcc $3a2c69	                BLT save_lut
.3a2c4a					bad_argument
.3a2c4a	08		php		            PHP
.3a2c4b	c2 20		rep #$20	            REP #$20
.3a2c4d	48		pha		            PHA
.3a2c4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2c51	5b		tcd		            TCD
.3a2c52	68		pla		            PLA
.3a2c53	28		plp		            PLP
.3a2c54	e2 20		sep #$20	            SEP #$20
.3a2c56	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2c58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2c5c	c2 20		rep #$20	            REP #$20
.3a2c5e	29 ff 00	and #$00ff	            AND #$00FF
.3a2c61	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2c64	e2 20		sep #$20	            SEP #$20
.3a2c66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2c69	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.3a2c6b	a9 2c		lda #$2c	                LDA #','
.3a2c6d	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c70	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c73	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c76	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c78	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.3a2c7a	a9 2c		lda #$2c	                LDA #','
.3a2c7c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c7f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c82	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c85	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c87	83 03		sta $03,s	                STA L_RED           ; Save as RED
.3a2c89	a9 2c		lda #$2c	                LDA #','
.3a2c8b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c8e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2c91	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2c94	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c96	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.3a2c98	a9 2c		lda #$2c	                LDA #','
.3a2c9a	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2c9d	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2ca0	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2ca3	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ca5	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.3a2ca7	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.3a2ca9	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.3a2cab	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.3a2cad	0a		asl a		                ASL A
.3a2cae	c2 20		rep #$20	            REP #$20
.3a2cb0	29 ff 00	and #$00ff	                AND #$00FF
.3a2cb3	aa		tax		                TAX                 ; Put it in X
.3a2cb4	bf eb 2c 3a	lda $3a2ceb,x	                LDA @llut_address,X ; Get the address of the LUT
.3a2cb8	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.3a2cba	e2 20		sep #$20	            SEP #$20
.3a2cbc	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.3a2cbe	c2 20		rep #$20	            REP #$20
.3a2cc0	29 ff 00	and #$00ff	                AND #$00FF
.3a2cc3	0a		asl a		                ASL A               ; Since each color has four bytes of data
.3a2cc4	0a		asl a		                ASL A
.3a2cc5	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.3a2cc6	65 9e		adc $089e	                ADC MTEMPPTR
.3a2cc8	85 9e		sta $089e	                STA MTEMPPTR
.3a2cca	e2 20		sep #$20	            SEP #$20
.3a2ccc	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.3a2ccf	a3 03		lda $03,s	                LDA L_RED
.3a2cd1	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.3a2cd3	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.3a2cd6	a3 04		lda $04,s	                LDA L_GREEN
.3a2cd8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.3a2cda	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.3a2cdd	a3 05		lda $05,s	                LDA L_BLUE
.3a2cdf	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.3a2ce1					done
.3a2ce1	c2 20		rep #$20	            REP #$20
.3a2ce3	3b		tsc		            TSC
.3a2ce4	18		clc		            CLC
.3a2ce5	69 05 00	adc #$0005	            ADC #SIZE(locals)
.3a2ce8	1b		tcs		            TCS
.3a2ce9	28		plp		                PLP
.3a2cea	60		rts		            RTS
>3a2ceb	00 20				lut_address     .word <>GRPH_LUT0_PTR
>3a2ced	00 24				                .word <>GRPH_LUT1_PTR
>3a2cef	00 28				                .word <>GRPH_LUT2_PTR
>3a2cf1	00 2c				                .word <>GRPH_LUT3_PTR
>3a2cf3	00 30				                .word <>GRPH_LUT4_PTR
>3a2cf5	00 34				                .word <>GRPH_LUT5_PTR
>3a2cf7	00 38				                .word <>GRPH_LUT6_PTR
>3a2cf9	00 3c				                .word <>GRPH_LUT7_PTR
>3a2cfb	40 1f				                .word <>FG_CHAR_LUT_PTR
>3a2cfd	80 1f				                .word <>BG_CHAR_LUT_PTR
.3a2cff					S_GRAPHICS
.3a2cff	da		phx		                PHX
.3a2d00	5a		phy		                PHY
.3a2d01	08		php		                PHP
.3a2d02	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2d05	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a2d08	c2 20		rep #$20	            REP #$20
.3a2d0a	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.3a2d0c	89 00 01	bit #$0100	                BIT #$0100
.3a2d0f	d0 17		bne $3a2d28	                BNE set_mode                ; Yes: go ahead and set it
.3a2d11	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.3a2d15	89 00 01	bit #$0100	                BIT #$0100
.3a2d18	f0 0e		beq $3a2d28	                BEQ set_mode                ; No: just go ahead and set the mode
.3a2d1a	e2 20		sep #$20	            SEP #$20
.3a2d1c	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.3a2d1e	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2d22	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.3a2d24	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2d28					set_mode
.3a2d28	c2 20		rep #$20	            REP #$20
.3a2d2a	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d2c	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.3a2d30	e2 20		sep #$20	            SEP #$20
.3a2d32	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.3a2d34	c2 20		rep #$20	            REP #$20
.3a2d36	29 03 00	and #$0003	                AND #$0003
.3a2d39	0a		asl a		                ASL A                       ; Multiply by two to get the index
.3a2d3a	aa		tax		                TAX                         ; X is index into the size tables
.3a2d3b	c2 20		rep #$20	            REP #$20
.3a2d3d	bf 86 2d 3a	lda $3a2d86,x	                LDA gr_columns,X            ; Set the columns
.3a2d41	8f 10 f0 3a	sta $3af010	                STA @lGR_MAX_COLS
.3a2d45	bf 8e 2d 3a	lda $3a2d8e,x	                LDA gr_rows,X               ; Set the rows
.3a2d49	8f 12 f0 3a	sta $3af012	                STA @lGR_MAX_ROWS
.3a2d4d	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.3a2d51	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2d55	af 12 f0 3a	lda $3af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.3a2d59	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.3a2d5d	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.3a2d61	8f 14 f0 3a	sta $3af014	                STA @lGR_TOTAL_PIXELS
.3a2d65	e2 20		sep #$20	            SEP #$20
.3a2d67	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2d6b	8f 16 f0 3a	sta $3af016	                STA @lGR_TOTAL_PIXELS+2
.3a2d6f	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2d73					reset_cursor
.3a2d73	c2 20		rep #$20	            REP #$20
.3a2d75	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.3a2d79	aa		tax		                TAX
.3a2d7a	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.3a2d7e	a8		tay		                TAY
.3a2d7f	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a2d82	28		plp		                PLP
.3a2d83	7a		ply		                PLY
.3a2d84	fa		plx		                PLX
.3a2d85	60		rts		            RTS
>3a2d86	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>3a2d8e	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>3a2d96	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>3a2d9e	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>3a2da6	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>3a2dae	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.3a2db6					BITMAP_SRAM
.3a2db6	da		phx		                PHX
.3a2db7	08		php		                PHP
.3a2db8	c2 30		rep #$30	            REP #$30
.3a2dba	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2dbd	b0 1c		bcs $3a2ddb	                BGE range_err           ; Make sure it's within range
.3a2dbf	0a		asl a		                ASL A
.3a2dc0	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2dc1	aa		tax		                TAX
.3a2dc2	bf 00 f0 3a	lda $3af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.3a2dc6	85 9e		sta $089e	                STA MTEMPPTR
.3a2dc8	bf 02 f0 3a	lda $3af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.3a2dcc	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2dce	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.3a2dd1	b0 08		bcs $3a2ddb	                BGE range_err
.3a2dd3	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.3a2dd6	90 03		bcc $3a2ddb	                BLT range_err
.3a2dd8	28		plp		                PLP
.3a2dd9	fa		plx		                PLX
.3a2dda	60		rts		            RTS
.3a2ddb					range_err
.3a2ddb	08		php		            PHP
.3a2ddc	c2 20		rep #$20	            REP #$20
.3a2dde	48		pha		            PHA
.3a2ddf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2de2	5b		tcd		            TCD
.3a2de3	68		pla		            PLA
.3a2de4	28		plp		            PLP
.3a2de5	e2 20		sep #$20	            SEP #$20
.3a2de7	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2de9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2ded	c2 20		rep #$20	            REP #$20
.3a2def	29 ff 00	and #$00ff	            AND #$00FF
.3a2df2	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2df5	e2 20		sep #$20	            SEP #$20
.3a2df7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2dfa					BITMAP_VRAM
.3a2dfa	da		phx		                PHX
.3a2dfb	08		php		                PHP
.3a2dfc	c2 30		rep #$30	            REP #$30
.3a2dfe	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2e01	b0 17		bcs $3a2e1a	                BGE range_err           ; Make sure it's within range
.3a2e03	0a		asl a		                ASL A
.3a2e04	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2e05	aa		tax		                TAX
.3a2e06	bf 08 f0 3a	lda $3af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.3a2e0a	85 9e		sta $089e	                STA MTEMPPTR
.3a2e0c	bf 0a f0 3a	lda $3af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.3a2e10	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2e12	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.3a2e15	b0 03		bcs $3a2e1a	                BGE range_err           ; If not, throw a range error
.3a2e17	28		plp		                PLP
.3a2e18	fa		plx		                PLX
.3a2e19	60		rts		            RTS
.3a2e1a					range_err
.3a2e1a	08		php		            PHP
.3a2e1b	c2 20		rep #$20	            REP #$20
.3a2e1d	48		pha		            PHA
.3a2e1e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2e21	5b		tcd		            TCD
.3a2e22	68		pla		            PLA
.3a2e23	28		plp		            PLP
.3a2e24	e2 20		sep #$20	            SEP #$20
.3a2e26	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2e28	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2e2c	c2 20		rep #$20	            REP #$20
.3a2e2e	29 ff 00	and #$00ff	            AND #$00FF
.3a2e31	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2e34	e2 20		sep #$20	            SEP #$20
.3a2e36	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2e39					S_BITMAP
.3a2e39	08		php		                PHP
.3a2e3a					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.3a2e3a	c2 30		rep #$30	            REP #$30
.3a2e3c	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.3a2e3d	38		sec		                SEC
.3a2e3e	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.3a2e41	1b		tcs		                TCS
.3a2e42	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2e45	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2e48	c2 20		rep #$20	            REP #$20
.3a2e4a	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.3a2e4c	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2e4f	b0 59		bcs $3a2eaa	                BGE range_err               ; If not, throw an error
.3a2e51	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.3a2e53	e2 20		sep #$20	            SEP #$20
.3a2e55	a9 2c		lda #$2c	                LDA #','
.3a2e57	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2e5a	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2e5d	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2e60	a5 23		lda $0823	                LDA ARGUMENT1
.3a2e62	83 03		sta $03,s	                STA L_VISIBLE
.3a2e64	a9 2c		lda #$2c	                LDA #','
.3a2e66	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a2e69	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2e6c	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2e6f	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.3a2e71	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.3a2e72	0a		asl a		                ASL A
.3a2e73	0a		asl a		                ASL A
.3a2e74	aa		tax		                TAX                         ; And save that offset to X
.3a2e75	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.3a2e77	d0 05		bne $3a2e7e	                BNE is_visible              ; If <> 0, it's visible
.3a2e79	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.3a2e7b	0a		asl a		                ASL A                       ; Shift it into position for the register
.3a2e7c	80 04		bra $3a2e82	                BRA wr_bm_reg               ; And go to write it
.3a2e7e	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.3a2e80	38		sec		                SEC
.3a2e81	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.3a2e82	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.3a2e86	c2 20		rep #$20	            REP #$20
.3a2e88	a9 2c 00	lda #$002c	                LDA #','
.3a2e8b	85 37		sta $0837	                STA TARGETTOK
.3a2e8d	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a2e90	b0 37		bcs $3a2ec9	                BCS get_address             ; Yes: parse the address
.3a2e92	c2 20		rep #$20	            REP #$20
.3a2e94	08		php		            PHP
.3a2e95	c2 20		rep #$20	            REP #$20
.3a2e97	a9 00 00	lda #$0000	            LDA #<>VRAM
.3a2e9a	85 23		sta $0823	            STA ARGUMENT1
.3a2e9c	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.3a2e9f	85 25		sta $0825	            STA ARGUMENT1+2
.3a2ea1	e2 20		sep #$20	            SEP #$20
.3a2ea3	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a2ea5	85 27		sta $0827	            STA ARGUMENT1+4
.3a2ea7	28		plp		            PLP
.3a2ea8	80 27		bra $3a2ed1	                BRA set_address
.3a2eaa					range_err
.3a2eaa	08		php		            PHP
.3a2eab	c2 20		rep #$20	            REP #$20
.3a2ead	48		pha		            PHA
.3a2eae	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2eb1	5b		tcd		            TCD
.3a2eb2	68		pla		            PLA
.3a2eb3	28		plp		            PLP
.3a2eb4	e2 20		sep #$20	            SEP #$20
.3a2eb6	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2eb8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2ebc	c2 20		rep #$20	            REP #$20
.3a2ebe	29 ff 00	and #$00ff	            AND #$00FF
.3a2ec1	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2ec4	e2 20		sep #$20	            SEP #$20
.3a2ec6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ec9					get_address
.3a2ec9	c2 20		rep #$20	            REP #$20
.3a2ecb	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a2ece	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2ed1					set_address
.3a2ed1	c2 20		rep #$20	            REP #$20
.3a2ed3	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2ed5	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.3a2ed6	0a		asl a		                ASL A
.3a2ed7	aa		tax		                TAX                         ; And put it in X
.3a2ed8	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.3a2eda	9f 00 f0 3a	sta $3af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.3a2ede	9f 08 f0 3a	sta $3af008,x	                STA @l GR_BM0_VRAM,X
.3a2ee2	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.3a2ee4	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2ee6	9f 02 f0 3a	sta $3af002,x	                STA @l GR_BM0_ADDR+2,X
.3a2eea	38		sec		                SEC
.3a2eeb	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.3a2eee	9f 0a f0 3a	sta $3af00a,x	                STA @l GR_BM0_VRAM+2,X
.3a2ef2	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.3a2ef4	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2ef6	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.3a2ef7	0a		asl a		                ASL A
.3a2ef8	0a		asl a		                ASL A
.3a2ef9	aa		tax		                TAX                         ; And put it in X
.3a2efa	e2 20		sep #$20	            SEP #$20
.3a2efc	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.3a2efe	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.3a2f02	a3 05		lda $05,s	                LDA L_ADDRESS+1
.3a2f04	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.3a2f08	a3 06		lda $06,s	                LDA L_ADDRESS+2
.3a2f0a	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.3a2f0e	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.3a2f10	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.3a2f14	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.3a2f18	c2 30		rep #$30	            REP #$30
.3a2f1a	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.3a2f1b	18		clc		                CLC
.3a2f1c	69 07 00	adc #$0007	                ADC #SIZE(locals)
.3a2f1f	1b		tcs		                TCS
.3a2f20	28		plp		                PLP
.3a2f21	60		rts		            RTS
.3a2f22					bad_address
.3a2f22	08		php		            PHP
.3a2f23	c2 20		rep #$20	            REP #$20
.3a2f25	48		pha		            PHA
.3a2f26	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2f29	5b		tcd		            TCD
.3a2f2a	68		pla		            PLA
.3a2f2b	28		plp		            PLP
.3a2f2c	e2 20		sep #$20	            SEP #$20
.3a2f2e	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2f30	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2f34	c2 20		rep #$20	            REP #$20
.3a2f36	29 ff 00	and #$00ff	            AND #$00FF
.3a2f39	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a2f3c	e2 20		sep #$20	            SEP #$20
.3a2f3e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2f41					S_CLRBITMAP
.3a2f41	08		php		                PHP
.3a2f42	c2 20		rep #$20	            REP #$20
.3a2f44	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a2f47	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a2f4a	a5 23		lda $0823	                LDA ARGUMENT1
.3a2f4c	20 fa 2d	jsr $3a2dfa	            JSR BITMAP_VRAM
.3a2f4f	c2 20		rep #$20	            REP #$20
.3a2f51	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.3a2f53	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.3a2f57	af 14 f0 3a	lda $3af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.3a2f5b	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.3a2f5f	e2 20		sep #$20	            SEP #$20
.3a2f61	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a2f63	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.3a2f67	af 16 f0 3a	lda $3af016	                LDA @lGR_TOTAL_PIXELS+2
.3a2f6b	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.3a2f6f	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.3a2f71	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.3a2f75	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.3a2f77	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2f7b	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a2f7f	30 fa		bmi $3a2f7b	                BMI wait
.3a2f81	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a2f83	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2f87	28		plp		done            PLP
.3a2f88	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.3a2f89					PLOT
.3a2f89	08		php		                PHP
.3a2f8a	c2 20		rep #$20	            REP #$20
.3a2f8c	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.3a2f8e	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2f92	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS
.3a2f96	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.3a2f9a	18		clc		                CLC                         ; Add the column
.3a2f9b	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.3a2f9f	65 59		adc $0859	                ADC X0
.3a2fa1	85 0c		sta $080c	                STA SCRATCH
.3a2fa3	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2fa7	69 00 00	adc #$0000	                ADC #0
.3a2faa	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.3a2fac	18		clc		                CLC                         ; Add the address of the first pixel
.3a2fad	a5 0c		lda $080c	                LDA SCRATCH
.3a2faf	65 9e		adc $089e	                ADC MTEMPPTR
.3a2fb1	85 0c		sta $080c	                STA SCRATCH
.3a2fb3	a5 0e		lda $080e	                LDA SCRATCH+2
.3a2fb5	65 a0		adc $08a0	                ADC MTEMPPTR+2
.3a2fb7	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.3a2fb9	e2 20		sep #$20	            SEP #$20
.3a2fbb	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.3a2fbd	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.3a2fbf	28		plp		                PLP
.3a2fc0	60		rts		            RTS
.3a2fc1					LINE
.3a2fc1	c2 20		rep #$20	            REP #$20
.3a2fc3	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.3a2fc6	85 dd		sta $08dd	                STA SX
.3a2fc8	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.3a2fc9	a5 61		lda $0861	                LDA X1
.3a2fcb	e5 59		sbc $0859	                SBC X0
.3a2fcd	85 69		sta $0869	                STA DX
.3a2fcf	10 0b		bpl $3a2fdc	                BPL abs_Y                   ; If DX < 0 {
.3a2fd1	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.3a2fd4	1a		inc a		                INC A
.3a2fd5	85 69		sta $0869	                STA DX
.3a2fd7	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.3a2fda	85 dd		sta $08dd	                STA SX                      ; }
.3a2fdc	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.3a2fdf	85 df		sta $08df	                STA SY
.3a2fe1	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.3a2fe2	a5 65		lda $0865	                LDA Y1
.3a2fe4	e5 5d		sbc $085d	                SBC Y0
.3a2fe6	85 6d		sta $086d	                STA DY
.3a2fe8	10 0b		bpl $3a2ff5	                BPL calc_ERR                ; If DY < 0 {
.3a2fea	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.3a2fed	1a		inc a		                INC A
.3a2fee	85 6d		sta $086d	                STA DY
.3a2ff0	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.3a2ff3	85 df		sta $08df	                STA SY                      ; }
.3a2ff5	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.3a2ff7	c5 69		cmp $0869	                CMP DX
.3a2ff9	b0 04		bcs $3a2fff	                BGE else
.3a2ffb	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.3a2ffd	80 06		bra $3a3005	                BRA shiftERR
.3a2fff	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.3a3001	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a3004	1a		inc a		                INC A
.3a3005	48		pha		shiftERR        PHA
.3a3006	0a		asl a		                ASL A
.3a3007	68		pla		                PLA
.3a3008	6a		ror a		                ROR A                       ; ERR := ERR / 2
.3a3009	85 71		sta $0871	                STA ERR
.3a300b					loop
.3a300b	20 89 2f	jsr $3a2f89	            JSR PLOT
.3a300e	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.3a3010	c5 61		cmp $0861	                CMP X1
.3a3012	d0 06		bne $3a301a	                BNE calc_ERR2
.3a3014	a5 5d		lda $085d	                LDA Y0
.3a3016	c5 65		cmp $0865	                CMP Y1
.3a3018	f0 36		beq $3a3050	                BEQ done
.3a301a	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.3a301c	85 75		sta $0875	                STA ERR2
.3a301e	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.3a3020	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a3023	1a		inc a		                INC A
.3a3024	c5 75		cmp $0875	                CMP ERR2
.3a3026	10 10		bpl $3a3038	                BPL check_DY
.3a3028	f0 0e		beq $3a3038	                BEQ check_DY
.3a302a	38		sec		                SEC                         ; ERR -= DY
.3a302b	a5 71		lda $0871	                LDA ERR
.3a302d	e5 6d		sbc $086d	                SBC DY
.3a302f	85 71		sta $0871	                STA ERR
.3a3031	18		clc		                CLC                         ; X0 += SX
.3a3032	a5 59		lda $0859	                LDA X0
.3a3034	65 dd		adc $08dd	                ADC SX
.3a3036	85 59		sta $0859	                STA X0                      ; }
.3a3038	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.3a303a	c5 6d		cmp $086d	                CMP DY
.3a303c	10 cd		bpl $3a300b	                BPL loop
.3a303e	f0 cb		beq $3a300b	                BEQ loop
.3a3040	18		clc		                CLC                         ; ERR += DX
.3a3041	a5 71		lda $0871	                LDA ERR
.3a3043	65 69		adc $0869	                ADC DX
.3a3045	85 71		sta $0871	                STA ERR
.3a3047	18		clc		                CLC                         ; Y0 += SY
.3a3048	a5 5d		lda $085d	                LDA Y0
.3a304a	65 df		adc $08df	                ADC SY
.3a304c	85 5d		sta $085d	                STA Y0                      ; }
.3a304e	80 bb		bra $3a300b	                BRA loop                    ; }
.3a3050					done
.3a3050	60		rts		            RTS
.3a3051					S_PLOT
.3a3051	08		php		                PHP
.3a3052					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.3a3052	c2 20		rep #$20	            REP #$20
.3a3054	3b		tsc		            TSC
.3a3055	38		sec		            SEC
.3a3056	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a3059	1b		tcs		            TCS
.3a305a	08		php		            PHP
.3a305b	c2 20		rep #$20	            REP #$20
.3a305d	48		pha		            PHA
.3a305e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3061	5b		tcd		            TCD
.3a3062	68		pla		            PLA
.3a3063	28		plp		            PLP
.3a3064	08		php		            PHP
.3a3065	e2 20		sep #$20	            SEP #$20
.3a3067	48		pha		            PHA
.3a3068	a9 00		lda #$00	            LDA #0
.3a306a	48		pha		            PHA
.3a306b	ab		plb		            PLB
.3a306c	68		pla		            PLA
.3a306d	28		plp		            PLP
.3a306e	c2 30		rep #$30	            REP #$30
.3a3070	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3073	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3076	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a3078	a9 2c 00	lda #$002c	                LDA #','
.3a307b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a307e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3081	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3084	a5 23		lda $0823	                LDA ARGUMENT1
.3a3086	83 03		sta $03,s	                STA L_X                     ; Save it to X
.3a3088	a9 2c 00	lda #$002c	                LDA #','
.3a308b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a308e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3091	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3094	a5 23		lda $0823	                LDA ARGUMENT1
.3a3096	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.3a3098	a9 2c 00	lda #$002c	                LDA #','
.3a309b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a309e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a30a1	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a30a4	a5 23		lda $0823	                LDA ARGUMENT1
.3a30a6	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.3a30a8	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.3a30aa	85 59		sta $0859	                STA X0
.3a30ac	a3 05		lda $05,s	                LDA L_Y
.3a30ae	85 5d		sta $085d	                STA Y0
.3a30b0	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a30b2	20 b6 2d	jsr $3a2db6	            JSR BITMAP_SRAM
.3a30b5	20 89 2f	jsr $3a2f89	            JSR PLOT
.3a30b8	c2 20		rep #$20	            REP #$20
.3a30ba	3b		tsc		            TSC
.3a30bb	18		clc		            CLC
.3a30bc	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a30bf	1b		tcs		            TCS
.3a30c0	28		plp		                PLP
.3a30c1	60		rts		            RTS
.3a30c2					S_LINE
.3a30c2	08		php		                PHP
.3a30c3					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.3a30c3	c2 20		rep #$20	            REP #$20
.3a30c5	3b		tsc		            TSC
.3a30c6	38		sec		            SEC
.3a30c7	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a30ca	1b		tcs		            TCS
.3a30cb	08		php		            PHP
.3a30cc	c2 20		rep #$20	            REP #$20
.3a30ce	48		pha		            PHA
.3a30cf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a30d2	5b		tcd		            TCD
.3a30d3	68		pla		            PLA
.3a30d4	28		plp		            PLP
.3a30d5	08		php		            PHP
.3a30d6	e2 20		sep #$20	            SEP #$20
.3a30d8	48		pha		            PHA
.3a30d9	a9 00		lda #$00	            LDA #0
.3a30db	48		pha		            PHA
.3a30dc	ab		plb		            PLB
.3a30dd	68		pla		            PLA
.3a30de	28		plp		            PLP
.3a30df	c2 30		rep #$30	            REP #$30
.3a30e1	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a30e4	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a30e7	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a30e9	a9 2c 00	lda #$002c	                LDA #','
.3a30ec	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a30ef	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a30f2	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a30f5	a5 23		lda $0823	                LDA ARGUMENT1
.3a30f7	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a30f9	a9 2c 00	lda #$002c	                LDA #','
.3a30fc	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a30ff	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3102	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3105	a5 23		lda $0823	                LDA ARGUMENT1
.3a3107	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a3109	a9 2c 00	lda #$002c	                LDA #','
.3a310c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a310f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3112	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3115	a5 23		lda $0823	                LDA ARGUMENT1
.3a3117	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a3119	a9 2c 00	lda #$002c	                LDA #','
.3a311c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a311f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3122	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3125	a5 23		lda $0823	                LDA ARGUMENT1
.3a3127	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a3129	a9 2c 00	lda #$002c	                LDA #','
.3a312c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a312f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3132	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3135	a5 23		lda $0823	                LDA ARGUMENT1
.3a3137	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.3a3139	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.3a313b	85 59		sta $0859	                STA X0
.3a313d	a3 05		lda $05,s	                LDA L_Y0
.3a313f	85 5d		sta $085d	                STA Y0
.3a3141	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.3a3143	85 61		sta $0861	                STA X1
.3a3145	a3 09		lda $09,s	                LDA L_Y1
.3a3147	85 65		sta $0865	                STA Y1
.3a3149	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a314b	20 b6 2d	jsr $3a2db6	            JSR BITMAP_SRAM
.3a314e	20 c1 2f	jsr $3a2fc1	            JSR LINE
.3a3151					done
.3a3151	c2 20		rep #$20	            REP #$20
.3a3153	3b		tsc		            TSC
.3a3154	18		clc		            CLC
.3a3155	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a3158	1b		tcs		            TCS
.3a3159	28		plp		                PLP
.3a315a	60		rts		            RTS
.3a315b					S_FILL
.3a315b	08		php		                PHP
.3a315c					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.3a315c	c2 20		rep #$20	            REP #$20
.3a315e	3b		tsc		            TSC
.3a315f	38		sec		            SEC
.3a3160	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.3a3163	1b		tcs		            TCS
.3a3164	08		php		            PHP
.3a3165	c2 20		rep #$20	            REP #$20
.3a3167	48		pha		            PHA
.3a3168	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a316b	5b		tcd		            TCD
.3a316c	68		pla		            PLA
.3a316d	28		plp		            PLP
.3a316e	08		php		            PHP
.3a316f	e2 20		sep #$20	            SEP #$20
.3a3171	48		pha		            PHA
.3a3172	a9 00		lda #$00	            LDA #0
.3a3174	48		pha		            PHA
.3a3175	ab		plb		            PLB
.3a3176	68		pla		            PLA
.3a3177	28		plp		            PLP
.3a3178	c2 30		rep #$30	            REP #$30
.3a317a	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a317d	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3180	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a3182	a9 2c 00	lda #$002c	                LDA #','
.3a3185	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3188	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a318b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a318e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3190	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a3192	a9 2c 00	lda #$002c	                LDA #','
.3a3195	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3198	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a319b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a319e	a5 23		lda $0823	                LDA ARGUMENT1
.3a31a0	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a31a2	a9 2c 00	lda #$002c	                LDA #','
.3a31a5	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a31a8	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a31ab	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a31ae	a5 23		lda $0823	                LDA ARGUMENT1
.3a31b0	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a31b2	a9 2c 00	lda #$002c	                LDA #','
.3a31b5	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a31b8	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a31bb	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a31be	a5 23		lda $0823	                LDA ARGUMENT1
.3a31c0	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a31c2	a9 2c 00	lda #$002c	                LDA #','
.3a31c5	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a31c8	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a31cb	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a31ce	a5 23		lda $0823	                LDA ARGUMENT1
.3a31d0	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.3a31d2	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a31d4	20 fa 2d	jsr $3a2dfa	            JSR BITMAP_VRAM
.3a31d7	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.3a31da	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a31de	c2 20		rep #$20	            REP #$20
.3a31e0	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.3a31e2	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a31e6	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a31ea	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.3a31ee	18		clc		                CLC                         ; Add the column
.3a31ef	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.3a31f3	63 03		adc $03,s	                ADC L_X0
.3a31f5	85 0c		sta $080c	                STA SCRATCH
.3a31f7	e2 20		sep #$20	            SEP #$20
.3a31f9	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a31fd	69 00		adc #$00	                ADC #0
.3a31ff	85 0e		sta $080e	                STA SCRATCH+2
.3a3201	c2 20		rep #$20	            REP #$20
.3a3203	18		clc		                CLC                         ; Set the destination address
.3a3204	a5 9e		lda $089e	                LDA MTEMPPTR
.3a3206	65 0c		adc $080c	                ADC SCRATCH
.3a3208	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a320c	e2 20		sep #$20	            SEP #$20
.3a320e	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a3210	65 0e		adc $080e	                ADC SCRATCH+2
.3a3212	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.3a3216	c2 20		rep #$20	            REP #$20
.3a3218	38		sec		                SEC                         ; Set the width of the FILL operation
.3a3219	a3 07		lda $07,s	                LDA L_X1
.3a321b	e3 03		sbc $03,s	                SBC L_X0
.3a321d	85 0c		sta $080c	                STA SCRATCH
.3a321f	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a3223	38		sec		                SEC
.3a3224	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a3228	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.3a322c	38		sec		                SEC                         ; Set the height of the FILL operation
.3a322d	a3 09		lda $09,s	                LDA L_Y1
.3a322f	e3 05		sbc $05,s	                SBC L_Y0
.3a3231	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a3235	e2 20		sep #$20	            SEP #$20
.3a3237	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.3a3239	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.3a323d	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a3241	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.3a3243	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3247	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a324b	30 fa		bmi $3a3247	                BMI wait
.3a324d	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a324f	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3253					done
.3a3253	c2 20		rep #$20	            REP #$20
.3a3255	3b		tsc		            TSC
.3a3256	18		clc		            CLC
.3a3257	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.3a325a	1b		tcs		            TCS
.3a325b	28		plp		                PLP
.3a325c	60		rts		            RTS
.3a325d					SPADDR
.3a325d	08		php		                PHP
.3a325e	c2 20		rep #$20	            REP #$20
.3a3260	c9 40 00	cmp #$0040	                CMP #SP_MAX
.3a3263	b0 13		bcs $3a3278	                BGE error
.3a3265	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.3a3266	0a		asl a		                ASL A
.3a3267	0a		asl a		                ASL A
.3a3268	18		clc		                CLC                         ; Add it to the address of the first
.3a3269	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.3a326c	85 9e		sta $089e	                STA MTEMPPTR
.3a326e	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.3a3271	69 00 00	adc #$0000	                ADC #0
.3a3274	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.3a3276	28		plp		                PLP
.3a3277	60		rts		            RTS
.3a3278					error
.3a3278	08		php		            PHP
.3a3279	c2 20		rep #$20	            REP #$20
.3a327b	48		pha		            PHA
.3a327c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a327f	5b		tcd		            TCD
.3a3280	68		pla		            PLA
.3a3281	28		plp		            PLP
.3a3282	e2 20		sep #$20	            SEP #$20
.3a3284	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3286	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a328a	c2 20		rep #$20	            REP #$20
.3a328c	29 ff 00	and #$00ff	            AND #$00FF
.3a328f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3292	e2 20		sep #$20	            SEP #$20
.3a3294	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3297					S_SPRITE
.3a3297	08		php		                PHP
.3a3298					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.3a3298	c2 20		rep #$20	            REP #$20
.3a329a	3b		tsc		            TSC
.3a329b	38		sec		            SEC
.3a329c	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a329f	1b		tcs		            TCS
.3a32a0	c2 30		rep #$30	            REP #$30
.3a32a2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a32a5	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a32a8	a5 23		lda $0823	                LDA ARGUMENT1
.3a32aa	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a32ac	a9 2c 00	lda #$002c	                LDA #','
.3a32af	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a32b2	e2 20		sep #$20	            SEP #$20
.3a32b4	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a32b7	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a32ba	a5 23		lda $0823	                LDA ARGUMENT1
.3a32bc	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.3a32be	b0 56		bcs $3a3316	                BGE error                   ; If not: throw an error
.3a32c0	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.3a32c2	a9 2c		lda #$2c	                LDA #','
.3a32c4	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a32c7	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a32ca	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a32cd	c2 20		rep #$20	            REP #$20
.3a32cf	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.3a32d0	a5 23		lda $0823	                LDA ARGUMENT1
.3a32d2	e9 00 00	sbc #$0000	                SBC #<>VRAM
.3a32d5	85 23		sta $0823	                STA ARGUMENT1
.3a32d7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a32d9	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.3a32dc	85 25		sta $0825	                STA ARGUMENT1+2
.3a32de	30 36		bmi $3a3316	                BMI error                   ; If negative, throw an error
.3a32e0	c2 20		rep #$20	            REP #$20
.3a32e2	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a32e4	aa		tax		                TAX
.3a32e5	20 5d 32	jsr $3a325d	            JSR SPADDR
.3a32e8	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.3a32ea	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.3a32ed	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a32ef	e2 20		sep #$20	            SEP #$20
.3a32f1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a32f3	c8		iny		                INY
.3a32f4	c8		iny		                INY
.3a32f5	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.3a32f7	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.3a32fb	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.3a32fd	85 0c		sta $080c	                STA SCRATCH
.3a32ff	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.3a3301	0a		asl a		                ASL A                       ; Sift it into the LUT position
.3a3302	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.3a3304	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.3a3306	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.3a3308	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.3a330c					done
.3a330c	c2 20		rep #$20	            REP #$20
.3a330e	3b		tsc		            TSC
.3a330f	18		clc		            CLC
.3a3310	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a3313	1b		tcs		            TCS
.3a3314	28		plp		                PLP
.3a3315	60		rts		            RTS
.3a3316					error
.3a3316	08		php		            PHP
.3a3317	c2 20		rep #$20	            REP #$20
.3a3319	48		pha		            PHA
.3a331a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a331d	5b		tcd		            TCD
.3a331e	68		pla		            PLA
.3a331f	28		plp		            PLP
.3a3320	e2 20		sep #$20	            SEP #$20
.3a3322	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3324	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3328	c2 20		rep #$20	            REP #$20
.3a332a	29 ff 00	and #$00ff	            AND #$00FF
.3a332d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3330	e2 20		sep #$20	            SEP #$20
.3a3332	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3335					S_SPRITEAT
.3a3335	08		php		                PHP
.3a3336					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.3a3336	c2 20		rep #$20	            REP #$20
.3a3338	3b		tsc		            TSC
.3a3339	38		sec		            SEC
.3a333a	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a333d	1b		tcs		            TCS
.3a333e	c2 30		rep #$30	            REP #$30
.3a3340	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3343	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3346	a5 23		lda $0823	                LDA ARGUMENT1
.3a3348	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a334a	a9 2c 00	lda #$002c	                LDA #','
.3a334d	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3350	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3353	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3356	a5 23		lda $0823	                LDA ARGUMENT1
.3a3358	83 03		sta $03,s	                STA L_X                     ; Save it as X
.3a335a	a9 2c 00	lda #$002c	                LDA #','
.3a335d	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3360	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3363	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3366	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a3368	20 5d 32	jsr $3a325d	            JSR SPADDR
.3a336b	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.3a336d	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.3a3370	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3372	a5 23		lda $0823	                LDA ARGUMENT1
.3a3374	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.3a3377	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3379					done
.3a3379	c2 20		rep #$20	            REP #$20
.3a337b	3b		tsc		            TSC
.3a337c	18		clc		            CLC
.3a337d	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a3380	1b		tcs		            TCS
.3a3381	28		plp		                PLP
.3a3382	60		rts		            RTS
.3a3383					S_SPRITESHOW
.3a3383	08		php		                PHP
.3a3384					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.3a3384	c2 20		rep #$20	            REP #$20
.3a3386	3b		tsc		            TSC
.3a3387	38		sec		            SEC
.3a3388	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a338b	1b		tcs		            TCS
.3a338c	c2 30		rep #$30	            REP #$30
.3a338e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3391	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3394	a5 23		lda $0823	                LDA ARGUMENT1
.3a3396	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3398	a9 2c 00	lda #$002c	                LDA #','
.3a339b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a339e	e2 20		sep #$20	            SEP #$20
.3a33a0	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a33a3	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a33a6	a5 23		lda $0823	                LDA ARGUMENT1
.3a33a8	d0 04		bne $3a33ae	                BNE is_visible
.3a33aa	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.3a33ac	80 04		bra $3a33b2	                BRA chk_layer
.3a33ae	a9 01		lda #$01	is_visible      LDA #1
.3a33b0	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.3a33b2	a9 2c		lda #$2c	chk_layer       LDA #','
.3a33b4	85 37		sta $0837	                STA TARGETTOK
.3a33b6	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a33b9	b0 20		bcs $3a33db	                BCS get_layer               ; Yes: get the layer
.3a33bb					no_layer
.3a33bb	c2 30		rep #$30	            REP #$30
.3a33bd	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a33bf	aa		tax		                TAX
.3a33c0	20 5d 32	jsr $3a325d	            JSR SPADDR
.3a33c3	e2 20		sep #$20	            SEP #$20
.3a33c5	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a33c9	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.3a33cb	85 0c		sta $080c	                STA SCRATCH
.3a33cd	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a33cf	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a33d1	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a33d3	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.3a33d7	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.3a33d9	80 36		bra $3a3411	                BRA done
.3a33db					get_layer
.3a33db	c2 30		rep #$30	            REP #$30
.3a33dd	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a33e0	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a33e3	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a33e6	a5 23		lda $0823	                LDA ARGUMENT1
.3a33e8	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.3a33eb	b0 2e		bcs $3a341b	                BGE error                   ; If not, throw an out of range error
.3a33ed	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.3a33ee	0a		asl a		                ASL A
.3a33ef	0a		asl a		                ASL A
.3a33f0	0a		asl a		                ASL A
.3a33f1	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.3a33f3	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a33f5	aa		tax		                TAX
.3a33f6	20 5d 32	jsr $3a325d	            JSR SPADDR
.3a33f9	e2 20		sep #$20	            SEP #$20
.3a33fb	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a33fd	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a33ff	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a3401	85 0c		sta $080c	                STA SCRATCH
.3a3403	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a3407	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.3a3409	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.3a340b	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.3a340d	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.3a3411					done
.3a3411	c2 20		rep #$20	            REP #$20
.3a3413	3b		tsc		            TSC
.3a3414	18		clc		            CLC
.3a3415	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a3418	1b		tcs		            TCS
.3a3419	28		plp		                PLP
.3a341a	60		rts		            RTS
.3a341b					error
.3a341b	08		php		            PHP
.3a341c	c2 20		rep #$20	            REP #$20
.3a341e	48		pha		            PHA
.3a341f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3422	5b		tcd		            TCD
.3a3423	68		pla		            PLA
.3a3424	28		plp		            PLP
.3a3425	e2 20		sep #$20	            SEP #$20
.3a3427	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3429	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a342d	c2 20		rep #$20	            REP #$20
.3a342f	29 ff 00	and #$00ff	            AND #$00FF
.3a3432	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3435	e2 20		sep #$20	            SEP #$20
.3a3437	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a343a					TILESET_ADDR
.3a343a	08		php		                PHP
.3a343b	c2 20		rep #$20	            REP #$20
.3a343d	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a3440	b0 19		bcs $3a345b	                BGE out_of_range            ; If not, throw a range error
.3a3442	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a3445	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.3a3448	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a344b	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.3a344c	ad 04 01	lda $0104	                LDA @w M0_RESULT
.3a344f	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.3a3452	85 9e		sta $089e	                STA MTEMPPTR
.3a3454	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.3a3457	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3459	28		plp		                PLP
.3a345a	60		rts		            RTS
.3a345b					out_of_range
.3a345b	08		php		            PHP
.3a345c	c2 20		rep #$20	            REP #$20
.3a345e	48		pha		            PHA
.3a345f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3462	5b		tcd		            TCD
.3a3463	68		pla		            PLA
.3a3464	28		plp		            PLP
.3a3465	e2 20		sep #$20	            SEP #$20
.3a3467	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3469	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a346d	c2 20		rep #$20	            REP #$20
.3a346f	29 ff 00	and #$00ff	            AND #$00FF
.3a3472	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3475	e2 20		sep #$20	            SEP #$20
.3a3477	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a347a					TILEMAP_ADDR
.3a347a	08		php		                PHP
.3a347b	c2 20		rep #$20	            REP #$20
.3a347d	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a3480	b0 19		bcs $3a349b	                BGE out_of_range            ; If not, throw a range error
.3a3482	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a3485	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.3a3488	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a348b	18		clc		                CLC
.3a348c	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.3a348f	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.3a3492	85 9e		sta $089e	                STA MTEMPPTR
.3a3494	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.3a3497	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3499	28		plp		                PLP
.3a349a	60		rts		            RTS
.3a349b					out_of_range
.3a349b	08		php		            PHP
.3a349c	c2 20		rep #$20	            REP #$20
.3a349e	48		pha		            PHA
.3a349f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a34a2	5b		tcd		            TCD
.3a34a3	68		pla		            PLA
.3a34a4	28		plp		            PLP
.3a34a5	e2 20		sep #$20	            SEP #$20
.3a34a7	a9 09		lda #$09	            LDA #ERR_RANGE
.3a34a9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a34ad	c2 20		rep #$20	            REP #$20
.3a34af	29 ff 00	and #$00ff	            AND #$00FF
.3a34b2	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a34b5	e2 20		sep #$20	            SEP #$20
.3a34b7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a34ba					S_TILESET
.3a34ba	08		php		                PHP
.3a34bb					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.3a34bb	c2 20		rep #$20	            REP #$20
.3a34bd	3b		tsc		            TSC
.3a34be	38		sec		            SEC
.3a34bf	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a34c2	1b		tcs		            TCS
.3a34c3	c2 20		rep #$20	            REP #$20
.3a34c5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a34c8	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a34cb	a5 23		lda $0823	                LDA ARGUMENT1
.3a34cd	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.3a34cf	a9 2c 00	lda #$002c	                LDA #','
.3a34d2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a34d5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a34d8	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a34db	a5 23		lda $0823	                LDA ARGUMENT1
.3a34dd	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.3a34df	a9 2c 00	lda #$002c	                LDA #','
.3a34e2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a34e5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a34e8	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a34eb	a5 23		lda $0823	                LDA ARGUMENT1
.3a34ed	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.3a34ef	a9 2c 00	lda #$002c	                LDA #','
.3a34f2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a34f5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a34f8	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a34fb	a3 01		lda $01,s	                LDA L_TILENUM
.3a34fd	20 3a 34	jsr $3a343a	            JSR TILESET_ADDR
.3a3500	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.3a3502	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.3a3504	e2 20		sep #$20	            SEP #$20
.3a3506	38		sec		                SEC
.3a3507	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3509	e9 b0		sbc #$b0	                SBC #`VRAM
.3a350b	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.3a350e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3510	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.3a3512	d0 0d		bne $3a3521	                BNE is_square
.3a3514					not_square
.3a3514	e2 20		sep #$20	            SEP #$20
.3a3516	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a3518	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a351a	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a351d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a351f	80 0d		bra $3a352e	                BRA done
.3a3521					is_square
.3a3521	e2 20		sep #$20	            SEP #$20
.3a3523	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a3525	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a3527	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.3a3529	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a352c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a352e					done
.3a352e	c2 20		rep #$20	            REP #$20
.3a3530	3b		tsc		            TSC
.3a3531	18		clc		            CLC
.3a3532	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a3535	1b		tcs		            TCS
.3a3536	28		plp		                PLP
.3a3537	60		rts		            RTS
.3a3538					S_TILEMAP
.3a3538	08		php		                PHP
.3a3539					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.3a3539	c2 20		rep #$20	            REP #$20
.3a353b	3b		tsc		            TSC
.3a353c	38		sec		            SEC
.3a353d	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a3540	1b		tcs		            TCS
.3a3541	c2 20		rep #$20	            REP #$20
.3a3543	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3546	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3549	a5 23		lda $0823	                LDA ARGUMENT1
.3a354b	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a354d	a9 2c 00	lda #$002c	                LDA #','
.3a3550	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3553	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3556	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3559	a5 23		lda $0823	                LDA ARGUMENT1
.3a355b	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.3a355d	a9 2c 00	lda #$002c	                LDA #','
.3a3560	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3563	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3566	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3569	a5 23		lda $0823	                LDA ARGUMENT1
.3a356b	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.3a356d	a9 2c 00	lda #$002c	                LDA #','
.3a3570	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3573	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3576	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3579	a3 01		lda $01,s	                LDA L_TILENUM
.3a357b	20 7a 34	jsr $3a347a	            JSR TILEMAP_ADDR
.3a357e	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.3a3580	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.3a3583	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.3a3585	e2 20		sep #$20	            SEP #$20
.3a3587	38		sec		                SEC
.3a3588	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a358a	e9 b0		sbc #$b0	                SBC #`VRAM
.3a358c	c8		iny		                INY
.3a358d	c8		iny		                INY
.3a358e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3590	c2 20		rep #$20	            REP #$20
.3a3592	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.3a3594	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.3a3597	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3599	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.3a359b	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.3a359e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a35a0					done
.3a35a0	c2 20		rep #$20	            REP #$20
.3a35a2	3b		tsc		            TSC
.3a35a3	18		clc		            CLC
.3a35a4	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a35a7	1b		tcs		            TCS
.3a35a8	28		plp		                PLP
.3a35a9	60		rts		            RTS
.3a35aa					S_TILESHOW
.3a35aa	08		php		                PHP
.3a35ab					locals
>0001					L_TILENUM       .word ?
.3a35ab	c2 20		rep #$20	            REP #$20
.3a35ad	f4 00 00	pea #$0000	            PEA #0
.3a35b0	c2 20		rep #$20	            REP #$20
.3a35b2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a35b5	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a35b8	a5 23		lda $0823	                LDA ARGUMENT1
.3a35ba	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a35bc	a9 2c 00	lda #$002c	                LDA #','
.3a35bf	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a35c2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a35c5	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a35c8	a3 01		lda $01,s	                LDA L_TILENUM
.3a35ca	20 7a 34	jsr $3a347a	            JSR TILEMAP_ADDR
.3a35cd	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.3a35cf	d0 06		bne $3a35d7	                BNE is_visible              ; If it's <> 0, make it visible
.3a35d1	e2 20		sep #$20	            SEP #$20
.3a35d3	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.3a35d5	80 04		bra $3a35db	                BRA set_control
.3a35d7					is_visible
.3a35d7	e2 20		sep #$20	            SEP #$20
.3a35d9	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.3a35db					set_control
.3a35db	e2 20		sep #$20	            SEP #$20
.3a35dd	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.3a35e0	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a35e2					done
.3a35e2	c2 20		rep #$20	            REP #$20
.3a35e4	68		pla		            PLA
.3a35e5	28		plp		                PLP
.3a35e6	60		rts		            RTS
.3a35e7					S_TILEAT
.3a35e7	08		php		                PHP
.3a35e8					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.3a35e8	c2 20		rep #$20	            REP #$20
.3a35ea	3b		tsc		            TSC
.3a35eb	38		sec		            SEC
.3a35ec	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a35ef	1b		tcs		            TCS
.3a35f0	c2 20		rep #$20	            REP #$20
.3a35f2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a35f5	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a35f8	a5 23		lda $0823	                LDA ARGUMENT1
.3a35fa	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a35fc	a9 2c 00	lda #$002c	                LDA #','
.3a35ff	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3602	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3605	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3608	a5 23		lda $0823	                LDA ARGUMENT1
.3a360a	83 03		sta $03,s	                STA L_X                     ; Save as X
.3a360c	a9 2c 00	lda #$002c	                LDA #','
.3a360f	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3612	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3615	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3618	a3 01		lda $01,s	                LDA L_TILENUM
.3a361a	20 7a 34	jsr $3a347a	            JSR TILEMAP_ADDR
.3a361d	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.3a361f	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.3a3622	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3624	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.3a3626	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.3a3629	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a362b					done
.3a362b	c2 20		rep #$20	            REP #$20
.3a362d	3b		tsc		            TSC
.3a362e	18		clc		            CLC
.3a362f	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a3632	1b		tcs		            TCS
.3a3633	28		plp		                PLP
.3a3634	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>3af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.3af059					DMA_SRC
>3af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>3af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3af066					DMA_DEST
>3af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af067					ADDR            .long ?                     ; The starting address for the data to transfer
>3af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3a3635					DO_DMA
.3a3635	0b		phd		                PHD
.3a3636	08		php		                PHP
.3a3637	08		php		            PHP
.3a3638	c2 20		rep #$20	            REP #$20
.3a363a	48		pha		            PHA
.3a363b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a363e	5b		tcd		            TCD
.3a363f	68		pla		            PLA
.3a3640	28		plp		            PLP
.3a3641	e2 20		sep #$20	            SEP #$20
.3a3643	a9 00		lda #$00	                LDA #0
.3a3645	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.3a3649	af 5c f0 3a	lda $3af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.3a364d	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a364f	b0 1c		bcs $3a366d	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a3651	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.3a3655	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3659	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.3a365d	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a3661	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.3a3665	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.3a3667	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a366b	80 17		bra $3a3684	                BRA src_mode
.3a366d	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.3a366e	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3670	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.3a3674	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3678	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.3a367c	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a3680	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.3a3684	af 59 f0 3a	lda $3af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.3a3688	d0 3c		bne $3a36c6	                BNE src_2d
.3a368a	af 58 f0 3a	lda $3af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a368e	f0 1b		beq $3a36ab	                BEQ src_1d_vram
.3a3690	af 5d f0 3a	lda $3af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.3a3694	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3698	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a369c	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.3a36a0	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a36a4	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a36a8	82 8b 00	brl $3a3736	                BRL set_dst                 ; Go to set up the destination
.3a36ab	af 5d f0 3a	lda $3af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.3a36af	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a36b3	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a36b7	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.3a36bb	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a36bf	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a36c3	82 70 00	brl $3a3736	                BRL set_dst                 ; Go to set up the destination
.3a36c6	af 58 f0 3a	lda $3af058	src_2d          LDA @l DMA_BLOCKS
.3a36ca	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.3a36cc	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a36d0	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.3a36d2	f0 32		beq $3a3706	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.3a36d4	af 60 f0 3a	lda $3af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a36d8	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a36dc	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a36e0	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a36e4	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a36e8	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a36ec	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a36f0	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a36f4	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a36f8	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.3a36fc	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a3700	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.3a3704	80 30		bra $3a3736	                BRA set_dst
.3a3706	af 60 f0 3a	lda $3af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a370a	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a370e	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a3712	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a3716	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a371a	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a371e	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a3722	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a3726	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a372a	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.3a372e	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a3732	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.3a3736					set_dst
.3a3736	e2 20		sep #$20	            SEP #$20
.3a3738	af 69 f0 3a	lda $3af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.3a373c	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a373e	b0 20		bcs $3a3760	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a3740	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.3a3744	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3748	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.3a374c	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a3750	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.3a3754	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS
.3a3758	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.3a375a	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a375e	80 17		bra $3a3777	                BRA dst_mode
.3a3760	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.3a3761	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3763	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.3a3767	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a376b	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.3a376f	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a3773	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a3777	af 66 f0 3a	lda $3af066	dst_mode        LDA @l DMA_DEST.MODE
.3a377b	d0 3e		bne $3a37bb	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.3a377d	af 58 f0 3a	lda $3af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a3781	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.3a3783	f0 1b		beq $3a37a0	                BEQ dst_1d_vram
.3a3785	af 6a f0 3a	lda $3af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.3a3789	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a378d	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a3791	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.3a3795	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a3799	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a379d	82 8b 00	brl $3a382b	                BRL start_xfer
.3a37a0	af 6a f0 3a	lda $3af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.3a37a4	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a37a8	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a37ac	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.3a37b0	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a37b4	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a37b8	82 70 00	brl $3a382b	                BRL start_xfer
.3a37bb	af 58 f0 3a	lda $3af058	dst_2d          LDA @l DMA_BLOCKS
.3a37bf	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.3a37c1	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a37c5	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.3a37c7	f0 32		beq $3a37fb	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.3a37c9	af 6d f0 3a	lda $3af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.3a37cd	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a37d1	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a37d5	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a37d9	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.3a37dd	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a37e1	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a37e5	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a37e9	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.3a37ed	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.3a37f1	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a37f5	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.3a37f9	80 30		bra $3a382b	                BRA start_xfer
.3a37fb	af 6d f0 3a	lda $3af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.3a37ff	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a3803	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a3807	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a380b	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.3a380f	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a3813	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a3817	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a381b	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.3a381f	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.3a3823	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a3827	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.3a382b	af 58 f0 3a	lda $3af058	start_xfer      LDA @l DMA_BLOCKS
.3a382f	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a3831	f0 43		beq $3a3876	                BEQ start_vdma_only
.3a3833	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.3a3835	f0 76		beq $3a38ad	                BEQ start_s2v
.3a3837	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.3a3839	d0 03		bne $3a383e	                BNE start_sdma_only
.3a383b	82 8a 00	brl $3a38c8	                BRL start_v2s
.3a383e					start_sdma_only
.3a383e	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a3842	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a3844	f0 23		beq $3a3869	                BEQ sdma_1d_only            ; Source and Destination 1D...
.3a3846	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a3848	f0 23		beq $3a386d	                BEQ sdma_2d_only            ; Source and Destination 2D
.3a384a	08		php		            PHP
.3a384b	c2 20		rep #$20	            REP #$20
.3a384d	48		pha		            PHA
.3a384e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3851	5b		tcd		            TCD
.3a3852	68		pla		            PLA
.3a3853	28		plp		            PLP
.3a3854	e2 20		sep #$20	            SEP #$20
.3a3856	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3858	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a385c	c2 20		rep #$20	            REP #$20
.3a385e	29 ff 00	and #$00ff	            AND #$00FF
.3a3861	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3864	e2 20		sep #$20	            SEP #$20
.3a3866	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3869	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.3a386b	80 02		bra $3a386f	                BRA sdma_set_ctrl
.3a386d	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.3a386f	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.3a3873	82 7d 00	brl $3a38f3	                BRL trig_sdma               ; And trigger the SDMA
.3a3876					start_vdma_only
.3a3876	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a387a	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a387c	f0 23		beq $3a38a1	                BEQ vdma_1d_only            ; Source and Destination 1D...
.3a387e	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a3880	f0 23		beq $3a38a5	                BEQ vdma_2d_only            ; Source and Destination 2D...
.3a3882	08		php		            PHP
.3a3883	c2 20		rep #$20	            REP #$20
.3a3885	48		pha		            PHA
.3a3886	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3889	5b		tcd		            TCD
.3a388a	68		pla		            PLA
.3a388b	28		plp		            PLP
.3a388c	e2 20		sep #$20	            SEP #$20
.3a388e	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3890	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3894	c2 20		rep #$20	            REP #$20
.3a3896	29 ff 00	and #$00ff	            AND #$00FF
.3a3899	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a389c	e2 20		sep #$20	            SEP #$20
.3a389e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a38a1	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.3a38a3	80 02		bra $3a38a7	                BRA vdma_set_ctrl
.3a38a5	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.3a38a7	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.3a38ab	80 34		bra $3a38e1	                BRA trig_vdma               ; And trigger the VDMA
.3a38ad					start_s2v
.3a38ad	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a38b1	29 01		and #$01	                AND #DMA_SRC_2D
.3a38b3	0a		asl a		                ASL A
.3a38b4	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.3a38b6	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a38ba	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a38be	29 02		and #$02	                AND #DMA_DST_2D
.3a38c0	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.3a38c2	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a38c6	80 19		bra $3a38e1	                BRA trig_vdma               ; And trigger the VDMA
.3a38c8					start_v2s
.3a38c8	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a38cc	29 02		and #$02	                AND #DMA_DST_2D
.3a38ce	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.3a38d0	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a38d4	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a38d8	29 01		and #$01	                AND #DMA_SRC_2D
.3a38da	0a		asl a		                ASL A
.3a38db	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.3a38dd	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a38e1					trig_vdma
.3a38e1	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a38e5	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.3a38e7	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a38eb	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.3a38ef	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a38f1	f0 0f		beq $3a3902	                BEQ wait_vdma               ; No: wait for VDMA to complete
.3a38f3					trig_sdma
.3a38f3	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.3a38f7	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.3a38f9	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a38fd	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.3a38fe	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.3a38ff	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.3a3900	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.3a3901	ea		nop		                NOP
.3a3902	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.3a3906	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.3a3908	d0 f8		bne $3a3902	                BNE wait_vdma               ; Wait until it stops.
.3a390a	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.3a390c	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a3910	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3914	28		plp		                PLP
.3a3915	2b		pld		                PLD
.3a3916	60		rts		            RTS
.3a3917					S_MEMCOPY
.3a3917	0b		phd		                PHD
.3a3918	08		php		                PHP
.3a3919	e2 20		sep #$20	            SEP #$20
.3a391b	c2 10		rep #$10	            REP #$10
.3a391d	a9 00		lda #$00	                LDA #0
.3a391f	a2 00 00	ldx #$0000	                LDX #0
.3a3922	8f 59 f0 3a	sta $3af059	clr_loop        STA @l DMA_SRC
.3a3926	e8		inx		                INX
.3a3927	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.3a392a	d0 f6		bne $3a3922	                BNE clr_loop
.3a392c	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a392f	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3931	f0 23		beq $3a3956	                BEQ src_linear                      ; Yes: go to process a linear source
.3a3933	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a3935	f0 5e		beq $3a3995	                BEQ src_rect                        ; Yes: go to process a rectangular source
.3a3937					syntax_err
.3a3937	08		php		            PHP
.3a3938	c2 20		rep #$20	            REP #$20
.3a393a	48		pha		            PHA
.3a393b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a393e	5b		tcd		            TCD
.3a393f	68		pla		            PLA
.3a3940	28		plp		            PLP
.3a3941	e2 20		sep #$20	            SEP #$20
.3a3943	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3945	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3949	c2 20		rep #$20	            REP #$20
.3a394b	29 ff 00	and #$00ff	            AND #$00FF
.3a394e	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3951	e2 20		sep #$20	            SEP #$20
.3a3953	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3956					src_linear
.3a3956	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3959	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a395c	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a395f	c2 20		rep #$20	            REP #$20
.3a3961	a5 23		lda $0823	            LDA ARGUMENT1
.3a3963	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a3967	e2 20		sep #$20	            SEP #$20
.3a3969	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a396b	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a396f	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3971	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3974	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3977	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a397a	c2 20		rep #$20	            REP #$20
.3a397c	a5 23		lda $0823	            LDA ARGUMENT1
.3a397e	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3982	e2 20		sep #$20	            SEP #$20
.3a3984	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3986	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a398a	e2 20		sep #$20	            SEP #$20
.3a398c	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a398e	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3992	82 74 00	brl $3a3a09	                BRL process_to
.3a3995					src_rect
.3a3995	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3998	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a399b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a399e	c2 20		rep #$20	            REP #$20
.3a39a0	a5 23		lda $0823	            LDA ARGUMENT1
.3a39a2	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a39a6	e2 20		sep #$20	            SEP #$20
.3a39a8	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a39aa	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a39ae	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a39b0	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a39b3	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a39b6	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a39b9	c2 20		rep #$20	            REP #$20
.3a39bb	a5 23		lda $0823	            LDA ARGUMENT1
.3a39bd	8f 60 f0 3a	sta $3af060	            STA DMA_SRC.WIDTH
.3a39c1	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a39c4	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a39c7	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a39ca	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a39cd	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a39d0	c2 20		rep #$20	            REP #$20
.3a39d2	a5 23		lda $0823	            LDA ARGUMENT1
.3a39d4	8f 62 f0 3a	sta $3af062	            STA DMA_SRC.HEIGHT
.3a39d8	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a39db	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a39de	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a39e1	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a39e4	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a39e7	c2 20		rep #$20	            REP #$20
.3a39e9	a5 23		lda $0823	            LDA ARGUMENT1
.3a39eb	8f 64 f0 3a	sta $3af064	            STA DMA_SRC.STRIDE
.3a39ef	c2 20		rep #$20	            REP #$20
.3a39f1	ad 04 01	lda $0104	            LDA M0_RESULT
.3a39f4	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a39f8	e2 20		sep #$20	            SEP #$20
.3a39fa	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a39fd	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a3a01	e2 20		sep #$20	            SEP #$20
.3a3a03	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3a05	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3a09					process_to
.3a3a09	e2 20		sep #$20	            SEP #$20
.3a3a0b	a9 9c		lda #$9c	                LDA #TOK_TO
.3a3a0d	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3a10	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a3a13	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3a15	f0 23		beq $3a3a3a	                BEQ dest_linear                     ; Yes: go to process a linear destination
.3a3a17	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a3a19	f0 5e		beq $3a3a79	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.3a3a1b					syntax_err2
.3a3a1b	08		php		            PHP
.3a3a1c	c2 20		rep #$20	            REP #$20
.3a3a1e	48		pha		            PHA
.3a3a1f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3a22	5b		tcd		            TCD
.3a3a23	68		pla		            PLA
.3a3a24	28		plp		            PLP
.3a3a25	e2 20		sep #$20	            SEP #$20
.3a3a27	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3a29	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3a2d	c2 20		rep #$20	            REP #$20
.3a3a2f	29 ff 00	and #$00ff	            AND #$00FF
.3a3a32	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3a35	e2 20		sep #$20	            SEP #$20
.3a3a37	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3a3a					dest_linear
.3a3a3a	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3a3d	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3a40	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3a43	c2 20		rep #$20	            REP #$20
.3a3a45	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a47	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3a4b	e2 20		sep #$20	            SEP #$20
.3a3a4d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a4f	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3a53	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3a55	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3a58	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3a5b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3a5e	c2 20		rep #$20	            REP #$20
.3a3a60	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a62	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3a66	e2 20		sep #$20	            SEP #$20
.3a3a68	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a6a	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3a6e	e2 20		sep #$20	            SEP #$20
.3a3a70	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3a72	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3a76	82 74 00	brl $3a3aed	                BRL verify
.3a3a79					dest_rect
.3a3a79	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3a7c	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3a7f	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3a82	c2 20		rep #$20	            REP #$20
.3a3a84	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a86	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3a8a	e2 20		sep #$20	            SEP #$20
.3a3a8c	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a8e	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3a92	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3a94	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3a97	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3a9a	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3a9d	c2 20		rep #$20	            REP #$20
.3a3a9f	a5 23		lda $0823	            LDA ARGUMENT1
.3a3aa1	8f 6d f0 3a	sta $3af06d	            STA DMA_DEST.WIDTH
.3a3aa5	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a3aa8	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3aab	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3aae	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3ab1	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3ab4	c2 20		rep #$20	            REP #$20
.3a3ab6	a5 23		lda $0823	            LDA ARGUMENT1
.3a3ab8	8f 6f f0 3a	sta $3af06f	            STA DMA_DEST.HEIGHT
.3a3abc	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a3abf	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3ac2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3ac5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3ac8	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3acb	c2 20		rep #$20	            REP #$20
.3a3acd	a5 23		lda $0823	            LDA ARGUMENT1
.3a3acf	8f 71 f0 3a	sta $3af071	            STA DMA_DEST.STRIDE
.3a3ad3	c2 20		rep #$20	            REP #$20
.3a3ad5	ad 04 01	lda $0104	            LDA M0_RESULT
.3a3ad8	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3adc	e2 20		sep #$20	            SEP #$20
.3a3ade	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a3ae1	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3ae5	e2 20		sep #$20	            SEP #$20
.3a3ae7	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3ae9	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3aed					verify
.3a3aed	c2 20		rep #$20	            REP #$20
.3a3aef	af 5d f0 3a	lda $3af05d	                LDA @l DMA_SRC.SIZE
.3a3af3	cf 6a f0 3a	cmp $3af06a	                CMP @l DMA_DEST.SIZE
.3a3af7	d0 14		bne $3a3b0d	                BNE size_err
.3a3af9	e2 20		sep #$20	            SEP #$20
.3a3afb	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a3aff	cf 6c f0 3a	cmp $3af06c	                CMP @l DMA_DEST.SIZE+2
.3a3b03	d0 08		bne $3a3b0d	                BNE size_err
.3a3b05	c2 20		rep #$20	            REP #$20
.3a3b07	20 35 36	jsr $3a3635	            JSR DO_DMA
.3a3b0a	28		plp		                PLP
.3a3b0b	2b		pld		                PLD
.3a3b0c	60		rts		            RTS
.3a3b0d					size_err
.3a3b0d	08		php		            PHP
.3a3b0e	c2 20		rep #$20	            REP #$20
.3a3b10	48		pha		            PHA
.3a3b11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3b14	5b		tcd		            TCD
.3a3b15	68		pla		            PLA
.3a3b16	28		plp		            PLP
.3a3b17	e2 20		sep #$20	            SEP #$20
.3a3b19	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3b1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3b1f	c2 20		rep #$20	            REP #$20
.3a3b21	29 ff 00	and #$00ff	            AND #$00FF
.3a3b24	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3b27	e2 20		sep #$20	            SEP #$20
.3a3b29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3b2c					S_LOCATE
.3a3b2c	08		php		                PHP
.3a3b2d	c2 30		rep #$30	            REP #$30
.3a3b2f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3b32	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3b35	a5 23		lda $0823	                LDA ARGUMENT1
.3a3b37	48		pha		                PHA                         ; Save it for later
.3a3b38	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.3a3b3b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3b3e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3b41	20 b7 06	jsr $3a06b7	            JSR ASS_ARG1_BYTE
.3a3b44	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.3a3b46	fa		plx		                PLX                         ; Set X to the column
.3a3b47	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a3b4a	28		plp		                PLP
.3a3b4b	60		rts		            RTS

;******  Return to file: src\statements.s

.3a3b4c					S_INPUT
.3a3b4c	08		php		                PHP
.3a3b4d					varloop
.3a3b4d	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3b50	e2 20		sep #$20	            SEP #$20
.3a3b52	a7 00		lda [$0800]	                LDA [BIP]
.3a3b54	d0 03		bne $3a3b59	                BNE check_colon
.3a3b56	4c f4 3b	jmp $3a3bf4	                JMP done            ; If EOL, we're done
.3a3b59	c9 3a		cmp #$3a	check_colon     CMP #':'
.3a3b5b	d0 03		bne $3a3b60	                BNE check_string
.3a3b5d	4c f4 3b	jmp $3a3bf4	                JMP done            ; If colon, we're done
.3a3b60	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.3a3b62	d0 0b		bne $3a3b6f	                BNE check_var       ; No: then it should be a variable name
.3a3b64	20 67 1b	jsr $3a1b67	            JSR EVALSTRING
.3a3b67	20 02 45	jsr $3a4502	            JSR PR_STRING
.3a3b6a	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.3a3b6c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3b6f					check_var
.3a3b6f	20 36 04	jsr $3a0436	            JSR ISALPHA
.3a3b72	90 44		bcc $3a3bb8	                BCC syntax_err      ; No: it's a syntax error
.3a3b74	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a3b77	90 3f		bcc $3a3bb8	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3b79	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.3a3b7b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3b7e	a9 20		lda #$20	                LDA #CHAR_SP
.3a3b80	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3b83	20 10 00	jsr $3a0010	            JSR INPUTLINE
.3a3b86	e2 20		sep #$20	            SEP #$20
.3a3b88	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.3a3b8a	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.3a3b8c	f0 49		beq $3a3bd7	                BEQ in_string       ; ... go to copy the string data
.3a3b8e	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.3a3b90	d0 03		bne $3a3b95	                BNE chk_float
.3a3b92	82 84 00	brl $3a3c19	                BRL in_integer      ; ... go to parse the integer
.3a3b95	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.3a3b97	f0 5d		beq $3a3bf6	                BEQ in_float        ; ... go to parse the float
.3a3b99	08		php		            PHP
.3a3b9a	c2 20		rep #$20	            REP #$20
.3a3b9c	48		pha		            PHA
.3a3b9d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3ba0	5b		tcd		            TCD
.3a3ba1	68		pla		            PLA
.3a3ba2	28		plp		            PLP
.3a3ba3	e2 20		sep #$20	            SEP #$20
.3a3ba5	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3ba7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3bab	c2 20		rep #$20	            REP #$20
.3a3bad	29 ff 00	and #$00ff	            AND #$00FF
.3a3bb0	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3bb3	e2 20		sep #$20	            SEP #$20
.3a3bb5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3bb8					syntax_err
.3a3bb8	08		php		            PHP
.3a3bb9	c2 20		rep #$20	            REP #$20
.3a3bbb	48		pha		            PHA
.3a3bbc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3bbf	5b		tcd		            TCD
.3a3bc0	68		pla		            PLA
.3a3bc1	28		plp		            PLP
.3a3bc2	e2 20		sep #$20	            SEP #$20
.3a3bc4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3bc6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3bca	c2 20		rep #$20	            REP #$20
.3a3bcc	29 ff 00	and #$00ff	            AND #$00FF
.3a3bcf	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3bd2	e2 20		sep #$20	            SEP #$20
.3a3bd4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3bd7					in_string
.3a3bd7	c2 20		rep #$20	            REP #$20
.3a3bd9	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.3a3bdc	85 23		sta $0823	                STA ARGUMENT1
.3a3bde	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3be1	85 25		sta $0825	                STA ARGUMENT1+2
.3a3be3	e2 20		sep #$20	            SEP #$20
.3a3be5	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3be7	85 27		sta $0827	                STA ARGTYPE1
.3a3be9					save_input
.3a3be9	c2 20		rep #$20	            REP #$20
.3a3beb	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a3bee	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.3a3bf1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3bf4	28		plp		done            PLP
.3a3bf5	60		rts		            RTS
.3a3bf6					in_float
.3a3bf6	c2 20		rep #$20	            REP #$20
.3a3bf8	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3bfa	85 40		sta $0840	                STA SAVEBIP
.3a3bfc	a5 02		lda $0802	                LDA BIP+2
.3a3bfe	85 42		sta $0842	                STA SAVEBIP+2
.3a3c00	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3c03	85 00		sta $0800	                STA BIP
.3a3c05	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3c08	85 02		sta $0802	                STA BIP+2
.3a3c0a	20 e9 58	jsr $3a58e9	            JSR PARSENUM
.3a3c0d	c2 20		rep #$20	            REP #$20
.3a3c0f	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3c11	85 00		sta $0800	                STA BIP
.3a3c13	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3c15	85 02		sta $0802	                STA BIP+2
.3a3c17	80 d0		bra $3a3be9	                BRA save_input
.3a3c19					in_integer
.3a3c19	c2 20		rep #$20	            REP #$20
.3a3c1b	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3c1d	85 40		sta $0840	                STA SAVEBIP
.3a3c1f	a5 02		lda $0802	                LDA BIP+2
.3a3c21	85 42		sta $0842	                STA SAVEBIP+2
.3a3c23	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3c26	85 00		sta $0800	                STA BIP
.3a3c28	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3c2b	85 02		sta $0802	                STA BIP+2
.3a3c2d	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a3c30	c2 20		rep #$20	            REP #$20
.3a3c32	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3c34	85 00		sta $0800	                STA BIP
.3a3c36	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3c38	85 02		sta $0802	                STA BIP+2
.3a3c3a	80 ad		bra $3a3be9	                BRA save_input
.3a3c3c					S_GET
.3a3c3c	08		php		                PHP
.3a3c3d					varloop
.3a3c3d	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3c40	e2 20		sep #$20	            SEP #$20
.3a3c42	a7 00		lda [$0800]	                LDA [BIP]
.3a3c44	f0 47		beq $3a3c8d	                BEQ done            ; If EOL, we're done
.3a3c46	c9 3a		cmp #$3a	                CMP #':'
.3a3c48	f0 43		beq $3a3c8d	                BEQ done            ; If colon, we're done
.3a3c4a	20 36 04	jsr $3a0436	            JSR ISALPHA
.3a3c4d	90 40		bcc $3a3c8f	                BCC syntax_err      ; No: it's a syntax error
.3a3c4f	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a3c52	90 3b		bcc $3a3c8f	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3c54	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a3c57	20 14 00	jsr $3a0014	            JSR GETKEY
.3a3c5a	e2 20		sep #$20	            SEP #$20
.3a3c5c	a0 00 00	ldy #$0000	                LDY #0
.3a3c5f	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3c61	a9 00		lda #$00	                LDA #0
.3a3c63	c8		iny		                INY
.3a3c64	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3c66	c2 20		rep #$20	            REP #$20
.3a3c68	a5 16		lda $0816	                LDA STRPTR
.3a3c6a	85 23		sta $0823	                STA ARGUMENT1
.3a3c6c	a5 18		lda $0818	                LDA STRPTR+2
.3a3c6e	85 25		sta $0825	                STA ARGUMENT1+2
.3a3c70	e2 20		sep #$20	            SEP #$20
.3a3c72	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3c74	85 27		sta $0827	                STA ARGTYPE1
.3a3c76	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a3c79	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3c7c	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3c7e	f0 0d		beq $3a3c8d	                BEQ done            ; EOL? We're done
.3a3c80	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3c82	f0 09		beq $3a3c8d	                BEQ done
.3a3c84	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3c86	d0 07		bne $3a3c8f	                BNE syntax_err      ; Nope: syntax error
.3a3c88	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3c8b	80 b0		bra $3a3c3d	                BRA varloop
.3a3c8d	28		plp		done            PLP
.3a3c8e	60		rts		            RTS
.3a3c8f					syntax_err
.3a3c8f	08		php		            PHP
.3a3c90	c2 20		rep #$20	            REP #$20
.3a3c92	48		pha		            PHA
.3a3c93	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c96	5b		tcd		            TCD
.3a3c97	68		pla		            PLA
.3a3c98	28		plp		            PLP
.3a3c99	e2 20		sep #$20	            SEP #$20
.3a3c9b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3c9d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ca1	c2 20		rep #$20	            REP #$20
.3a3ca3	29 ff 00	and #$00ff	            AND #$00FF
.3a3ca6	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3ca9	e2 20		sep #$20	            SEP #$20
.3a3cab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3cae					S_CALL
.3a3cae	08		php		                PHP
.3a3caf	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3cb2	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3cb5	e2 20		sep #$20	            SEP #$20
.3a3cb7	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.3a3cb9	85 a2		sta $08a2	                STA MJUMPINST
.3a3cbb	c2 20		rep #$20	            REP #$20
.3a3cbd	a5 23		lda $0823	                LDA ARGUMENT1
.3a3cbf	85 a3		sta $08a3	                STA MJUMPADDR
.3a3cc1	e2 20		sep #$20	            SEP #$20
.3a3cc3	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3cc5	85 a5		sta $08a5	                STA MJUMPADDR+2
.3a3cc7	e2 20		sep #$20	            SEP #$20
.3a3cc9	a9 2c		lda #$2c	                LDA #','
.3a3ccb	85 37		sta $0837	                STA TARGETTOK
.3a3ccd	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a3cd0	90 41		bcc $3a3d13	                BCC launch          ; Not present... go ahead and launch
.3a3cd2	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3cd5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3cd8	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3cdb	c2 20		rep #$20	            REP #$20
.3a3cdd	a5 23		lda $0823	                LDA ARGUMENT1
.3a3cdf	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.3a3ce1	e2 20		sep #$20	            SEP #$20
.3a3ce3	a9 2c		lda #$2c	                LDA #','
.3a3ce5	85 37		sta $0837	                STA TARGETTOK
.3a3ce7	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a3cea	90 27		bcc $3a3d13	                BCC launch          ; Not present... go ahead and launch
.3a3cec	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3cef	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3cf2	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3cf5	c2 20		rep #$20	            REP #$20
.3a3cf7	a5 23		lda $0823	                LDA ARGUMENT1
.3a3cf9	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.3a3cfb	e2 20		sep #$20	            SEP #$20
.3a3cfd	a9 2c		lda #$2c	                LDA #','
.3a3cff	85 37		sta $0837	                STA TARGETTOK
.3a3d01	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a3d04	90 0d		bcc $3a3d13	                BCC launch          ; Not present... go ahead and launch
.3a3d06	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3d09	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3d0c	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a3d0f	c2 20		rep #$20	            REP #$20
.3a3d11	a4 23		ldy $0823	                LDY ARGUMENT1
.3a3d13	a6 59		ldx $0859	launch          LDX MARG2
.3a3d15	a5 55		lda $0855	                LDA MARG1
.3a3d17	0b		phd		                PHD
.3a3d18	8b		phb		                PHB
.3a3d19	08		php		                PHP
.3a3d1a	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.3a3d1e	28		plp		                PLP
.3a3d1f	ab		plb		                PLB
.3a3d20	2b		pld		                PLD
.3a3d21	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a3d24	28		plp		                PLP
.3a3d25	60		rts		            RTS
.3a3d26					type_err
.3a3d26	08		php		            PHP
.3a3d27	c2 20		rep #$20	            REP #$20
.3a3d29	48		pha		            PHA
.3a3d2a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3d2d	5b		tcd		            TCD
.3a3d2e	68		pla		            PLA
.3a3d2f	28		plp		            PLP
.3a3d30	e2 20		sep #$20	            SEP #$20
.3a3d32	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3d34	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3d38	c2 20		rep #$20	            REP #$20
.3a3d3a	29 ff 00	and #$00ff	            AND #$00FF
.3a3d3d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3d40	e2 20		sep #$20	            SEP #$20
.3a3d42	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3d45					S_DIM
.3a3d45	08		php		                PHP
.3a3d46	e2 20		sep #$20	            SEP #$20
.3a3d48	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3d4b	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a3d4e	90 64		bcc $3a3db4	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3d50	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.3a3d52	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a3d55	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a3d57	20 77 19	jsr $3a1977	            JSR PHOPERATOR
.3a3d5a	a2 01 00	ldx #$0001	                LDX #1
.3a3d5d	a9 00		lda #$00	                LDA #0
.3a3d5f	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.3a3d63					dim_loop
.3a3d63	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3d66	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a3d69	c2 20		rep #$20	            REP #$20
.3a3d6b	a5 23		lda $0823	                LDA ARGUMENT1
.3a3d6d	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.3a3d71	e2 20		sep #$20	            SEP #$20
.3a3d73	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.3a3d77	1a		inc a		                INC A
.3a3d78	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.3a3d7c	30 55		bmi $3a3dd3	                BMI overflow        ; If > 127 throw an error
.3a3d7e	e8		inx		                INX
.3a3d7f	e8		inx		                INX
.3a3d80	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3d83	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.3a3d85	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.3a3d87	f0 25		beq $3a3dae	                BEQ skip_comma      ; Yes: get the next dimension
.3a3d89	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.3a3d8b	d0 27		bne $3a3db4	                BNE syntax_err      ; No: throw a syntax error
.3a3d8d	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3d90	20 45 65	jsr $3a6545	            JSR ARR_ALLOC
.3a3d93	c2 20		rep #$20	            REP #$20
.3a3d95	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.3a3d97	85 23		sta $0823	                STA ARGUMENT1
.3a3d99	e2 20		sep #$20	            SEP #$20
.3a3d9b	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a3d9d	85 25		sta $0825	                STA ARGUMENT1+2
.3a3d9f	64 26		stz $0826	                STZ ARGUMENT1+3
.3a3da1	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.3a3da3	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.3a3da5	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.3a3da7	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.3a3da9	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a3dac	28		plp		                PLP
.3a3dad	60		rts		            RTS
.3a3dae					skip_comma
.3a3dae	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3db1	4c 63 3d	jmp $3a3d63	                JMP dim_loop
.3a3db4					syntax_err
.3a3db4	08		php		            PHP
.3a3db5	c2 20		rep #$20	            REP #$20
.3a3db7	48		pha		            PHA
.3a3db8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3dbb	5b		tcd		            TCD
.3a3dbc	68		pla		            PLA
.3a3dbd	28		plp		            PLP
.3a3dbe	e2 20		sep #$20	            SEP #$20
.3a3dc0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3dc2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3dc6	c2 20		rep #$20	            REP #$20
.3a3dc8	29 ff 00	and #$00ff	            AND #$00FF
.3a3dcb	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3dce	e2 20		sep #$20	            SEP #$20
.3a3dd0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3dd3					overflow
.3a3dd3	08		php		            PHP
.3a3dd4	c2 20		rep #$20	            REP #$20
.3a3dd6	48		pha		            PHA
.3a3dd7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3dda	5b		tcd		            TCD
.3a3ddb	68		pla		            PLA
.3a3ddc	28		plp		            PLP
.3a3ddd	e2 20		sep #$20	            SEP #$20
.3a3ddf	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3de1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3de5	c2 20		rep #$20	            REP #$20
.3a3de7	29 ff 00	and #$00ff	            AND #$00FF
.3a3dea	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3ded	e2 20		sep #$20	            SEP #$20
.3a3def	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3df2					S_READ
.3a3df2	08		php		                PHP
.3a3df3					varloop
.3a3df3	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3df6	e2 20		sep #$20	            SEP #$20
.3a3df8	a7 00		lda [$0800]	                LDA [BIP]
.3a3dfa	f0 28		beq $3a3e24	                BEQ done            ; If EOL, we're done
.3a3dfc	c9 3a		cmp #$3a	                CMP #':'
.3a3dfe	f0 24		beq $3a3e24	                BEQ done            ; If colon, we're done
.3a3e00	20 36 04	jsr $3a0436	            JSR ISALPHA
.3a3e03	90 21		bcc $3a3e26	                BCC syntax_err      ; No: it's a syntax error
.3a3e05	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a3e08	90 1c		bcc $3a3e26	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3e0a	20 45 3e	jsr $3a3e45	            JSR NEXTDATA
.3a3e0d	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a3e10	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3e13	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3e15	f0 0d		beq $3a3e24	                BEQ done            ; EOL? We're done
.3a3e17	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3e19	f0 09		beq $3a3e24	                BEQ done
.3a3e1b	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3e1d	d0 07		bne $3a3e26	                BNE syntax_err      ; Nope: syntax error
.3a3e1f	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3e22	80 cf		bra $3a3df3	                BRA varloop
.3a3e24	28		plp		done            PLP
.3a3e25	60		rts		            RTS
.3a3e26					syntax_err
.3a3e26	08		php		            PHP
.3a3e27	c2 20		rep #$20	            REP #$20
.3a3e29	48		pha		            PHA
.3a3e2a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e2d	5b		tcd		            TCD
.3a3e2e	68		pla		            PLA
.3a3e2f	28		plp		            PLP
.3a3e30	e2 20		sep #$20	            SEP #$20
.3a3e32	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3e34	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e38	c2 20		rep #$20	            REP #$20
.3a3e3a	29 ff 00	and #$00ff	            AND #$00FF
.3a3e3d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3e40	e2 20		sep #$20	            SEP #$20
.3a3e42	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e45					NEXTDATA
.3a3e45	08		php		                PHP
.3a3e46	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.3a3e48	85 42		sta $0842	                STA SAVEBIP+2
.3a3e4a	a5 00		lda $0800	                LDA BIP
.3a3e4c	85 40		sta $0840	                STA SAVEBIP
.3a3e4e	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.3a3e50	85 46		sta $0846	                STA SAVELINE+2
.3a3e52	a5 1a		lda $081a	                LDA CURLINE
.3a3e54	85 44		sta $0844	                STA SAVELINE
.3a3e56	c2 20		rep #$20	            REP #$20
.3a3e58	a5 3a		lda $083a	                LDA DATABIP+2
.3a3e5a	d0 04		bne $3a3e60	                BNE data_set
.3a3e5c	a5 38		lda $0838	                LDA DATABIP
.3a3e5e	f0 4e		beq $3a3eae	                BEQ scan_start      ; No: scan for a DATA statement
.3a3e60	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.3a3e62	85 00		sta $0800	                STA BIP
.3a3e64	a5 3a		lda $083a	                LDA DATABIP+2
.3a3e66	85 02		sta $0802	                STA BIP+2
.3a3e68	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.3a3e6a	85 1a		sta $081a	                STA CURLINE
.3a3e6c	a5 3e		lda $083e	                LDA DATALINE+2
.3a3e6e	85 1c		sta $081c	                STA CURLINE+2
.3a3e70	e2 20		sep #$20	            SEP #$20
.3a3e72	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.3a3e74	f0 53		beq $3a3ec9	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.3a3e76	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.3a3e78	f0 4f		beq $3a3ec9	                BEQ scan_DATA       ; ... scan for a DATA statement
.3a3e7a	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3e7c	d0 03		bne $3a3e81	                BNE skip_parse      ; No: skip leading WS and try to parse
.3a3e7e	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3e81					skip_parse
.3a3e81	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a3e84	a7 00		lda [$0800]	                LDA [BIP]
.3a3e86	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.3a3e88	f0 4e		beq $3a3ed8	                BEQ read_string     ; Yes: process the string
.3a3e8a	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a3e8d	b0 4e		bcs $3a3edd	                BCS read_number     ; Yes: process the number
.3a3e8f					syntax_err
.3a3e8f	08		php		            PHP
.3a3e90	c2 20		rep #$20	            REP #$20
.3a3e92	48		pha		            PHA
.3a3e93	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e96	5b		tcd		            TCD
.3a3e97	68		pla		            PLA
.3a3e98	28		plp		            PLP
.3a3e99	e2 20		sep #$20	            SEP #$20
.3a3e9b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3e9d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ea1	c2 20		rep #$20	            REP #$20
.3a3ea3	29 ff 00	and #$00ff	            AND #$00FF
.3a3ea6	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3ea9	e2 20		sep #$20	            SEP #$20
.3a3eab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3eae					scan_start
.3a3eae	c2 20		rep #$20	            REP #$20
.3a3eb0	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.3a3eb3	85 1a		sta $081a	                STA CURLINE
.3a3eb5	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a3eb8	85 1c		sta $081c	                STA CURLINE+2
.3a3eba	18		clc		                CLC
.3a3ebb	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.3a3ebd	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a3ec0	85 00		sta $0800	                STA BIP
.3a3ec2	a5 1c		lda $081c	                LDA CURLINE+2
.3a3ec4	69 00 00	adc #$0000	                ADC #0
.3a3ec7	85 02		sta $0802	                STA BIP+2
.3a3ec9					scan_data
.3a3ec9	e2 20		sep #$20	            SEP #$20
.3a3ecb	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.3a3ecd	85 35		sta $0835	                STA SKIPNEST
.3a3ecf	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.3a3ed1	85 37		sta $0837	                STA TARGETTOK
.3a3ed3	20 c3 20	jsr $3a20c3	            JSR SKIPTOTOK
.3a3ed6	80 a9		bra $3a3e81	                BRA skip_parse
.3a3ed8					read_string
.3a3ed8	20 67 1b	jsr $3a1b67	            JSR EVALSTRING
.3a3edb	80 03		bra $3a3ee0	                BRA done
.3a3edd					read_number
.3a3edd	20 59 1a	jsr $3a1a59	            JSR EVALNUMBER
.3a3ee0					done
.3a3ee0	c2 20		rep #$20	            REP #$20
.3a3ee2	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.3a3ee4	85 38		sta $0838	                STA DATABIP
.3a3ee6	a5 02		lda $0802	                LDA BIP+2
.3a3ee8	85 3a		sta $083a	                STA DATABIP+2
.3a3eea	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.3a3eec	85 3c		sta $083c	                STA DATALINE
.3a3eee	a5 1c		lda $081c	                LDA CURLINE+2
.3a3ef0	85 3e		sta $083e	                STA DATALINE+2
.3a3ef2	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.3a3ef4	85 1a		sta $081a	                STA CURLINE
.3a3ef6	a5 46		lda $0846	                LDA SAVELINE+2
.3a3ef8	85 1c		sta $081c	                STA CURLINE+2
.3a3efa	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a3efc	85 00		sta $0800	                STA BIP
.3a3efe	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3f00	85 02		sta $0802	                STA BIP+2
.3a3f02	28		plp		                PLP
.3a3f03	60		rts		            RTS
.3a3f04					S_DATA
.3a3f04	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a3f07	60		rts		            RTS
.3a3f08					S_RESTORE
.3a3f08	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.3a3f0a	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.3a3f0c	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.3a3f0e	64 3e		stz $083e	                STZ DATALINE+2
.3a3f10	60		rts		            RTS
.3a3f11					S_CLS
.3a3f11	20 24 00	jsr $3a0024	            JSR CLSCREEN
.3a3f14	60		rts		            RTS
.3a3f15					S_POKEL
.3a3f15	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3f18	c2 20		rep #$20	            REP #$20
.3a3f1a	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3f1c	48		pha		                PHA
.3a3f1d	a5 23		lda $0823	                LDA ARGUMENT1
.3a3f1f	48		pha		                PHA
.3a3f20	e2 20		sep #$20	            SEP #$20
.3a3f22	a7 00		lda [$0800]	                LDA [BIP]
.3a3f24	c9 2c		cmp #$2c	                CMP #','
.3a3f26	d0 22		bne $3a3f4a	                BNE syntax_err
.3a3f28	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3f2b	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3f2e	c2 20		rep #$20	            REP #$20
.3a3f30	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a3f32	d0 35		bne $3a3f69	                BNE range_err
.3a3f34	68		pla		                PLA                 ; Pull the target address from the stack
.3a3f35	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3f37	68		pla		                PLA
.3a3f38	85 0a		sta $080a	                STA INDEX+2
.3a3f3a	c2 20		rep #$20	            REP #$20
.3a3f3c	a5 23		lda $0823	                LDA ARGUMENT1
.3a3f3e	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3f40	e2 20		sep #$20	            SEP #$20
.3a3f42	a0 02 00	ldy #$0002	                LDY #2
.3a3f45	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3f47	97 08		sta [$0808],y	                STA [INDEX],Y
.3a3f49	60		rts		            RTS
.3a3f4a					syntax_err
.3a3f4a	08		php		            PHP
.3a3f4b	c2 20		rep #$20	            REP #$20
.3a3f4d	48		pha		            PHA
.3a3f4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f51	5b		tcd		            TCD
.3a3f52	68		pla		            PLA
.3a3f53	28		plp		            PLP
.3a3f54	e2 20		sep #$20	            SEP #$20
.3a3f56	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3f58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f5c	c2 20		rep #$20	            REP #$20
.3a3f5e	29 ff 00	and #$00ff	            AND #$00FF
.3a3f61	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3f64	e2 20		sep #$20	            SEP #$20
.3a3f66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f69					range_err
.3a3f69	08		php		            PHP
.3a3f6a	c2 20		rep #$20	            REP #$20
.3a3f6c	48		pha		            PHA
.3a3f6d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f70	5b		tcd		            TCD
.3a3f71	68		pla		            PLA
.3a3f72	28		plp		            PLP
.3a3f73	e2 20		sep #$20	            SEP #$20
.3a3f75	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3f77	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f7b	c2 20		rep #$20	            REP #$20
.3a3f7d	29 ff 00	and #$00ff	            AND #$00FF
.3a3f80	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3f83	e2 20		sep #$20	            SEP #$20
.3a3f85	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f88					S_POKEW
.3a3f88	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3f8b	c2 20		rep #$20	            REP #$20
.3a3f8d	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3f8f	48		pha		                PHA
.3a3f90	a5 23		lda $0823	                LDA ARGUMENT1
.3a3f92	48		pha		                PHA
.3a3f93	e2 20		sep #$20	            SEP #$20
.3a3f95	a7 00		lda [$0800]	                LDA [BIP]
.3a3f97	c9 2c		cmp #$2c	                CMP #','
.3a3f99	d0 19		bne $3a3fb4	                BNE syntax_err
.3a3f9b	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a3f9e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3fa1	c2 20		rep #$20	            REP #$20
.3a3fa3	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3fa5	d0 2c		bne $3a3fd3	                BNE range_err
.3a3fa7	68		pla		                PLA                 ; Pull the target address from the stack
.3a3fa8	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3faa	68		pla		                PLA
.3a3fab	85 0a		sta $080a	                STA INDEX+2
.3a3fad	c2 20		rep #$20	            REP #$20
.3a3faf	a5 23		lda $0823	                LDA ARGUMENT1
.3a3fb1	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3fb3	60		rts		            RTS
.3a3fb4					syntax_err
.3a3fb4	08		php		            PHP
.3a3fb5	c2 20		rep #$20	            REP #$20
.3a3fb7	48		pha		            PHA
.3a3fb8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3fbb	5b		tcd		            TCD
.3a3fbc	68		pla		            PLA
.3a3fbd	28		plp		            PLP
.3a3fbe	e2 20		sep #$20	            SEP #$20
.3a3fc0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3fc2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3fc6	c2 20		rep #$20	            REP #$20
.3a3fc8	29 ff 00	and #$00ff	            AND #$00FF
.3a3fcb	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3fce	e2 20		sep #$20	            SEP #$20
.3a3fd0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3fd3					range_err
.3a3fd3	08		php		            PHP
.3a3fd4	c2 20		rep #$20	            REP #$20
.3a3fd6	48		pha		            PHA
.3a3fd7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3fda	5b		tcd		            TCD
.3a3fdb	68		pla		            PLA
.3a3fdc	28		plp		            PLP
.3a3fdd	e2 20		sep #$20	            SEP #$20
.3a3fdf	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3fe1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3fe5	c2 20		rep #$20	            REP #$20
.3a3fe7	29 ff 00	and #$00ff	            AND #$00FF
.3a3fea	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a3fed	e2 20		sep #$20	            SEP #$20
.3a3fef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3ff2					S_POKE
.3a3ff2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a3ff5	c2 20		rep #$20	            REP #$20
.3a3ff7	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3ff9	48		pha		                PHA
.3a3ffa	a5 23		lda $0823	                LDA ARGUMENT1
.3a3ffc	48		pha		                PHA
.3a3ffd	e2 20		sep #$20	            SEP #$20
.3a3fff	a7 00		lda [$0800]	                LDA [BIP]
.3a4001	c9 2c		cmp #$2c	                CMP #','
.3a4003	d0 1f		bne $3a4024	                BNE syntax_err
.3a4005	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4008	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a400b	e2 20		sep #$20	            SEP #$20
.3a400d	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.3a400f	d0 32		bne $3a4043	                BNE range_err
.3a4011	c2 20		rep #$20	            REP #$20
.3a4013	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4015	d0 2c		bne $3a4043	                BNE range_err
.3a4017	68		pla		                PLA                 ; Pull the target address from the stack
.3a4018	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a401a	68		pla		                PLA
.3a401b	85 0a		sta $080a	                STA INDEX+2
.3a401d	e2 20		sep #$20	            SEP #$20
.3a401f	a5 23		lda $0823	                LDA ARGUMENT1
.3a4021	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a4023	60		rts		            RTS
.3a4024					syntax_err
.3a4024	08		php		            PHP
.3a4025	c2 20		rep #$20	            REP #$20
.3a4027	48		pha		            PHA
.3a4028	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a402b	5b		tcd		            TCD
.3a402c	68		pla		            PLA
.3a402d	28		plp		            PLP
.3a402e	e2 20		sep #$20	            SEP #$20
.3a4030	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4032	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4036	c2 20		rep #$20	            REP #$20
.3a4038	29 ff 00	and #$00ff	            AND #$00FF
.3a403b	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a403e	e2 20		sep #$20	            SEP #$20
.3a4040	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4043					range_err
.3a4043	08		php		            PHP
.3a4044	c2 20		rep #$20	            REP #$20
.3a4046	48		pha		            PHA
.3a4047	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a404a	5b		tcd		            TCD
.3a404b	68		pla		            PLA
.3a404c	28		plp		            PLP
.3a404d	e2 20		sep #$20	            SEP #$20
.3a404f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4051	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4055	c2 20		rep #$20	            REP #$20
.3a4057	29 ff 00	and #$00ff	            AND #$00FF
.3a405a	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a405d	e2 20		sep #$20	            SEP #$20
.3a405f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4062					S_STOP
.3a4062	08		php		            PHP
.3a4063	c2 20		rep #$20	            REP #$20
.3a4065	48		pha		            PHA
.3a4066	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4069	5b		tcd		            TCD
.3a406a	68		pla		            PLA
.3a406b	28		plp		            PLP
.3a406c	e2 20		sep #$20	            SEP #$20
.3a406e	a9 01		lda #$01	            LDA #ERR_BREAK
.3a4070	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4074	c2 20		rep #$20	            REP #$20
.3a4076	29 ff 00	and #$00ff	            AND #$00FF
.3a4079	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a407c	e2 20		sep #$20	            SEP #$20
.3a407e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4081					S_REM
.3a4081	08		php		                PHP
.3a4082	e2 20		sep #$20	            SEP #$20
.3a4084	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.3a4086	f0 05		beq $3a408d	                BEQ done
.3a4088	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a408b	80 f7		bra $3a4084	                BRA rem_loop
.3a408d	28		plp		done            PLP
.3a408e	60		rts		            RTS
.3a408f					S_EXIT
.3a408f	08		php		                PHP
.3a4090	28		plp		                PLP
.3a4091	60		rts		            RTS
.3a4092					S_DO
.3a4092	08		php		                PHP
.3a4093	28		plp		                PLP
.3a4094	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.3a4095					S_LOOP
.3a4095	08		php		                PHP
.3a4096	28		plp		                PLP
.3a4097	60		rts		            RTS
.3a4098					S_FOR
.3a4098	08		php		                PHP
.3a4099	c2 20		rep #$20	            REP #$20
.3a409b	a5 1c		lda $081c	                LDA CURLINE+2
.3a409d	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a40a0	a5 1a		lda $081a	                LDA CURLINE
.3a40a2	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a40a5	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.3a40a7	48		pha		                PHA
.3a40a8	a5 00		lda $0800	                LDA BIP
.3a40aa	48		pha		                PHA
.3a40ab	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a40ae	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.3a40b0	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a40b3	a5 00		lda $0800	                LDA BIP
.3a40b5	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a40b8	68		pla		                PLA                 ; Restore the original BIP
.3a40b9	85 00		sta $0800	                STA BIP
.3a40bb	68		pla		                PLA
.3a40bc	85 02		sta $0802	                STA BIP+2
.3a40be	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a40c1					get_name
.3a40c1	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a40c4	b0 1f		bcs $3a40e5	                BCS push_name       ; If we didn't find a name, thrown an error
.3a40c6	08		php		            PHP
.3a40c7	c2 20		rep #$20	            REP #$20
.3a40c9	48		pha		            PHA
.3a40ca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a40cd	5b		tcd		            TCD
.3a40ce	68		pla		            PLA
.3a40cf	28		plp		            PLP
.3a40d0	e2 20		sep #$20	            SEP #$20
.3a40d2	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a40d4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a40d8	c2 20		rep #$20	            REP #$20
.3a40da	29 ff 00	and #$00ff	            AND #$00FF
.3a40dd	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a40e0	e2 20		sep #$20	            SEP #$20
.3a40e2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a40e5					push_name
.3a40e5	e2 20		sep #$20	            SEP #$20
.3a40e7	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.3a40e9	20 8b 1d	jsr $3a1d8b	            JSR PHRETURNB
.3a40ec	a5 e9		lda $08e9	                LDA TOFIND+2
.3a40ee	20 8b 1d	jsr $3a1d8b	            JSR PHRETURNB
.3a40f1	c2 20		rep #$20	            REP #$20
.3a40f3	a5 e7		lda $08e7	                LDA TOFIND
.3a40f5	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a40f8					else
.3a40f8	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a40fb	e2 20		sep #$20	            SEP #$20
.3a40fd	a7 00		lda [$0800]	                LDA [BIP]
.3a40ff	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a4101	d0 6a		bne $3a416d	                BNE syntax_err      ; If not found: signal an syntax error
.3a4103	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.3a4105	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.3a4107	f0 04		beq $3a410d	                BEQ process_initial ; Yes: it's ok
.3a4109	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.3a410b	f0 00		beq $3a410d	                BEQ process_initial ; Yes: it's ok
.3a410d					process_initial
.3a410d	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4110	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4113	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a4116	e2 20		sep #$20	            SEP #$20
.3a4118	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.3a411a	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a411d	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4120	c2 20		rep #$20	            REP #$20
.3a4122	a5 27		lda $0827	                LDA ARGTYPE1
.3a4124	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4127	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4129	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a412c	a5 23		lda $0823	                LDA ARGUMENT1
.3a412e	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4131	e2 20		sep #$20	            SEP #$20
.3a4133	a9 9d		lda #$9d	                LDA #TOK_STEP
.3a4135	85 37		sta $0837	                STA TARGETTOK
.3a4137	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a413a	90 1b		bcc $3a4157	                BCC default_inc     ; Not found: set a default increment of 1
.3a413c	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a413f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4142	e2 20		sep #$20	            SEP #$20
.3a4144	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.3a4146	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4149	c2 20		rep #$20	            REP #$20
.3a414b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a414d	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4150	a5 23		lda $0823	                LDA ARGUMENT1
.3a4152	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4155	80 14		bra $3a416b	                BRA done
.3a4157					default_inc
.3a4157	c2 20		rep #$20	            REP #$20
.3a4159	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.3a415c	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a415f	a9 00 00	lda #$0000	                LDA #0
.3a4162	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4165	a9 01 00	lda #$0001	                LDA #1
.3a4168	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a416b	28		plp		done            PLP
.3a416c	60		rts		            RTS
.3a416d					syntax_err
.3a416d	08		php		            PHP
.3a416e	c2 20		rep #$20	            REP #$20
.3a4170	48		pha		            PHA
.3a4171	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4174	5b		tcd		            TCD
.3a4175	68		pla		            PLA
.3a4176	28		plp		            PLP
.3a4177	e2 20		sep #$20	            SEP #$20
.3a4179	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a417b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a417f	c2 20		rep #$20	            REP #$20
.3a4181	29 ff 00	and #$00ff	            AND #$00FF
.3a4184	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4187	e2 20		sep #$20	            SEP #$20
.3a4189	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.3a418c					S_NEXT
.3a418c	08		php		                PHP
.3a418d	8b		phb		                PHB
.3a418e	08		php		            PHP
.3a418f	e2 20		sep #$20	            SEP #$20
.3a4191	48		pha		            PHA
.3a4192	a9 00		lda #$00	            LDA #0
.3a4194	48		pha		            PHA
.3a4195	ab		plb		            PLB
.3a4196	68		pla		            PLA
.3a4197	28		plp		            PLP
.3a4198	08		php		            PHP
.3a4199	c2 20		rep #$20	            REP #$20
.3a419b	48		pha		            PHA
.3a419c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a419f	5b		tcd		            TCD
.3a41a0	68		pla		            PLA
.3a41a1	28		plp		            PLP
.3a41a2	c2 30		rep #$30	            REP #$30
.3a41a4	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.3a41a6	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.3a41a7	c8		iny		                INY
.3a41a8	c2 20		rep #$20	            REP #$20
.3a41aa	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.3a41ad	85 e7		sta $08e7	                STA TOFIND
.3a41af	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.3a41b2	e2 20		sep #$20	            SEP #$20
.3a41b4	85 e9		sta $08e9	                STA TOFIND+2
.3a41b6	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.3a41b9	85 ea		sta $08ea	                STA TOFINDTYPE
.3a41bb	c2 20		rep #$20	            REP #$20
.3a41bd	5a		phy		                PHY
.3a41be	20 c8 50	jsr $3a50c8	            JSR VAR_REF
.3a41c1	7a		ply		                PLY
.3a41c2	c2 20		rep #$20	            REP #$20
.3a41c4	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.3a41c7	85 29		sta $0829	                STA ARGUMENT2
.3a41c9	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.3a41cc	85 2b		sta $082b	                STA ARGUMENT2+2
.3a41ce	e2 20		sep #$20	            SEP #$20
.3a41d0	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.3a41d3	85 2d		sta $082d	                STA ARGTYPE2
.3a41d5	c2 20		rep #$20	            REP #$20
.3a41d7	5a		phy		                PHY
.3a41d8	20 32 27	jsr $3a2732	            JSR OP_PLUS
.3a41db	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a41de	7a		ply		                PLY
.3a41df	c2 20		rep #$20	            REP #$20
.3a41e1	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.3a41e4	85 29		sta $0829	                STA ARGUMENT2
.3a41e6	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.3a41e9	85 2b		sta $082b	                STA ARGUMENT2+2
.3a41eb	e2 20		sep #$20	            SEP #$20
.3a41ed	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.3a41f0	85 2d		sta $082d	                STA ARGTYPE2
.3a41f2	c2 20		rep #$20	            REP #$20
.3a41f4	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.3a41f7	30 0a		bmi $3a4203	                BMI going_down
.3a41f9					going_up
.3a41f9	20 bb 29	jsr $3a29bb	            JSR OP_LTE
.3a41fc	20 6e 05	jsr $3a056e	            JSR IS_ARG1_Z
.3a41ff	f0 28		beq $3a4229	                BEQ end_loop                    ; No: end the loop
.3a4201	80 08		bra $3a420b	                BRA loop_back                   ; Yes: loop back
.3a4203					going_down
.3a4203	20 7b 29	jsr $3a297b	            JSR OP_GTE
.3a4206	20 6e 05	jsr $3a056e	            JSR IS_ARG1_Z
.3a4209	f0 1e		beq $3a4229	                BEQ end_loop                    ; No: end the loop
.3a420b					loop_back
.3a420b	c2 20		rep #$20	            REP #$20
.3a420d	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.3a4210	85 00		sta $0800	                STA BIP
.3a4212	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.3a4215	85 02		sta $0802	                STA BIP+2
.3a4217	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.3a421a	85 1a		sta $081a	                STA CURLINE
.3a421c	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.3a421f	85 1c		sta $081c	                STA CURLINE+2
.3a4221	e2 20		sep #$20	            SEP #$20
.3a4223	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a4225	85 dc		sta $08dc	                STA EXECACTION
.3a4227	80 17		bra $3a4240	                BRA done
.3a4229					end_loop
.3a4229	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.3a422c	20 38 19	jsr $3a1938	            JSR PLARGUMENT
.3a422f	c2 20		rep #$20	            REP #$20
.3a4231	18		clc		                CLC
.3a4232	a5 33		lda $0833	                LDA RETURNSP
.3a4234	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.3a4237	85 33		sta $0833	                STA RETURNSP
.3a4239	a5 35		lda $0835	                LDA RETURNSP+2
.3a423b	69 00 00	adc #$0000	                ADC #0
.3a423e	85 35		sta $0835	                STA RETURNSP+2
.3a4240	ab		plb		done            PLB
.3a4241	28		plp		                PLP
.3a4242	60		rts		            RTS
.3a4243					S_GOSUB
.3a4243	08		php		                PHP
.3a4244	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.3a4246	48		pha		                PHA
.3a4247	a5 1c		lda $081c	                LDA CURLINE+2
.3a4249	48		pha		                PHA
.3a424a	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a424d	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4250	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a4252	f0 26		beq $3a427a	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a4254	20 6c 23	jsr $3a236c	            JSR FINDLINE
.3a4257	90 42		bcc $3a429b	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4259	e2 20		sep #$20	            SEP #$20
.3a425b	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a425d	85 dc		sta $08dc	                STA EXECACTION
.3a425f	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a4262	c2 20		rep #$20	            REP #$20
.3a4264	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.3a4265	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4268	68		pla		                PLA
.3a4269	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a426c	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.3a426e	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4271	a5 00		lda $0800	                LDA BIP
.3a4273	20 74 1d	jsr $3a1d74	            JSR PHRETURN
.3a4276	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.3a4278	28		plp		                PLP
.3a4279	60		rts		            RTS
.3a427a	68		pla		syntax_err      PLA
.3a427b	68		pla		                PLA
.3a427c	08		php		            PHP
.3a427d	c2 20		rep #$20	            REP #$20
.3a427f	48		pha		            PHA
.3a4280	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4283	5b		tcd		            TCD
.3a4284	68		pla		            PLA
.3a4285	28		plp		            PLP
.3a4286	e2 20		sep #$20	            SEP #$20
.3a4288	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a428a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a428e	c2 20		rep #$20	            REP #$20
.3a4290	29 ff 00	and #$00ff	            AND #$00FF
.3a4293	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4296	e2 20		sep #$20	            SEP #$20
.3a4298	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a429b	68		pla		not_found       PLA
.3a429c	68		pla		                PLA
.3a429d	08		php		            PHP
.3a429e	c2 20		rep #$20	            REP #$20
.3a42a0	48		pha		            PHA
.3a42a1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a42a4	5b		tcd		            TCD
.3a42a5	68		pla		            PLA
.3a42a6	28		plp		            PLP
.3a42a7	e2 20		sep #$20	            SEP #$20
.3a42a9	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a42ab	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a42af	c2 20		rep #$20	            REP #$20
.3a42b1	29 ff 00	and #$00ff	            AND #$00FF
.3a42b4	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a42b7	e2 20		sep #$20	            SEP #$20
.3a42b9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a42bc					S_RETURN
.3a42bc	08		php		                PHP
.3a42bd	c2 30		rep #$30	            REP #$30
.3a42bf	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.3a42c1	f0 1e		beq $3a42e1	                BEQ underflow               ; No? It's a stack underflow error
.3a42c3	20 96 1d	jsr $3a1d96	            JSR PLRETURN
.3a42c6	85 00		sta $0800	                STA BIP
.3a42c8	20 96 1d	jsr $3a1d96	            JSR PLRETURN
.3a42cb	85 02		sta $0802	                STA BIP+2
.3a42cd	20 96 1d	jsr $3a1d96	            JSR PLRETURN
.3a42d0	85 1a		sta $081a	                STA CURLINE
.3a42d2	20 96 1d	jsr $3a1d96	            JSR PLRETURN
.3a42d5	85 1c		sta $081c	                STA CURLINE+2
.3a42d7	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.3a42d9	e2 20		sep #$20	            SEP #$20
.3a42db	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a42dd	85 dc		sta $08dc	                STA EXECACTION
.3a42df	28		plp		                PLP
.3a42e0	60		rts		            RTS
.3a42e1					underflow
.3a42e1	08		php		            PHP
.3a42e2	c2 20		rep #$20	            REP #$20
.3a42e4	48		pha		            PHA
.3a42e5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a42e8	5b		tcd		            TCD
.3a42e9	68		pla		            PLA
.3a42ea	28		plp		            PLP
.3a42eb	e2 20		sep #$20	            SEP #$20
.3a42ed	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.3a42ef	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a42f3	c2 20		rep #$20	            REP #$20
.3a42f5	29 ff 00	and #$00ff	            AND #$00FF
.3a42f8	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a42fb	e2 20		sep #$20	            SEP #$20
.3a42fd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4300					S_IF
.3a4300	08		php		                PHP
.3a4301	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4304	20 6e 05	jsr $3a056e	            JSR IS_ARG1_Z
.3a4307	f0 1c		beq $3a4325	                BEQ is_false                ; If so, handle the FALSE case
.3a4309	e2 20		sep #$20	            SEP #$20
.3a430b	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.3a430d	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4310	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4313	20 6e 05	jsr $3a056e	            JSR IS_ARG1_Z
.3a4316	f0 12		beq $3a432a	                BEQ syntax_err              ; If not, we have a syntax error
.3a4318	20 6c 23	jsr $3a236c	            JSR FINDLINE
.3a431b	90 2c		bcc $3a4349	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a431d	e2 20		sep #$20	            SEP #$20
.3a431f	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4321	85 dc		sta $08dc	                STA EXECACTION
.3a4323	80 03		bra $3a4328	                BRA done
.3a4325					is_false
.3a4325	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a4328	28		plp		done            PLP
.3a4329	60		rts		            RTS
.3a432a					syntax_err
.3a432a	08		php		            PHP
.3a432b	c2 20		rep #$20	            REP #$20
.3a432d	48		pha		            PHA
.3a432e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4331	5b		tcd		            TCD
.3a4332	68		pla		            PLA
.3a4333	28		plp		            PLP
.3a4334	e2 20		sep #$20	            SEP #$20
.3a4336	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4338	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a433c	c2 20		rep #$20	            REP #$20
.3a433e	29 ff 00	and #$00ff	            AND #$00FF
.3a4341	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4344	e2 20		sep #$20	            SEP #$20
.3a4346	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4349					not_found
.3a4349	08		php		            PHP
.3a434a	c2 20		rep #$20	            REP #$20
.3a434c	48		pha		            PHA
.3a434d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4350	5b		tcd		            TCD
.3a4351	68		pla		            PLA
.3a4352	28		plp		            PLP
.3a4353	e2 20		sep #$20	            SEP #$20
.3a4355	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4357	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a435b	c2 20		rep #$20	            REP #$20
.3a435d	29 ff 00	and #$00ff	            AND #$00FF
.3a4360	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4363	e2 20		sep #$20	            SEP #$20
.3a4365	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4368					S_END
.3a4368	08		php		                PHP
.3a4369	e2 20		sep #$20	            SEP #$20
.3a436b	a9 01		lda #$01	                LDA #EXEC_STOP
.3a436d	85 dc		sta $08dc	                STA EXECACTION
.3a436f	28		plp		                PLP
.3a4370	60		rts		            RTS
.3a4371					S_GOTO
.3a4371	08		php		                PHP
.3a4372	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4375	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4378	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a437a	f0 0d		beq $3a4389	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a437c	20 6c 23	jsr $3a236c	            JSR FINDLINE
.3a437f	90 27		bcc $3a43a8	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4381	e2 20		sep #$20	            SEP #$20
.3a4383	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4385	85 dc		sta $08dc	                STA EXECACTION
.3a4387	28		plp		                PLP
.3a4388	60		rts		            RTS
.3a4389					syntax_err
.3a4389	08		php		            PHP
.3a438a	c2 20		rep #$20	            REP #$20
.3a438c	48		pha		            PHA
.3a438d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4390	5b		tcd		            TCD
.3a4391	68		pla		            PLA
.3a4392	28		plp		            PLP
.3a4393	e2 20		sep #$20	            SEP #$20
.3a4395	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4397	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a439b	c2 20		rep #$20	            REP #$20
.3a439d	29 ff 00	and #$00ff	            AND #$00FF
.3a43a0	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a43a3	e2 20		sep #$20	            SEP #$20
.3a43a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43a8					not_found
.3a43a8	08		php		            PHP
.3a43a9	c2 20		rep #$20	            REP #$20
.3a43ab	48		pha		            PHA
.3a43ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a43af	5b		tcd		            TCD
.3a43b0	68		pla		            PLA
.3a43b1	28		plp		            PLP
.3a43b2	e2 20		sep #$20	            SEP #$20
.3a43b4	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a43b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a43ba	c2 20		rep #$20	            REP #$20
.3a43bc	29 ff 00	and #$00ff	            AND #$00FF
.3a43bf	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a43c2	e2 20		sep #$20	            SEP #$20
.3a43c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43c7					S_CLR
.3a43c7	20 da 18	jsr $3a18da	            JSR INITEVALSP
.3a43ca	20 fa 0f	jsr $3a0ffa	            JSR INITHEAP
.3a43cd	20 c7 4f	jsr $3a4fc7	            JSR INITVARS
.3a43d0	60		rts		            RTS
.3a43d1					S_LET
.3a43d1	08		php		                PHP
.3a43d2	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a43d4	10 03		bpl $3a43d9	                BPL get_name        ; If it's not a token, try to find the variable name
.3a43d6	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a43d9					get_name
.3a43d9	20 c7 52	jsr $3a52c7	            JSR VAR_FINDNAME
.3a43dc	b0 03		bcs $3a43e1	                BCS check_array     ; If we didn't find a name, thrown an error
.3a43de	4c 48 44	jmp $3a4448	                JMP syntax_err
.3a43e1					check_array
.3a43e1	e2 20		sep #$20	            SEP #$20
.3a43e3	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.3a43e5	48		pha		                PHA                 ; (it will get over-written by variable references)
.3a43e6	a5 e9		lda $08e9	                LDA TOFIND+2
.3a43e8	48		pha		                PHA
.3a43e9	a5 e8		lda $08e8	                LDA TOFIND+1
.3a43eb	48		pha		                PHA
.3a43ec	a5 e7		lda $08e7	                LDA TOFIND
.3a43ee	48		pha		                PHA
.3a43ef	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a43f2	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.3a43f4	d0 0e		bne $3a4404	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.3a43f6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a43f8	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a43fb	a9 00		lda #$00	                LDA #0
.3a43fd	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.3a4401	20 5c 1a	jsr $3a1a5c	            JSR ARR_GETIDX
.3a4404					get_value
.3a4404	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4407	e2 20		sep #$20	            SEP #$20
.3a4409	a7 00		lda [$0800]	                LDA [BIP]
.3a440b	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a440d	f0 03		beq $3a4412	                BEQ found_eq        ; If not found: signal an syntax error
.3a440f	4c 48 44	jmp $3a4448	                JMP syntax_err
.3a4412					found_eq
.3a4412	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4415	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4418	68		pla		                PLA                 ; Restore the variable name
.3a4419	85 e7		sta $08e7	                STA TOFIND
.3a441b	68		pla		                PLA
.3a441c	85 e8		sta $08e8	                STA TOFIND+1
.3a441e	68		pla		                PLA
.3a441f	85 e9		sta $08e9	                STA TOFIND+2
.3a4421	68		pla		                PLA
.3a4422	85 ea		sta $08ea	                STA TOFINDTYPE
.3a4424	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.3a4426	f0 1b		beq $3a4443	                BEQ set_scalar      ; No: do a scalar variable set
.3a4428	20 3a 50	jsr $3a503a	            JSR VAR_FIND
.3a442b	90 3a		bcc $3a4467	                BCC notfound_err
.3a442d	c2 20		rep #$20	            REP #$20
.3a442f	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a4432	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a4434	85 c0		sta $08c0	                STA CURRBLOCK
.3a4436	e2 20		sep #$20	            SEP #$20
.3a4438	c8		iny		                INY
.3a4439	c8		iny		                INY
.3a443a	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a443c	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a443e	20 31 67	jsr $3a6731	            JSR ARR_SET
.3a4441	80 03		bra $3a4446	                BRA done            ; and we're finished!
.3a4443					set_scalar
.3a4443	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a4446					done
.3a4446	28		plp		                PLP
.3a4447	60		rts		            RTS
.3a4448					syntax_err
.3a4448	08		php		            PHP
.3a4449	c2 20		rep #$20	            REP #$20
.3a444b	48		pha		            PHA
.3a444c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a444f	5b		tcd		            TCD
.3a4450	68		pla		            PLA
.3a4451	28		plp		            PLP
.3a4452	e2 20		sep #$20	            SEP #$20
.3a4454	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4456	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a445a	c2 20		rep #$20	            REP #$20
.3a445c	29 ff 00	and #$00ff	            AND #$00FF
.3a445f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4462	e2 20		sep #$20	            SEP #$20
.3a4464	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4467					notfound_err
.3a4467	08		php		            PHP
.3a4468	c2 20		rep #$20	            REP #$20
.3a446a	48		pha		            PHA
.3a446b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a446e	5b		tcd		            TCD
.3a446f	68		pla		            PLA
.3a4470	28		plp		            PLP
.3a4471	e2 20		sep #$20	            SEP #$20
.3a4473	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a4475	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4479	c2 20		rep #$20	            REP #$20
.3a447b	29 ff 00	and #$00ff	            AND #$00FF
.3a447e	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4481	e2 20		sep #$20	            SEP #$20
.3a4483	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4486					S_PRINT
.3a4486	08		php		                PHP
.3a4487	e2 20		sep #$20	            SEP #$20
.3a4489	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a448c	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.3a448e	f0 6d		beq $3a44fd	                BEQ pr_nl_exit      ; Yes: just print return
.3a4490					pr_loop
.3a4490	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4493	e2 20		sep #$20	            SEP #$20
.3a4495	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.3a4497	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.3a4499	f0 1b		beq $3a44b6	                BEQ check_nl        ; Yes: we are probably just printing a newline
.3a449b	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.3a449d	d0 05		bne $3a44a4	                BNE check_int       ; No: check to see if it's an integer
.3a449f	20 02 45	jsr $3a4502	            JSR PR_STRING
.3a44a2	80 12		bra $3a44b6	                BRA check_nl
.3a44a4	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.3a44a6	d0 05		bne $3a44ad	                BNE check_float     ; No: check to see if it is a float
.3a44a8	20 20 45	jsr $3a4520	            JSR PR_INTEGER
.3a44ab	80 09		bra $3a44b6	                BRA check_nl
.3a44ad	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.3a44af	d0 4f		bne $3a4500	                BNE done            ; No: just quit
.3a44b1	20 33 45	jsr $3a4533	            JSR PR_FLOAT
.3a44b4	80 00		bra $3a44b6	                BRA check_nl
.3a44b6					check_nl
.3a44b6	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a44b9	a7 00		lda [$0800]	                LDA [BIP]
.3a44bb	f0 40		beq $3a44fd	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.3a44bd	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a44bf	f0 3c		beq $3a44fd	                BEQ pr_nl_exit      ; print a newline and return
.3a44c1	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.3a44c3	f0 23		beq $3a44e8	                BEQ pr_comma        ; Print a TAB and try another expression
.3a44c5	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.3a44c7	f0 24		beq $3a44ed	                BEQ is_more         ; Print nothing, and try another expression
.3a44c9	08		php		            PHP
.3a44ca	c2 20		rep #$20	            REP #$20
.3a44cc	48		pha		            PHA
.3a44cd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a44d0	5b		tcd		            TCD
.3a44d1	68		pla		            PLA
.3a44d2	28		plp		            PLP
.3a44d3	e2 20		sep #$20	            SEP #$20
.3a44d5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a44d7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a44db	c2 20		rep #$20	            REP #$20
.3a44dd	29 ff 00	and #$00ff	            AND #$00FF
.3a44e0	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a44e3	e2 20		sep #$20	            SEP #$20
.3a44e5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a44e8	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.3a44ea	20 18 00	jsr $3a0018	            JSR PRINTC
.3a44ed					is_more
.3a44ed	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a44f0	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a44f3	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a44f5	f0 09		beq $3a4500	                BEQ done            ; If it's NULL, return without printing a newline
.3a44f7	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a44f9	f0 05		beq $3a4500	                BEQ done            ; ... return without printing a newline
.3a44fb	80 93		bra $3a4490	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.3a44fd					pr_nl_exit
.3a44fd	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a4500	28		plp		done            PLP
.3a4501	60		rts		            RTS
.3a4502					PR_STRING
.3a4502	08		php		                PHP
.3a4503	8b		phb		                PHB
.3a4504	08		php		            PHP
.3a4505	c2 20		rep #$20	            REP #$20
.3a4507	48		pha		            PHA
.3a4508	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a450b	5b		tcd		            TCD
.3a450c	68		pla		            PLA
.3a450d	28		plp		            PLP
.3a450e	e2 20		sep #$20	            SEP #$20
.3a4510	a0 00 00	ldy #$0000	start_print     LDY #0
.3a4513	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.3a4515	f0 06		beq $3a451d	                BEQ done
.3a4517	20 18 00	jsr $3a0018	            JSR PRINTC
.3a451a	c8		iny		                INY
.3a451b	80 f6		bra $3a4513	                BRA loop
.3a451d	ab		plb		done            PLB
.3a451e	28		plp		                PLP
.3a451f	60		rts		            RTS
.3a4520					PR_INTEGER
.3a4520	08		php		                PHP
.3a4521	c2 20		rep #$20	            REP #$20
.3a4523	20 af 14	jsr $3a14af	            JSR ITOS
.3a4526	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a4528	85 23		sta $0823	                STA ARGUMENT1
.3a452a	a5 18		lda $0818	                LDA STRPTR+2
.3a452c	85 25		sta $0825	                STA ARGUMENT1+2
.3a452e	20 02 45	jsr $3a4502	            JSR PR_STRING
.3a4531	28		plp		                PLP
.3a4532	60		rts		            RTS
.3a4533					PR_FLOAT
.3a4533	08		php		                PHP
.3a4534	20 90 5c	jsr $3a5c90	            JSR FTOS
.3a4537	c2 20		rep #$20	            REP #$20
.3a4539	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a453b	85 23		sta $0823	                STA ARGUMENT1
.3a453d	a5 18		lda $0818	                LDA STRPTR+2
.3a453f	85 25		sta $0825	                STA ARGUMENT1+2
.3a4541	20 02 45	jsr $3a4502	            JSR PR_STRING
.3a4544	28		plp		                PLP
.3a4545	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.3a4546					BCD2STR
.3a4546	08		php		            PHP
.3a4547	e2 20		sep #$20	            SEP #$20
.3a4549	85 b5		sta $08b5	            STA SAVE_A
.3a454b	4a		lsr a		            LSR A
.3a454c	4a		lsr a		            LSR A
.3a454d	4a		lsr a		            LSR A
.3a454e	4a		lsr a		            LSR A
.3a454f	29 0f		and #$0f	            AND #$0F
.3a4551	18		clc		            CLC
.3a4552	69 30		adc #$30	            ADC #'0'
.3a4554	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4556	c8		iny		            INY
.3a4557	a5 b5		lda $08b5	            LDA SAVE_A
.3a4559	29 0f		and #$0f	            AND #$0F
.3a455b	18		clc		            CLC
.3a455c	69 30		adc #$30	            ADC #'0'
.3a455e	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4560	c8		iny		            INY
.3a4561	28		plp		            PLP
.3a4562	60		rts		            RTS
.3a4563					F_GETDATE
.3a4563	e2 20		sep #$20	            SEP #$20
.3a4565	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4567	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a456a	08		php		            PHP
.3a456b	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a456e	e2 20		sep #$20	            SEP #$20
.3a4570	c2 10		rep #$10	            REP #$10
.3a4572	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a4576	09 08		ora #$08	            ORA #%00001000
.3a4578	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a457c	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a457f	a0 00 00	ldy #$0000	            LDY #0
.3a4582	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.3a4586	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a4589	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a458b	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a458d	c8		iny		            INY
.3a458e	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.3a4592	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a4595	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4597	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4599	c8		iny		            INY
.3a459a	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.3a459e	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a45a1	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.3a45a5	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a45a8	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a45aa	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a45ac	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a45b0	29 f7		and #$f7	            AND #%11110111
.3a45b2	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a45b6	c2 20		rep #$20	            REP #$20
.3a45b8	a5 16		lda $0816	            LDA STRPTR
.3a45ba	85 23		sta $0823	            STA ARGUMENT1
.3a45bc	a5 18		lda $0818	            LDA STRPTR+2
.3a45be	85 25		sta $0825	            STA ARGUMENT1+2
.3a45c0	e2 20		sep #$20	            SEP #$20
.3a45c2	a9 02		lda #$02	            LDA #TYPE_STRING
.3a45c4	85 27		sta $0827	            STA ARGTYPE1
.3a45c6	28		plp		            PLP
.3a45c7	e2 20		sep #$20	            SEP #$20
.3a45c9	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a45cc	60		rts		            RTS
.3a45cd					F_GETTIME
.3a45cd	e2 20		sep #$20	            SEP #$20
.3a45cf	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a45d1	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a45d4	08		php		            PHP
.3a45d5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a45d8	e2 20		sep #$20	            SEP #$20
.3a45da	c2 10		rep #$10	            REP #$10
.3a45dc	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a45e0	09 08		ora #$08	            ORA #%00001000
.3a45e2	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a45e6	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a45e9	a0 00 00	ldy #$0000	            LDY #0
.3a45ec	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.3a45f0	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.3a45f2	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a45f5	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a45f7	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a45f9	c8		iny		            INY
.3a45fa	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.3a45fe	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a4601	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a4603	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4605	c8		iny		            INY
.3a4606	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.3a460a	20 46 45	jsr $3a4546	            JSR BCD2STR
.3a460d	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a460f	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4611	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a4615	29 f7		and #$f7	            AND #%11110111
.3a4617	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a461b	c2 20		rep #$20	            REP #$20
.3a461d	a5 16		lda $0816	            LDA STRPTR
.3a461f	85 23		sta $0823	            STA ARGUMENT1
.3a4621	a5 18		lda $0818	            LDA STRPTR+2
.3a4623	85 25		sta $0825	            STA ARGUMENT1+2
.3a4625	e2 20		sep #$20	            SEP #$20
.3a4627	a9 02		lda #$02	            LDA #TYPE_STRING
.3a4629	85 27		sta $0827	            STA ARGTYPE1
.3a462b	28		plp		            PLP
.3a462c	e2 20		sep #$20	            SEP #$20
.3a462e	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4631	60		rts		            RTS
.3a4632					FN_RND
.3a4632	e2 20		sep #$20	            SEP #$20
.3a4634	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4636	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4639	08		php		            PHP
.3a463a	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a463d	e2 20		sep #$20	            SEP #$20
.3a463f	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.3a4641	85 27		sta $0827	            STA ARGTYPE1
.3a4643	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a4645	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.3a4649	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.3a464b	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.3a464f	c2 30		rep #$30	            REP #$30
.3a4651	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.3a4655	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.3a4659	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.3a465d	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.3a4660	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.3a4664	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.3a4667	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.3a466b	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.3a466e	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.3a4672	ea		nop		            NOP
.3a4673	ea		nop		            NOP
.3a4674	ea		nop		            NOP
.3a4675	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.3a4679	85 23		sta $0823	            STA ARGUMENT1
.3a467b	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.3a467f	85 25		sta $0825	            STA ARGUMENT1+2
.3a4681	28		plp		            PLP
.3a4682	e2 20		sep #$20	            SEP #$20
.3a4684	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4687	60		rts		            RTS

;******  Return to file: src\functions.s

.3a4688					FN_MID
.3a4688	e2 20		sep #$20	            SEP #$20
.3a468a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a468c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a468f	08		php		                PHP
.3a4690	c2 30		rep #$30	            REP #$30
.3a4692	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4695	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a4698					save_string
.3a4698	c2 20		rep #$20	            REP #$20
.3a469a	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a469c	48		pha		                PHA
.3a469d	a5 23		lda $0823	                LDA ARGUMENT1
.3a469f	48		pha		                PHA
.3a46a0	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a46a3	e2 20		sep #$20	            SEP #$20
.3a46a5	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a46a7	c9 2c		cmp #$2c	                CMP #','
.3a46a9	f0 03		beq $3a46ae	                BEQ skip_comma1
.3a46ab	4c ff 46	jmp $3a46ff	                JMP syntax_err
.3a46ae					skip_comma1
.3a46ae	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a46b1	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a46b4	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a46b7	c2 20		rep #$20	            REP #$20
.3a46b9	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.3a46bb	48		pha		                PHA
.3a46bc	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a46bf	e2 20		sep #$20	            SEP #$20
.3a46c1	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a46c3	c9 2c		cmp #$2c	                CMP #','
.3a46c5	f0 03		beq $3a46ca	                BEQ skip_comma2
.3a46c7	4c ff 46	jmp $3a46ff	                JMP syntax_err
.3a46ca					skip_comma2
.3a46ca	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a46cd	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a46d0	20 61 06	jsr $3a0661	            JSR ASS_ARG1_INT16
.3a46d3	c2 20		rep #$20	            REP #$20
.3a46d5	a5 23		lda $0823	            LDA ARGUMENT1
.3a46d7	85 8f		sta $088f	            STA MCOUNT
.3a46d9	e2 20		sep #$20	            SEP #$20
.3a46db	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a46dd	85 91		sta $0891	            STA MCOUNT+2
.3a46df	c2 20		rep #$20	            REP #$20
.3a46e1	68		pla		                PLA                         ; Restore index
.3a46e2	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.3a46e4	a9 00 00	lda #$0000	                LDA #0
.3a46e7	85 2b		sta $082b	                STA ARGUMENT2+2
.3a46e9	68		pla		                PLA                         ; Restore string
.3a46ea	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.3a46ec	68		pla		                PLA
.3a46ed	85 25		sta $0825	                STA ARGUMENT1+2
.3a46ef	e2 20		sep #$20	            SEP #$20
.3a46f1	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a46f3	85 27		sta $0827	            STA ARGTYPE1
.3a46f5	20 a8 16	jsr $3a16a8	            JSR STRSUBSTR
.3a46f8					done
.3a46f8	e2 20		sep #$20	            SEP #$20
.3a46fa	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a46fd	28		plp		                PLP
.3a46fe	60		rts		            RTS
.3a46ff					syntax_err
.3a46ff	08		php		            PHP
.3a4700	c2 20		rep #$20	            REP #$20
.3a4702	48		pha		            PHA
.3a4703	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4706	5b		tcd		            TCD
.3a4707	68		pla		            PLA
.3a4708	28		plp		            PLP
.3a4709	e2 20		sep #$20	            SEP #$20
.3a470b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a470d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4711	c2 20		rep #$20	            REP #$20
.3a4713	29 ff 00	and #$00ff	            AND #$00FF
.3a4716	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4719	e2 20		sep #$20	            SEP #$20
.3a471b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a471e					range_err
.3a471e	08		php		            PHP
.3a471f	c2 20		rep #$20	            REP #$20
.3a4721	48		pha		            PHA
.3a4722	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4725	5b		tcd		            TCD
.3a4726	68		pla		            PLA
.3a4727	28		plp		            PLP
.3a4728	e2 20		sep #$20	            SEP #$20
.3a472a	a9 09		lda #$09	            LDA #ERR_RANGE
.3a472c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4730	c2 20		rep #$20	            REP #$20
.3a4732	29 ff 00	and #$00ff	            AND #$00FF
.3a4735	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4738	e2 20		sep #$20	            SEP #$20
.3a473a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a473d					FN_RIGHT
.3a473d	e2 20		sep #$20	            SEP #$20
.3a473f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4741	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4744	08		php		                PHP
.3a4745	c2 30		rep #$30	            REP #$30
.3a4747	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a474a	e2 20		sep #$20	            SEP #$20
.3a474c	a5 27		lda $0827	                LDA ARGTYPE1
.3a474e	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4750	f0 03		beq $3a4755	                BEQ save_string
.3a4752	4c c1 47	jmp $3a47c1	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4755					save_string
.3a4755	c2 20		rep #$20	            REP #$20
.3a4757	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a4759	48		pha		                PHA
.3a475a	a5 23		lda $0823	                LDA ARGUMENT1
.3a475c	48		pha		                PHA
.3a475d	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4760	e2 20		sep #$20	            SEP #$20
.3a4762	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4764	c9 2c		cmp #$2c	                CMP #','
.3a4766	f0 03		beq $3a476b	                BEQ skip_comma
.3a4768	4c e0 47	jmp $3a47e0	                JMP syntax_err
.3a476b					skip_comma
.3a476b	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a476e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4771	e2 20		sep #$20	            SEP #$20
.3a4773	a5 27		lda $0827	                LDA ARGTYPE1
.3a4775	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4777	d0 48		bne $3a47c1	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a4779	c2 20		rep #$20	            REP #$20
.3a477b	a5 23		lda $0823	            LDA ARGUMENT1
.3a477d	85 8f		sta $088f	            STA MCOUNT
.3a477f	c2 20		rep #$20	            REP #$20
.3a4781	68		pla		                PLA                         ; Recover the string pointer
.3a4782	85 23		sta $0823	                STA ARGUMENT1
.3a4784	68		pla		                PLA
.3a4785	85 25		sta $0825	                STA ARGUMENT1+2
.3a4787	e2 20		sep #$20	            SEP #$20
.3a4789	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a478b	85 27		sta $0827	            STA ARGTYPE1
.3a478d	e2 20		sep #$20	            SEP #$20
.3a478f	a0 00 00	ldy #$0000	                LDY #0
.3a4792	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.3a4794	f0 03		beq $3a4799	                BEQ count_done
.3a4796	c8		iny		                INY
.3a4797	80 f9		bra $3a4792	                BRA count_loop
.3a4799					count_done
.3a4799	c2 20		rep #$20	            REP #$20
.3a479b	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.3a479c	38		sec		                SEC
.3a479d	e5 8f		sbc $088f	                SBC MCOUNT
.3a479f	30 09		bmi $3a47aa	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.3a47a1	85 29		sta $0829	                STA ARGUMENT2
.3a47a3	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.3a47a6	85 2b		sta $082b	                STA ARGUMENT2+2
.3a47a8	80 07		bra $3a47b1	                BRA slice
.3a47aa	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.3a47ad	85 29		sta $0829	                STA ARGUMENT2
.3a47af	85 2b		sta $082b	                STA ARGUMENT2+2
.3a47b1					slice
.3a47b1	e2 20		sep #$20	            SEP #$20
.3a47b3	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a47b5	85 2d		sta $082d	            STA ARGTYPE2
.3a47b7	20 a8 16	jsr $3a16a8	            JSR STRSUBSTR
.3a47ba					done
.3a47ba	e2 20		sep #$20	            SEP #$20
.3a47bc	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a47bf	28		plp		                PLP
.3a47c0	60		rts		            RTS
.3a47c1					type_mismatch
.3a47c1	08		php		            PHP
.3a47c2	c2 20		rep #$20	            REP #$20
.3a47c4	48		pha		            PHA
.3a47c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a47c8	5b		tcd		            TCD
.3a47c9	68		pla		            PLA
.3a47ca	28		plp		            PLP
.3a47cb	e2 20		sep #$20	            SEP #$20
.3a47cd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a47cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a47d3	c2 20		rep #$20	            REP #$20
.3a47d5	29 ff 00	and #$00ff	            AND #$00FF
.3a47d8	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a47db	e2 20		sep #$20	            SEP #$20
.3a47dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47e0					syntax_err
.3a47e0	08		php		            PHP
.3a47e1	c2 20		rep #$20	            REP #$20
.3a47e3	48		pha		            PHA
.3a47e4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a47e7	5b		tcd		            TCD
.3a47e8	68		pla		            PLA
.3a47e9	28		plp		            PLP
.3a47ea	e2 20		sep #$20	            SEP #$20
.3a47ec	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a47ee	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a47f2	c2 20		rep #$20	            REP #$20
.3a47f4	29 ff 00	and #$00ff	            AND #$00FF
.3a47f7	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a47fa	e2 20		sep #$20	            SEP #$20
.3a47fc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47ff					range_err
.3a47ff	08		php		            PHP
.3a4800	c2 20		rep #$20	            REP #$20
.3a4802	48		pha		            PHA
.3a4803	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4806	5b		tcd		            TCD
.3a4807	68		pla		            PLA
.3a4808	28		plp		            PLP
.3a4809	e2 20		sep #$20	            SEP #$20
.3a480b	a9 09		lda #$09	            LDA #ERR_RANGE
.3a480d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4811	c2 20		rep #$20	            REP #$20
.3a4813	29 ff 00	and #$00ff	            AND #$00FF
.3a4816	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4819	e2 20		sep #$20	            SEP #$20
.3a481b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a481e					FN_LEFT
.3a481e	e2 20		sep #$20	            SEP #$20
.3a4820	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4822	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4825	08		php		                PHP
.3a4826	c2 30		rep #$30	            REP #$30
.3a4828	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a482b	e2 20		sep #$20	            SEP #$20
.3a482d	a5 27		lda $0827	                LDA ARGTYPE1
.3a482f	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4831	f0 03		beq $3a4836	                BEQ save_string
.3a4833	4c 8a 48	jmp $3a488a	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4836					save_string
.3a4836	c2 20		rep #$20	            REP #$20
.3a4838	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a483a	48		pha		                PHA
.3a483b	a5 23		lda $0823	                LDA ARGUMENT1
.3a483d	48		pha		                PHA
.3a483e	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4841	e2 20		sep #$20	            SEP #$20
.3a4843	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4845	c9 2c		cmp #$2c	                CMP #','
.3a4847	f0 03		beq $3a484c	                BEQ skip_comma
.3a4849	4c a9 48	jmp $3a48a9	                JMP syntax_err
.3a484c					skip_comma
.3a484c	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a484f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4852	e2 20		sep #$20	            SEP #$20
.3a4854	a5 27		lda $0827	                LDA ARGTYPE1
.3a4856	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4858	d0 30		bne $3a488a	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a485a	c2 20		rep #$20	            REP #$20
.3a485c	a5 23		lda $0823	            LDA ARGUMENT1
.3a485e	85 8f		sta $088f	            STA MCOUNT
.3a4860	c2 20		rep #$20	            REP #$20
.3a4862	a9 00 00	lda #$0000	            LDA #<>0
.3a4865	85 29		sta $0829	            STA ARGUMENT2
.3a4867	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.3a486a	85 2b		sta $082b	            STA ARGUMENT2+2
.3a486c	e2 20		sep #$20	            SEP #$20
.3a486e	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a4870	85 2d		sta $082d	            STA ARGTYPE2
.3a4872	c2 20		rep #$20	            REP #$20
.3a4874	68		pla		                PLA                         ; Recover the string pointer
.3a4875	85 23		sta $0823	                STA ARGUMENT1
.3a4877	68		pla		                PLA
.3a4878	85 25		sta $0825	                STA ARGUMENT1+2
.3a487a	e2 20		sep #$20	            SEP #$20
.3a487c	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a487e	85 27		sta $0827	            STA ARGTYPE1
.3a4880	20 a8 16	jsr $3a16a8	            JSR STRSUBSTR
.3a4883					done
.3a4883	e2 20		sep #$20	            SEP #$20
.3a4885	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4888	28		plp		                PLP
.3a4889	60		rts		            RTS
.3a488a					type_mismatch
.3a488a	08		php		            PHP
.3a488b	c2 20		rep #$20	            REP #$20
.3a488d	48		pha		            PHA
.3a488e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4891	5b		tcd		            TCD
.3a4892	68		pla		            PLA
.3a4893	28		plp		            PLP
.3a4894	e2 20		sep #$20	            SEP #$20
.3a4896	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4898	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a489c	c2 20		rep #$20	            REP #$20
.3a489e	29 ff 00	and #$00ff	            AND #$00FF
.3a48a1	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a48a4	e2 20		sep #$20	            SEP #$20
.3a48a6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48a9					syntax_err
.3a48a9	08		php		            PHP
.3a48aa	c2 20		rep #$20	            REP #$20
.3a48ac	48		pha		            PHA
.3a48ad	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a48b0	5b		tcd		            TCD
.3a48b1	68		pla		            PLA
.3a48b2	28		plp		            PLP
.3a48b3	e2 20		sep #$20	            SEP #$20
.3a48b5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a48b7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a48bb	c2 20		rep #$20	            REP #$20
.3a48bd	29 ff 00	and #$00ff	            AND #$00FF
.3a48c0	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a48c3	e2 20		sep #$20	            SEP #$20
.3a48c5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48c8					range_err
.3a48c8	08		php		            PHP
.3a48c9	c2 20		rep #$20	            REP #$20
.3a48cb	48		pha		            PHA
.3a48cc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a48cf	5b		tcd		            TCD
.3a48d0	68		pla		            PLA
.3a48d1	28		plp		            PLP
.3a48d2	e2 20		sep #$20	            SEP #$20
.3a48d4	a9 09		lda #$09	            LDA #ERR_RANGE
.3a48d6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a48da	c2 20		rep #$20	            REP #$20
.3a48dc	29 ff 00	and #$00ff	            AND #$00FF
.3a48df	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a48e2	e2 20		sep #$20	            SEP #$20
.3a48e4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48e7					FN_VAL
.3a48e7	e2 20		sep #$20	            SEP #$20
.3a48e9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a48eb	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a48ee	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a48f1	c2 10		rep #$10	            REP #$10
.3a48f3	e2 20		sep #$20	            SEP #$20
.3a48f5	a5 27		lda $0827	                LDA ARGTYPE1
.3a48f7	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a48f9	d0 23		bne $3a491e	                BNE type_mismatch
.3a48fb	c2 20		rep #$20	            REP #$20
.3a48fd	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.3a48ff	85 40		sta $0840	                STA SAVEBIP
.3a4901	a5 02		lda $0802	                LDA BIP+2
.3a4903	85 42		sta $0842	                STA SAVEBIP+2
.3a4905	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.3a4907	85 00		sta $0800	                STA BIP
.3a4909	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a490b	85 02		sta $0802	                STA BIP+2
.3a490d	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4910	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a4912	85 00		sta $0800	                STA BIP
.3a4914	a5 42		lda $0842	                LDA SAVEBIP+2
.3a4916	85 02		sta $0802	                STA BIP+2
.3a4918	e2 20		sep #$20	            SEP #$20
.3a491a	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a491d	60		rts		            RTS
.3a491e					type_mismatch
.3a491e	08		php		            PHP
.3a491f	c2 20		rep #$20	            REP #$20
.3a4921	48		pha		            PHA
.3a4922	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4925	5b		tcd		            TCD
.3a4926	68		pla		            PLA
.3a4927	28		plp		            PLP
.3a4928	e2 20		sep #$20	            SEP #$20
.3a492a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a492c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4930	c2 20		rep #$20	            REP #$20
.3a4932	29 ff 00	and #$00ff	            AND #$00FF
.3a4935	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4938	e2 20		sep #$20	            SEP #$20
.3a493a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a493d					FN_STR
.3a493d	e2 20		sep #$20	            SEP #$20
.3a493f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4941	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4944	08		php		                PHP
.3a4945	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4948	c2 10		rep #$10	            REP #$10
.3a494a	e2 20		sep #$20	            SEP #$20
.3a494c	a5 27		lda $0827	                LDA ARGTYPE1
.3a494e	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4950	d0 1a		bne $3a496c	                BNE type_mismatch
.3a4952	20 af 14	jsr $3a14af	            JSR ITOS
.3a4955	c2 20		rep #$20	            REP #$20
.3a4957	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.3a4959	85 23		sta $0823	                STA ARGUMENT1
.3a495b	a5 18		lda $0818	                LDA STRPTR+2
.3a495d	85 25		sta $0825	                STA ARGUMENT1+2
.3a495f	e2 20		sep #$20	            SEP #$20
.3a4961	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4963	85 27		sta $0827	                STA ARGTYPE1
.3a4965	28		plp		                PLP
.3a4966	e2 20		sep #$20	            SEP #$20
.3a4968	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a496b	60		rts		            RTS
.3a496c					type_mismatch
.3a496c	08		php		            PHP
.3a496d	c2 20		rep #$20	            REP #$20
.3a496f	48		pha		            PHA
.3a4970	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4973	5b		tcd		            TCD
.3a4974	68		pla		            PLA
.3a4975	28		plp		            PLP
.3a4976	e2 20		sep #$20	            SEP #$20
.3a4978	a9 04		lda #$04	            LDA #ERR_TYPE
.3a497a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a497e	c2 20		rep #$20	            REP #$20
.3a4980	29 ff 00	and #$00ff	            AND #$00FF
.3a4983	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4986	e2 20		sep #$20	            SEP #$20
.3a4988	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a498b					FN_DEC
.3a498b	e2 20		sep #$20	            SEP #$20
.3a498d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a498f	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4992	08		php		                PHP
.3a4993	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4996	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a4999	c2 20		rep #$20	            REP #$20
.3a499b	64 0c		stz $080c	                STZ SCRATCH
.3a499d	64 0e		stz $080e	                STZ SCRATCH+2
.3a499f	e2 30		sep #$30	            SEP #$30
.3a49a1	a0 00		ldy #$00	                LDY #0
.3a49a3	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.3a49a5	c9 20		cmp #$20	                CMP #CHAR_SP
.3a49a7	f0 04		beq $3a49ad	                BEQ skip_char
.3a49a9	c9 24		cmp #$24	                CMP #'$'
.3a49ab	d0 03		bne $3a49b0	                BNE loop
.3a49ad	c8		iny		skip_char       INY
.3a49ae	80 f3		bra $3a49a3	                BRA skip_loop
.3a49b0	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.3a49b2	20 60 04	jsr $3a0460	            JSR ISHEX
.3a49b5	90 1e		bcc $3a49d5	                BCC ret_result      ; No: return what we have so far
.3a49b7	c2 20		rep #$20	            REP #$20
.3a49b9	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a49bb	26 0e		rol $080e	                ROL SCRATCH+2
.3a49bd	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a49bf	26 0e		rol $080e	                ROL SCRATCH+2
.3a49c1	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a49c3	26 0e		rol $080e	                ROL SCRATCH+2
.3a49c5	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a49c7	26 0e		rol $080e	                ROL SCRATCH+2
.3a49c9	e2 20		sep #$20	            SEP #$20
.3a49cb	20 81 04	jsr $3a0481	            JSR HEX2BIN
.3a49ce	05 0c		ora $080c	                ORA SCRATCH
.3a49d0	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.3a49d2	c8		iny		                INY
.3a49d3	80 db		bra $3a49b0	                BRA loop            ; And try the next character
.3a49d5					ret_result
.3a49d5	c2 20		rep #$20	            REP #$20
.3a49d7	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.3a49d9	85 23		sta $0823	                STA ARGUMENT1
.3a49db	a5 0e		lda $080e	                LDA SCRATCH+2
.3a49dd	85 25		sta $0825	                STA ARGUMENT1+2
.3a49df	e2 20		sep #$20	            SEP #$20
.3a49e1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a49e3	85 27		sta $0827	                STA ARGTYPE1
.3a49e5	28		plp		                PLP
.3a49e6	e2 20		sep #$20	            SEP #$20
.3a49e8	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a49eb	60		rts		            RTS
.3a49ec					FN_HEX
.3a49ec	e2 20		sep #$20	            SEP #$20
.3a49ee	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a49f0	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a49f3	08		php		                PHP
.3a49f4	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a49f7	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a49fa	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a49fd	e2 30		sep #$30	            SEP #$30
.3a49ff	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.3a4a01	a9 00		lda #$00	                LDA #0
.3a4a03	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4a05	88		dey		                DEY
.3a4a06	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.3a4a08	29 0f		and #$0f	                AND #$0F
.3a4a0a	aa		tax		                TAX
.3a4a0b	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4a0f	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4a11	88		dey		                DEY
.3a4a12	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.3a4a14	29 f0		and #$f0	                AND #$F0
.3a4a16	4a		lsr a		                LSR A
.3a4a17	4a		lsr a		                LSR A
.3a4a18	4a		lsr a		                LSR A
.3a4a19	4a		lsr a		                LSR A
.3a4a1a	aa		tax		                TAX
.3a4a1b	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4a1f	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4a21	88		dey		                DEY
.3a4a22	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.3a4a24	85 23		sta $0823	                STA ARGUMENT1
.3a4a26	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4a28	85 24		sta $0824	                STA ARGUMENT1+1
.3a4a2a	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a4a2c	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a2e	a9 00		lda #$00	                LDA #0
.3a4a30	85 26		sta $0826	                STA ARGUMENT1+3
.3a4a32	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.3a4a34	d0 d0		bne $3a4a06	                BNE loop            ; No: keep converting
.3a4a36	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4a38	d0 cc		bne $3a4a06	                BNE loop
.3a4a3a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4a3c	d0 c8		bne $3a4a06	                BNE loop
.3a4a3e	98		tya		                TYA                 ; Get the index of the first free char
.3a4a3f	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.3a4a40	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.3a4a42	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.3a4a44	a5 17		lda $0817	                LDA STRPTR+1
.3a4a46	85 24		sta $0824	                STA ARGUMENT1+1
.3a4a48	a5 18		lda $0818	                LDA STRPTR+2
.3a4a4a	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a4c	a5 19		lda $0819	                LDA STRPTR+3
.3a4a4e	85 26		sta $0826	                STA ARGUMENT1+3
.3a4a50	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.3a4a52	85 27		sta $0827	                STA ARGTYPE1
.3a4a54	28		plp		                PLP
.3a4a55	e2 20		sep #$20	            SEP #$20
.3a4a57	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4a5a	60		rts		            RTS
.3a4a5b					type_mismatch
.3a4a5b	08		php		            PHP
.3a4a5c	c2 20		rep #$20	            REP #$20
.3a4a5e	48		pha		            PHA
.3a4a5f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a62	5b		tcd		            TCD
.3a4a63	68		pla		            PLA
.3a4a64	28		plp		            PLP
.3a4a65	e2 20		sep #$20	            SEP #$20
.3a4a67	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a69	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a6d	c2 20		rep #$20	            REP #$20
.3a4a6f	29 ff 00	and #$00ff	            AND #$00FF
.3a4a72	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4a75	e2 20		sep #$20	            SEP #$20
.3a4a77	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a7a					FN_LEN
.3a4a7a	e2 20		sep #$20	            SEP #$20
.3a4a7c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a7e	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4a81	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4a84	e2 20		sep #$20	            SEP #$20
.3a4a86	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a88	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4a8a	d0 1f		bne $3a4aab	                BNE type_mismatch
.3a4a8c	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.3a4a8d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4a8f	48		pha		                PHA
.3a4a90	ab		plb		                PLB
.3a4a91	c2 10		rep #$10	            REP #$10
.3a4a93	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.3a4a95	20 3c 15	jsr $3a153c	            JSR STRLEN
.3a4a98	ab		plb		                PLB                 ; Restore the old data bank
.3a4a99	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.3a4a9b	c2 20		rep #$20	            REP #$20
.3a4a9d	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4a9f	e2 20		sep #$20	            SEP #$20
.3a4aa1	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.3a4aa3	85 27		sta $0827	                STA ARGTYPE1
.3a4aa5	e2 20		sep #$20	            SEP #$20
.3a4aa7	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4aaa	60		rts		            RTS
.3a4aab					type_mismatch
.3a4aab	08		php		            PHP
.3a4aac	c2 20		rep #$20	            REP #$20
.3a4aae	48		pha		            PHA
.3a4aaf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ab2	5b		tcd		            TCD
.3a4ab3	68		pla		            PLA
.3a4ab4	28		plp		            PLP
.3a4ab5	e2 20		sep #$20	            SEP #$20
.3a4ab7	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4ab9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4abd	c2 20		rep #$20	            REP #$20
.3a4abf	29 ff 00	and #$00ff	            AND #$00FF
.3a4ac2	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4ac5	e2 20		sep #$20	            SEP #$20
.3a4ac7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4aca					FN_PEEK
.3a4aca	e2 20		sep #$20	            SEP #$20
.3a4acc	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ace	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ad1	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4ad4	e2 20		sep #$20	            SEP #$20
.3a4ad6	a5 27		lda $0827	                LDA ARGTYPE1
.3a4ad8	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4ada	d0 33		bne $3a4b0f	                BNE type_mismatch
.3a4adc	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.3a4ade	c9 b0		cmp #$b0	                CMP #`VRAM
.3a4ae0	90 1b		bcc $3a4afd	                BLT simple_peek                     ; No: just do an ordinary PEEK
.3a4ae2	c9 f0		cmp #$f0	                CMP #$F0
.3a4ae4	b0 17		bcs $3a4afd	                BGE simple_peek
.3a4ae6	e2 20		sep #$20	            SEP #$20
.3a4ae8	a7 23		lda [$0823]	                LDA [ARGUMENT1]                     ; Request the data from VRAM
.3a4aea	c2 20		rep #$20	            REP #$20
.3a4aec	af 02 09 af	lda $af0902	wait_vram       LDA @l VMEM2CPU_Fifo_Count_LO       ; Wait for the Vicky FIFO to have a byte in it
.3a4af0	89 00 80	bit #$8000	                BIT #$8000
.3a4af3	d0 f7		bne $3a4aec	                BNE wait_vram
.3a4af5	e2 20		sep #$20	            SEP #$20
.3a4af7	af 01 09 af	lda $af0901	                LDA @l VMEM2CPU_Data_Port           ; Fetch the byte from the Vicky FIFO
.3a4afb	80 04		bra $3a4b01	                BRA save_result                     ; And return it
.3a4afd					simple_peek
.3a4afd	e2 20		sep #$20	            SEP #$20
.3a4aff	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4b01	85 23		sta $0823	save_result     STA ARGUMENT1
.3a4b03	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4b05	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4b07	64 30		stz $0830	                STZ ARGUMENT1+13
.3a4b09	e2 20		sep #$20	            SEP #$20
.3a4b0b	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4b0e	60		rts		            RTS
.3a4b0f					type_mismatch
.3a4b0f	08		php		            PHP
.3a4b10	c2 20		rep #$20	            REP #$20
.3a4b12	48		pha		            PHA
.3a4b13	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b16	5b		tcd		            TCD
.3a4b17	68		pla		            PLA
.3a4b18	28		plp		            PLP
.3a4b19	e2 20		sep #$20	            SEP #$20
.3a4b1b	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b1d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b21	c2 20		rep #$20	            REP #$20
.3a4b23	29 ff 00	and #$00ff	            AND #$00FF
.3a4b26	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4b29	e2 20		sep #$20	            SEP #$20
.3a4b2b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b2e					FN_PEEKL
.3a4b2e	e2 20		sep #$20	            SEP #$20
.3a4b30	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b32	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4b35	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4b38	e2 20		sep #$20	            SEP #$20
.3a4b3a	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b3c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4b3e	d0 1d		bne $3a4b5d	                BNE type_mismatch
.3a4b40	c2 20		rep #$20	            REP #$20
.3a4b42	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4b44	85 0c		sta $080c	                STA SCRATCH
.3a4b46	e2 20		sep #$20	            SEP #$20
.3a4b48	a0 02 00	ldy #$0002	                LDY #2
.3a4b4b	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.3a4b4d	85 25		sta $0825	                STA ARGUMENT1+2
.3a4b4f	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4b51	c2 20		rep #$20	            REP #$20
.3a4b53	a5 0c		lda $080c	                LDA SCRATCH
.3a4b55	85 23		sta $0823	                STA ARGUMENT1
.3a4b57	e2 20		sep #$20	            SEP #$20
.3a4b59	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4b5c	60		rts		            RTS
.3a4b5d					type_mismatch
.3a4b5d	08		php		            PHP
.3a4b5e	c2 20		rep #$20	            REP #$20
.3a4b60	48		pha		            PHA
.3a4b61	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b64	5b		tcd		            TCD
.3a4b65	68		pla		            PLA
.3a4b66	28		plp		            PLP
.3a4b67	e2 20		sep #$20	            SEP #$20
.3a4b69	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b6b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b6f	c2 20		rep #$20	            REP #$20
.3a4b71	29 ff 00	and #$00ff	            AND #$00FF
.3a4b74	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4b77	e2 20		sep #$20	            SEP #$20
.3a4b79	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b7c					FN_PEEKW
.3a4b7c	e2 20		sep #$20	            SEP #$20
.3a4b7e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b80	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4b83	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4b86	e2 20		sep #$20	            SEP #$20
.3a4b88	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b8a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4b8c	d0 0e		bne $3a4b9c	                BNE type_mismatch
.3a4b8e	c2 20		rep #$20	            REP #$20
.3a4b90	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4b92	85 23		sta $0823	                STA ARGUMENT1
.3a4b94	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4b96	e2 20		sep #$20	            SEP #$20
.3a4b98	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4b9b	60		rts		            RTS
.3a4b9c					type_mismatch
.3a4b9c	08		php		            PHP
.3a4b9d	c2 20		rep #$20	            REP #$20
.3a4b9f	48		pha		            PHA
.3a4ba0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ba3	5b		tcd		            TCD
.3a4ba4	68		pla		            PLA
.3a4ba5	28		plp		            PLP
.3a4ba6	e2 20		sep #$20	            SEP #$20
.3a4ba8	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4baa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4bae	c2 20		rep #$20	            REP #$20
.3a4bb0	29 ff 00	and #$00ff	            AND #$00FF
.3a4bb3	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4bb6	e2 20		sep #$20	            SEP #$20
.3a4bb8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4bbb					FN_CHR
.3a4bbb	e2 20		sep #$20	            SEP #$20
.3a4bbd	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4bbf	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4bc2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4bc5	e2 20		sep #$20	            SEP #$20
.3a4bc7	a5 27		lda $0827	                LDA ARGTYPE1
.3a4bc9	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4bcb	d0 24		bne $3a4bf1	                BNE type_mismatch
.3a4bcd	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a4bd0	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.3a4bd2	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.3a4bd4	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.3a4bd6	a0 01 00	ldy #$0001	                LDY #1
.3a4bd9	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4bdb	c2 20		rep #$20	            REP #$20
.3a4bdd	a5 16		lda $0816	                LDA STRPTR
.3a4bdf	85 23		sta $0823	                STA ARGUMENT1
.3a4be1	a5 18		lda $0818	                LDA STRPTR+2
.3a4be3	85 25		sta $0825	                STA ARGUMENT1+2
.3a4be5	e2 20		sep #$20	            SEP #$20
.3a4be7	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4be9	85 27		sta $0827	                STA ARGTYPE1
.3a4beb	e2 20		sep #$20	            SEP #$20
.3a4bed	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4bf0	60		rts		            RTS
.3a4bf1					type_mismatch
.3a4bf1	08		php		            PHP
.3a4bf2	c2 20		rep #$20	            REP #$20
.3a4bf4	48		pha		            PHA
.3a4bf5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4bf8	5b		tcd		            TCD
.3a4bf9	68		pla		            PLA
.3a4bfa	28		plp		            PLP
.3a4bfb	e2 20		sep #$20	            SEP #$20
.3a4bfd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4bff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c03	c2 20		rep #$20	            REP #$20
.3a4c05	29 ff 00	and #$00ff	            AND #$00FF
.3a4c08	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4c0b	e2 20		sep #$20	            SEP #$20
.3a4c0d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c10					FN_ASC
.3a4c10	e2 20		sep #$20	            SEP #$20
.3a4c12	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c14	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4c17	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4c1a	e2 20		sep #$20	            SEP #$20
.3a4c1c	a5 27		lda $0827	                LDA ARGTYPE1
.3a4c1e	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4c20	d0 14		bne $3a4c36	                BNE type_mismatch
.3a4c22	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.3a4c24	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.3a4c26	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4c28	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4c2a	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4c2c	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.3a4c2e	85 27		sta $0827	                STA ARGTYPE1
.3a4c30	e2 20		sep #$20	            SEP #$20
.3a4c32	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4c35	60		rts		            RTS
.3a4c36					type_mismatch
.3a4c36	08		php		            PHP
.3a4c37	c2 20		rep #$20	            REP #$20
.3a4c39	48		pha		            PHA
.3a4c3a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c3d	5b		tcd		            TCD
.3a4c3e	68		pla		            PLA
.3a4c3f	28		plp		            PLP
.3a4c40	e2 20		sep #$20	            SEP #$20
.3a4c42	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4c44	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c48	c2 20		rep #$20	            REP #$20
.3a4c4a	29 ff 00	and #$00ff	            AND #$00FF
.3a4c4d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4c50	e2 20		sep #$20	            SEP #$20
.3a4c52	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c55					FN_SPC
.3a4c55	e2 20		sep #$20	            SEP #$20
.3a4c57	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c59	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4c5c	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4c5f	e2 20		sep #$20	            SEP #$20
.3a4c61	a5 27		lda $0827	                LDA ARGTYPE1
.3a4c63	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4c65	d0 39		bne $3a4ca0	                BNE type_mismatch
.3a4c67	e2 20		sep #$20	            SEP #$20
.3a4c69	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4c6b	d0 52		bne $3a4cbf	                BNE err_limit
.3a4c6d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4c6f	d0 4e		bne $3a4cbf	                BNE err_limit
.3a4c71	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4c73	d0 4a		bne $3a4cbf	                BNE err_limit
.3a4c75	c2 10		rep #$10	            REP #$10
.3a4c77	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a4c7a	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4c7c	e2 20		sep #$20	            SEP #$20
.3a4c7e	a9 00		lda #$00	                LDA #0
.3a4c80	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4c82	88		dey		                DEY
.3a4c83	30 07		bmi $3a4c8c	                BMI done
.3a4c85	a9 20		lda #$20	                LDA #CHAR_SP
.3a4c87	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4c89	88		dey		                DEY
.3a4c8a	10 fb		bpl $3a4c87	                BPL loop            ; And keep writing until we're done
.3a4c8c	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4c8e	85 27		sta $0827	                STA ARGTYPE1
.3a4c90	c2 20		rep #$20	            REP #$20
.3a4c92	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4c94	85 23		sta $0823	                STA ARGUMENT1
.3a4c96	a5 18		lda $0818	                LDA STRPTR+2
.3a4c98	85 25		sta $0825	                STA ARGUMENT1+2
.3a4c9a	e2 20		sep #$20	            SEP #$20
.3a4c9c	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4c9f	60		rts		            RTS
.3a4ca0					type_mismatch
.3a4ca0	08		php		            PHP
.3a4ca1	c2 20		rep #$20	            REP #$20
.3a4ca3	48		pha		            PHA
.3a4ca4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ca7	5b		tcd		            TCD
.3a4ca8	68		pla		            PLA
.3a4ca9	28		plp		            PLP
.3a4caa	e2 20		sep #$20	            SEP #$20
.3a4cac	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4cae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4cb2	c2 20		rep #$20	            REP #$20
.3a4cb4	29 ff 00	and #$00ff	            AND #$00FF
.3a4cb7	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4cba	e2 20		sep #$20	            SEP #$20
.3a4cbc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4cbf					err_limit
.3a4cbf	08		php		            PHP
.3a4cc0	c2 20		rep #$20	            REP #$20
.3a4cc2	48		pha		            PHA
.3a4cc3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4cc6	5b		tcd		            TCD
.3a4cc7	68		pla		            PLA
.3a4cc8	28		plp		            PLP
.3a4cc9	e2 20		sep #$20	            SEP #$20
.3a4ccb	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4ccd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4cd1	c2 20		rep #$20	            REP #$20
.3a4cd3	29 ff 00	and #$00ff	            AND #$00FF
.3a4cd6	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4cd9	e2 20		sep #$20	            SEP #$20
.3a4cdb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4cde					FN_TAB
.3a4cde	e2 20		sep #$20	            SEP #$20
.3a4ce0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ce2	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ce5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4ce8	e2 20		sep #$20	            SEP #$20
.3a4cea	a5 27		lda $0827	                LDA ARGTYPE1
.3a4cec	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4cee	d0 39		bne $3a4d29	                BNE type_mismatch
.3a4cf0	e2 20		sep #$20	            SEP #$20
.3a4cf2	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4cf4	d0 52		bne $3a4d48	                BNE err_limit
.3a4cf6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4cf8	d0 4e		bne $3a4d48	                BNE err_limit
.3a4cfa	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4cfc	d0 4a		bne $3a4d48	                BNE err_limit
.3a4cfe	c2 10		rep #$10	            REP #$10
.3a4d00	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a4d03	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4d05	e2 20		sep #$20	            SEP #$20
.3a4d07	a9 00		lda #$00	                LDA #0
.3a4d09	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4d0b	88		dey		                DEY
.3a4d0c	30 07		bmi $3a4d15	                BMI done
.3a4d0e	a9 09		lda #$09	                LDA #CHAR_TAB
.3a4d10	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4d12	88		dey		                DEY
.3a4d13	10 fb		bpl $3a4d10	                BPL loop            ; And keep writing until we're done
.3a4d15	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4d17	85 27		sta $0827	                STA ARGTYPE1
.3a4d19	c2 20		rep #$20	            REP #$20
.3a4d1b	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4d1d	85 23		sta $0823	                STA ARGUMENT1
.3a4d1f	a5 18		lda $0818	                LDA STRPTR+2
.3a4d21	85 25		sta $0825	                STA ARGUMENT1+2
.3a4d23	e2 20		sep #$20	            SEP #$20
.3a4d25	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4d28	60		rts		            RTS
.3a4d29					type_mismatch
.3a4d29	08		php		            PHP
.3a4d2a	c2 20		rep #$20	            REP #$20
.3a4d2c	48		pha		            PHA
.3a4d2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d30	5b		tcd		            TCD
.3a4d31	68		pla		            PLA
.3a4d32	28		plp		            PLP
.3a4d33	e2 20		sep #$20	            SEP #$20
.3a4d35	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4d37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d3b	c2 20		rep #$20	            REP #$20
.3a4d3d	29 ff 00	and #$00ff	            AND #$00FF
.3a4d40	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4d43	e2 20		sep #$20	            SEP #$20
.3a4d45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d48					err_limit
.3a4d48	08		php		            PHP
.3a4d49	c2 20		rep #$20	            REP #$20
.3a4d4b	48		pha		            PHA
.3a4d4c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d4f	5b		tcd		            TCD
.3a4d50	68		pla		            PLA
.3a4d51	28		plp		            PLP
.3a4d52	e2 20		sep #$20	            SEP #$20
.3a4d54	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4d56	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d5a	c2 20		rep #$20	            REP #$20
.3a4d5c	29 ff 00	and #$00ff	            AND #$00FF
.3a4d5f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4d62	e2 20		sep #$20	            SEP #$20
.3a4d64	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d67					FN_ABS
.3a4d67	e2 20		sep #$20	            SEP #$20
.3a4d69	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d6b	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4d6e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4d71	e2 20		sep #$20	            SEP #$20
.3a4d73	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.3a4d75	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4d77	f0 23		beq $3a4d9c	                BEQ abs_int         ; If integer, get the absolute value of the integer
.3a4d79	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a4d7b	f0 3e		beq $3a4dbb	                BEQ abs_float       ; If float, get the absolute value of the float
.3a4d7d					type_err
.3a4d7d	08		php		            PHP
.3a4d7e	c2 20		rep #$20	            REP #$20
.3a4d80	48		pha		            PHA
.3a4d81	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d84	5b		tcd		            TCD
.3a4d85	68		pla		            PLA
.3a4d86	28		plp		            PLP
.3a4d87	e2 20		sep #$20	            SEP #$20
.3a4d89	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4d8b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d8f	c2 20		rep #$20	            REP #$20
.3a4d91	29 ff 00	and #$00ff	            AND #$00FF
.3a4d94	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4d97	e2 20		sep #$20	            SEP #$20
.3a4d99	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d9c					abs_int
.3a4d9c	c2 20		rep #$20	            REP #$20
.3a4d9e	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.3a4da0	10 21		bpl $3a4dc3	                BPL done            ; Yes: we don't need to do anythign further
.3a4da2	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.3a4da5	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.3a4da7	a5 23		lda $0823	                LDA ARGUMENT1
.3a4da9	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a4dac	18		clc		                CLC
.3a4dad	69 01 00	adc #$0001	                ADC #1
.3a4db0	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.3a4db2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4db4	69 00 00	adc #$0000	                ADC #0
.3a4db7	85 25		sta $0825	                STA ARGUMENT1+2
.3a4db9	80 08		bra $3a4dc3	                BRA done
.3a4dbb					abs_float
.3a4dbb	e2 20		sep #$20	            SEP #$20
.3a4dbd	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.3a4dbf	29 7f		and #$7f	                AND #$7F
.3a4dc1	85 26		sta $0826	                STA ARGUMENT1+3
.3a4dc3					done
.3a4dc3	e2 20		sep #$20	            SEP #$20
.3a4dc5	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4dc8	60		rts		            RTS
.3a4dc9					FN_SGN
.3a4dc9	e2 20		sep #$20	            SEP #$20
.3a4dcb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4dcd	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4dd0	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4dd3	e2 20		sep #$20	            SEP #$20
.3a4dd5	a5 27		lda $0827	                LDA ARGTYPE1
.3a4dd7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4dd9	d0 25		bne $3a4e00	                BNE type_mismatch
.3a4ddb	c2 20		rep #$20	            REP #$20
.3a4ddd	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4ddf	30 12		bmi $3a4df3	                BMI is_negative     ; Negative: return -1
.3a4de1	d0 04		bne $3a4de7	                BNE is_positive     ; Is it not 0? Then return 1
.3a4de3	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.3a4de5	f0 13		beq $3a4dfa	                BEQ done            ; Yes: the whole thing is zero: return 0
.3a4de7	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.3a4dea	85 25		sta $0825	                STA ARGUMENT1+2
.3a4dec	a9 01 00	lda #$0001	                LDA #1
.3a4def	85 23		sta $0823	                STA ARGUMENT1
.3a4df1	80 07		bra $3a4dfa	                BRA done
.3a4df3	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.3a4df6	85 25		sta $0825	                STA ARGUMENT1+2
.3a4df8	85 23		sta $0823	                STA ARGUMENT1
.3a4dfa					done
.3a4dfa	e2 20		sep #$20	            SEP #$20
.3a4dfc	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4dff	60		rts		            RTS
.3a4e00					type_mismatch
.3a4e00	08		php		            PHP
.3a4e01	c2 20		rep #$20	            REP #$20
.3a4e03	48		pha		            PHA
.3a4e04	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e07	5b		tcd		            TCD
.3a4e08	68		pla		            PLA
.3a4e09	28		plp		            PLP
.3a4e0a	e2 20		sep #$20	            SEP #$20
.3a4e0c	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4e0e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e12	c2 20		rep #$20	            REP #$20
.3a4e14	29 ff 00	and #$00ff	            AND #$00FF
.3a4e17	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4e1a	e2 20		sep #$20	            SEP #$20
.3a4e1c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e1f					FN_INT
.3a4e1f	e2 20		sep #$20	            SEP #$20
.3a4e21	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e23	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e26	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e29	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a4e2c					done
.3a4e2c	e2 20		sep #$20	            SEP #$20
.3a4e2e	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e31	60		rts		            RTS
.3a4e32					FN_SIN
.3a4e32	e2 20		sep #$20	            SEP #$20
.3a4e34	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e36	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e39	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e3c	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4e3f	20 f0 60	jsr $3a60f0	            JSR FP_SIN
.3a4e42					done
.3a4e42	e2 20		sep #$20	            SEP #$20
.3a4e44	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e47	60		rts		            RTS
.3a4e48					FN_COS
.3a4e48	e2 20		sep #$20	            SEP #$20
.3a4e4a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e4c	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e4f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e52	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4e55	20 1f 61	jsr $3a611f	            JSR FP_COS
.3a4e58					done
.3a4e58	e2 20		sep #$20	            SEP #$20
.3a4e5a	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e5d	60		rts		            RTS
.3a4e5e					FN_TAN
.3a4e5e	e2 20		sep #$20	            SEP #$20
.3a4e60	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e62	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e65	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e68	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4e6b	20 4e 61	jsr $3a614e	            JSR FP_TAN
.3a4e6e					done
.3a4e6e	e2 20		sep #$20	            SEP #$20
.3a4e70	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e73	60		rts		            RTS
.3a4e74					FN_LN
.3a4e74	e2 20		sep #$20	            SEP #$20
.3a4e76	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e78	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e7b	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e7e	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4e81	20 7c 61	jsr $3a617c	            JSR FP_LN
.3a4e84					done
.3a4e84	e2 20		sep #$20	            SEP #$20
.3a4e86	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e89	60		rts		            RTS
.3a4e8a					FN_ACOS
.3a4e8a	e2 20		sep #$20	            SEP #$20
.3a4e8c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e8e	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4e91	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4e94	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4e97	20 a5 62	jsr $3a62a5	            JSR FP_ACOS
.3a4e9a					done
.3a4e9a	e2 20		sep #$20	            SEP #$20
.3a4e9c	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4e9f	60		rts		            RTS
.3a4ea0					FN_ASIN
.3a4ea0	e2 20		sep #$20	            SEP #$20
.3a4ea2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ea4	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ea7	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4eaa	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4ead	20 7b 62	jsr $3a627b	            JSR FP_ASIN
.3a4eb0					done
.3a4eb0	e2 20		sep #$20	            SEP #$20
.3a4eb2	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4eb5	60		rts		            RTS
.3a4eb6					FN_ATAN
.3a4eb6	e2 20		sep #$20	            SEP #$20
.3a4eb8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4eba	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ebd	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4ec0	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4ec3	20 c7 62	jsr $3a62c7	            JSR FP_ATAN
.3a4ec6					done
.3a4ec6	e2 20		sep #$20	            SEP #$20
.3a4ec8	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4ecb	60		rts		            RTS
.3a4ecc					FN_EXP
.3a4ecc	e2 20		sep #$20	            SEP #$20
.3a4ece	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ed0	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ed3	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4ed6	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4ed9	20 5b 63	jsr $3a635b	            JSR FP_EXP
.3a4edc					done
.3a4edc	e2 20		sep #$20	            SEP #$20
.3a4ede	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4ee1	60		rts		            RTS
.3a4ee2					FN_SQR
.3a4ee2	e2 20		sep #$20	            SEP #$20
.3a4ee4	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ee6	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4ee9	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a4eec	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a4eef	20 dd 63	jsr $3a63dd	            JSR FP_SQR
.3a4ef2					done
.3a4ef2	e2 20		sep #$20	            SEP #$20
.3a4ef4	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a4ef7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.3a4ef8	00		brk #		CMD_MONITOR     BRK
.3a4ef9	ea		nop		                NOP
.3a4efa	60		rts		            RTS
.3a4efb					CMD_NEW
.3a4efb	08		php		                PHP
.3a4efc	0b		phd		                PHD
.3a4efd	08		php		            PHP
.3a4efe	c2 20		rep #$20	            REP #$20
.3a4f00	48		pha		            PHA
.3a4f01	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a4f04	5b		tcd		            TCD
.3a4f05	68		pla		            PLA
.3a4f06	28		plp		            PLP
.3a4f07	c2 30		rep #$30	            REP #$30
.3a4f09	c2 20		rep #$20	            REP #$20
.3a4f0b	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a4f0e	85 d9		sta $08d9	            STA LASTLINE
.3a4f10	e2 20		sep #$20	            SEP #$20
.3a4f12	a9 36		lda #$36	            LDA #`BASIC_BOT
.3a4f14	85 db		sta $08db	            STA LASTLINE+2
.3a4f16	c2 30		rep #$30	            REP #$30
.3a4f18	a9 00 00	lda #$0000	                LDA #0
.3a4f1b	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.3a4f1e	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4f20	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.3a4f23	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4f25	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.3a4f28	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4f2a	20 42 20	jsr $3a2042	            JSR CLRINTERP
.3a4f2d	2b		pld		                PLD
.3a4f2e	28		plp		                PLP
.3a4f2f	60		rts		            RTS
.3a4f30					CMD_RUN
.3a4f30	8b		phb		                PHB
.3a4f31	08		php		                PHP
.3a4f32	c2 20		rep #$20	            REP #$20
.3a4f34	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.3a4f37	85 1a		sta $081a	                STA CURLINE
.3a4f39	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a4f3c	85 1c		sta $081c	                STA CURLINE + 2
.3a4f3e	20 42 20	jsr $3a2042	            JSR CLRINTERP
.3a4f41	20 22 23	jsr $3a2322	            JSR EXECPROGRAM
.3a4f44	28		plp		                PLP
.3a4f45	ab		plb		                PLB
.3a4f46	60		rts		            RTS
.3a4f47					CMD_LIST
.3a4f47	08		php		                PHP
.3a4f48	c2 20		rep #$20	            REP #$20
.3a4f4a	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.3a4f4c	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a4f4f	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.3a4f51	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a4f54	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a4f57	29 ff 00	and #$00ff	                AND #$00FF
.3a4f5a	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a4f5d	f0 2c		beq $3a4f8b	                BEQ call_list           ; ... just list with the defaults
.3a4f5f	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.3a4f62	f0 1a		beq $3a4f7e	                BEQ parse_endline       ; ... try to parse the end line number
.3a4f64	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4f67	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4f6a	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.3a4f6c	85 55		sta $0855	                STA MARG1
.3a4f6e	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a4f71	29 ff 00	and #$00ff	                AND #$00FF
.3a4f74	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a4f77	f0 12		beq $3a4f8b	                BEQ call_list           ; ... just list with the defaults
.3a4f79	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.3a4f7c	d0 2a		bne $3a4fa8	                BNE error               ; At this point, if not '-', it's a syntax error
.3a4f7e					parse_endline
.3a4f7e	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a4f81	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a4f84	20 2c 08	jsr $3a082c	            JSR PARSEINT
.3a4f87	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.3a4f89	85 59		sta $0859	                STA MARG2
.3a4f8b	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.3a4f8d	48		pha		                PHA
.3a4f8e	a5 1a		lda $081a	                LDA CURLINE
.3a4f90	48		pha		                PHA
.3a4f91	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.3a4f93	48		pha		                PHA
.3a4f94	a5 00		lda $0800	                LDA BIP
.3a4f96	48		pha		                PHA
.3a4f97	20 da 17	jsr $3a17da	            JSR LISTPROG
.3a4f9a	68		pla		                PLA
.3a4f9b	85 00		sta $0800	                STA BIP
.3a4f9d	68		pla		                PLA
.3a4f9e	85 02		sta $0802	                STA BIP+2
.3a4fa0	68		pla		                PLA
.3a4fa1	85 1a		sta $081a	                STA CURLINE
.3a4fa3	68		pla		                PLA
.3a4fa4	85 1c		sta $081c	                STA CURLINE+2
.3a4fa6	28		plp		                PLP
.3a4fa7	60		rts		            RTS
.3a4fa8					error
.3a4fa8	08		php		            PHP
.3a4fa9	c2 20		rep #$20	            REP #$20
.3a4fab	48		pha		            PHA
.3a4fac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4faf	5b		tcd		            TCD
.3a4fb0	68		pla		            PLA
.3a4fb1	28		plp		            PLP
.3a4fb2	e2 20		sep #$20	            SEP #$20
.3a4fb4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4fb6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4fba	c2 20		rep #$20	            REP #$20
.3a4fbc	29 ff 00	and #$00ff	            AND #$00FF
.3a4fbf	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a4fc2	e2 20		sep #$20	            SEP #$20
.3a4fc4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.3a4fc7					INITVARS
.3a4fc7	08		php		                PHP
.3a4fc8	08		php		            PHP
.3a4fc9	c2 20		rep #$20	            REP #$20
.3a4fcb	48		pha		            PHA
.3a4fcc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4fcf	5b		tcd		            TCD
.3a4fd0	68		pla		            PLA
.3a4fd1	28		plp		            PLP
.3a4fd2	c2 20		rep #$20	            REP #$20
.3a4fd4	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.3a4fd6	64 e7		stz $08e7	                STZ TOFIND
.3a4fd8	e2 20		sep #$20	            SEP #$20
.3a4fda	64 e6		stz $08e6	                STZ VARIABLES+2
.3a4fdc	64 e9		stz $08e9	                STZ TOFIND+2
.3a4fde	64 ea		stz $08ea	                STZ TOFINDTYPE
.3a4fe0	c2 20		rep #$20	            REP #$20
.3a4fe2	38		sec		                SEC                     ; Compute the position of the first variable
.3a4fe3	a5 d9		lda $08d9	                LDA LASTLINE
.3a4fe5	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a4fe8	85 e1		sta $08e1	                STA NEXTVAR
.3a4fea	e2 20		sep #$20	            SEP #$20
.3a4fec	a5 db		lda $08db	                LDA LASTLINE+2
.3a4fee	69 00		adc #$00	                ADC #0
.3a4ff0	85 e3		sta $08e3	                STA NEXTVAR+2
.3a4ff2	28		plp		                PLP
.3a4ff3	60		rts		            RTS
.3a4ff4					ISVARCHAR
.3a4ff4	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.3a4ff6	f0 1a		beq $3a5012	                BEQ return_true     ; Yes: return true
.3a4ff8	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.3a4ffa	b0 04		bcs $3a5000	                BGE else1           ; No: check something else
.3a4ffc	c9 30		cmp #$30	                CMP #'0'
.3a4ffe	b0 12		bcs $3a5012	                BGE return_true     ; Yes: return true
.3a5000	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.3a5002	b0 04		bcs $3a5008	                BGE not_upper       ; No: check lower case
.3a5004	c9 41		cmp #$41	                CMP #'A'
.3a5006	b0 0a		bcs $3a5012	                BGE return_true     ; Yes: return true
.3a5008	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.3a500a	b0 04		bcs $3a5010	                BGE return_false    ; No: return false
.3a500c	c9 61		cmp #$61	                CMP #'a'
.3a500e	b0 02		bcs $3a5012	                BGE return_true     ; Yes: return true
.3a5010	18		clc		return_false    CLC
.3a5011	60		rts		            RTS
.3a5012	38		sec		return_true     SEC
.3a5013	60		rts		            RTS
.3a5014					VARNAMECMP
.3a5014	08		php		                PHP
.3a5015	e2 20		sep #$20	            SEP #$20
.3a5017	c2 10		rep #$10	            REP #$10
.3a5019	a0 00 00	ldy #$0000	                LDY #0
.3a501c	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.3a501e	f0 0a		beq $3a502a	                BEQ is_end
.3a5020	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.3a5022	d0 13		bne $3a5037	                BNE return_false        ; Not equal? Then this is not a match
.3a5024	c8		iny		                INY
.3a5025	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a5028	d0 f2		bne $3a501c	                BNE cmp_loop
.3a502a	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.3a502c	20 aa 04	jsr $3a04aa	            JSR TOUPPERA
.3a502f	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a5032	b0 03		bcs $3a5037	                BCS return_false        ; YES: we do not have a match
.3a5034					return_true
.3a5034	28		plp		                PLP
.3a5035	38		sec		                SEC
.3a5036	60		rts		            RTS
.3a5037					return_false
.3a5037	28		plp		                PLP
.3a5038	18		clc		                CLC
.3a5039	60		rts		            RTS
.3a503a					VAR_FIND
.3a503a	08		php		                PHP
.3a503b	e2 20		sep #$20	            SEP #$20
.3a503d	c2 10		rep #$10	            REP #$10
.3a503f	a0 00 00	ldy #$0000	                LDY #0
.3a5042	a2 00 00	ldx #$0000	                LDX #0
.3a5045	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.3a5047	f0 0b		beq $3a5054	                BEQ done_upper
.3a5049	20 aa 04	jsr $3a04aa	            JSR TOUPPERA
.3a504c	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.3a5050	c8		iny		                INY
.3a5051	e8		inx		                INX
.3a5052	80 f1		bra $3a5045	                BRA upper_loop          ; Go back for another
.3a5054	a9 00		lda #$00	done_upper      LDA #0
.3a5056	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.3a505a	c2 20		rep #$20	            REP #$20
.3a505c	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.3a505f	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.3a5061	e2 20		sep #$20	            SEP #$20
.3a5063	a9 00		lda #$00	                LDA #`TEMPBUF
.3a5065	85 e9		sta $08e9	                STA TOFIND+2
.3a5067	c2 20		rep #$20	            REP #$20
.3a5069	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.3a506b	85 08		sta $0808	                STA INDEX
.3a506d	d0 06		bne $3a5075	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.3a506f	e2 20		sep #$20	            SEP #$20
.3a5071	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a5073	f0 4d		beq $3a50c2	                BEQ not_found           ; If it is, we have no variables yet.
.3a5075					set_index_h
.3a5075	e2 20		sep #$20	            SEP #$20
.3a5077	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a5079	85 0a		sta $080a	                STA INDEX+2
.3a507b	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.3a507d	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.3a5080	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.3a5082	d0 17		bne $3a509b	                BNE check_next          ; If it's not a match, check the next binding
.3a5084	c2 20		rep #$20	            REP #$20
.3a5086	18		clc		                CLC
.3a5087	a5 08		lda $0808	                LDA INDEX
.3a5089	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a508c	85 0c		sta $080c	                STA SCRATCH
.3a508e	e2 20		sep #$20	            SEP #$20
.3a5090	a5 0a		lda $080a	                LDA INDEX+2
.3a5092	69 00		adc #$00	                ADC #0
.3a5094	85 0e		sta $080e	                STA SCRATCH+2
.3a5096	20 14 50	jsr $3a5014	            JSR VARNAMECMP
.3a5099	b0 2a		bcs $3a50c5	                BCS found               ; If they match, return that we've found the variable
.3a509b	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.3a509e	c2 20		rep #$20	            REP #$20
.3a50a0	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a50a2	85 0c		sta $080c	                STA SCRATCH
.3a50a4	c8		iny		                INY
.3a50a5	c8		iny		                INY
.3a50a6	e2 20		sep #$20	            SEP #$20
.3a50a8	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a50aa	85 0e		sta $080e	                STA SCRATCH+2
.3a50ac	d0 06		bne $3a50b4	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.3a50ae	c2 20		rep #$20	            REP #$20
.3a50b0	a5 0c		lda $080c	                LDA SCRATCH
.3a50b2	f0 0e		beq $3a50c2	                BEQ not_found
.3a50b4					set_index
.3a50b4	c2 20		rep #$20	            REP #$20
.3a50b6	a5 0c		lda $080c	                LDA SCRATCH
.3a50b8	85 08		sta $0808	                STA INDEX
.3a50ba	e2 20		sep #$20	            SEP #$20
.3a50bc	a5 0e		lda $080e	                LDA SCRATCH+2
.3a50be	85 0a		sta $080a	                STA INDEX+2
.3a50c0	80 b9		bra $3a507b	                BRA check_binding       ; And check this next variable for a match
.3a50c2					not_found
.3a50c2	28		plp		                PLP
.3a50c3	18		clc		                CLC
.3a50c4	60		rts		            RTS
.3a50c5					found
.3a50c5	28		plp		                PLP
.3a50c6	38		sec		                SEC
.3a50c7	60		rts		            RTS
.3a50c8					VAR_REF
.3a50c8	08		php		                PHP
.3a50c9	20 3a 50	jsr $3a503a	            JSR VAR_FIND
.3a50cc	b0 1f		bcs $3a50ed	                BCS found
.3a50ce	08		php		            PHP
.3a50cf	c2 20		rep #$20	            REP #$20
.3a50d1	48		pha		            PHA
.3a50d2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a50d5	5b		tcd		            TCD
.3a50d6	68		pla		            PLA
.3a50d7	28		plp		            PLP
.3a50d8	e2 20		sep #$20	            SEP #$20
.3a50da	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a50dc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a50e0	c2 20		rep #$20	            REP #$20
.3a50e2	29 ff 00	and #$00ff	            AND #$00FF
.3a50e5	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a50e8	e2 20		sep #$20	            SEP #$20
.3a50ea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a50ed					found
.3a50ed	c2 30		rep #$30	            REP #$30
.3a50ef	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a50f2	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a50f4	85 23		sta $0823	                STA ARGUMENT1
.3a50f6	c8		iny		                INY
.3a50f7	c8		iny		                INY
.3a50f8	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a50fa	85 25		sta $0825	                STA ARGUMENT1+2
.3a50fc	e2 20		sep #$20	            SEP #$20
.3a50fe	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.3a5101	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5103	85 27		sta $0827	                STA ARGTYPE1
.3a5105	28		plp		done            PLP
.3a5106	60		rts		            RTS
.3a5107					VAR_ALLOC
.3a5107	08		php		                PHP
.3a5108	c2 20		rep #$20	            REP #$20
.3a510a	18		clc		                CLC                     ; Compute extent of the binding
.3a510b	a5 e1		lda $08e1	                LDA NEXTVAR
.3a510d	69 10 00	adc #$0010	                ADC #size(BINDING)
.3a5110	85 08		sta $0808	                STA INDEX
.3a5112	e2 20		sep #$20	            SEP #$20
.3a5114	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a5116	69 00		adc #$00	                ADC #0
.3a5118	85 0a		sta $080a	                STA INDEX+2
.3a511a	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.3a511c	90 27		bcc $3a5145	                BLT has_room
.3a511e	c2 20		rep #$20	            REP #$20
.3a5120	a5 08		lda $0808	                LDA INDEX
.3a5122	c5 ba		cmp $08ba	                CMP HEAP
.3a5124	90 1f		bcc $3a5145	                BLT has_room
.3a5126	08		php		            PHP
.3a5127	c2 20		rep #$20	            REP #$20
.3a5129	48		pha		            PHA
.3a512a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a512d	5b		tcd		            TCD
.3a512e	68		pla		            PLA
.3a512f	28		plp		            PLP
.3a5130	e2 20		sep #$20	            SEP #$20
.3a5132	a9 09		lda #$09	            LDA #ERR_RANGE
.3a5134	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5138	c2 20		rep #$20	            REP #$20
.3a513a	29 ff 00	and #$00ff	            AND #$00FF
.3a513d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a5140	e2 20		sep #$20	            SEP #$20
.3a5142	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5145					has_room
.3a5145	c2 20		rep #$20	            REP #$20
.3a5147	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.3a5149	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.3a514b	e2 20		sep #$20	            SEP #$20
.3a514d	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a514f	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5151	c2 20		rep #$20	            REP #$20
.3a5153	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.3a5155	85 e1		sta $08e1	                STA NEXTVAR
.3a5157	e2 20		sep #$20	            SEP #$20
.3a5159	a5 0a		lda $080a	                LDA INDEX+2
.3a515b	85 e3		sta $08e3	                STA NEXTVAR+2
.3a515d	28		plp		                PLP
.3a515e	60		rts		            RTS
.3a515f					VAR_CREATE
.3a515f	08		php		                PHP
.3a5160	e2 20		sep #$20	            SEP #$20
.3a5162	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.3a5164	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a5166	f0 33		beq $3a519b	                BEQ chk_string          ; If so: check to see if it's a string
.3a5168	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.3a516a	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.3a516c	d0 05		bne $3a5173	                BNE chk_float
.3a516e	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a5171	80 2f		bra $3a51a2	                BRA alloc_binding       ; And bind the variable
.3a5173	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.3a5175	d0 05		bne $3a517c	                BNE type_error
.3a5177	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a517a	80 26		bra $3a51a2	                BRA alloc_binding       ; And bind the variable
.3a517c					type_error
.3a517c	08		php		            PHP
.3a517d	c2 20		rep #$20	            REP #$20
.3a517f	48		pha		            PHA
.3a5180	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5183	5b		tcd		            TCD
.3a5184	68		pla		            PLA
.3a5185	28		plp		            PLP
.3a5186	e2 20		sep #$20	            SEP #$20
.3a5188	a9 04		lda #$04	            LDA #ERR_TYPE
.3a518a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a518e	c2 20		rep #$20	            REP #$20
.3a5190	29 ff 00	and #$00ff	            AND #$00FF
.3a5193	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a5196	e2 20		sep #$20	            SEP #$20
.3a5198	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a519b	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.3a519d	d0 03		bne $3a51a2	                BNE alloc_binding       ; No: just go ahead and bind it
.3a519f	20 42 16	jsr $3a1642	            JSR STRCPY
.3a51a2					alloc_binding
.3a51a2	c2 10		rep #$10	            REP #$10
.3a51a4	20 07 51	jsr $3a5107	            JSR VAR_ALLOC
.3a51a7	c2 30		rep #$30	            REP #$30
.3a51a9	18		clc		                CLC
.3a51aa	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a51ac	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a51af	85 08		sta $0808	                STA INDEX
.3a51b1	e2 20		sep #$20	            SEP #$20
.3a51b3	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a51b5	69 00		adc #$00	                ADC #0
.3a51b7	85 0a		sta $080a	                STA INDEX+2
.3a51b9	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.3a51bc	a9 00		lda #$00	                LDA #0
.3a51be	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.3a51c0	c8		iny		                INY
.3a51c1	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a51c4	d0 f8		bne $3a51be	                BNE blank_loop
.3a51c6	a0 00 00	ldy #$0000	                LDY #0
.3a51c9	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.3a51cb	f0 10		beq $3a51dd	                BEQ set_type
.3a51cd	20 aa 04	jsr $3a04aa	            JSR TOUPPERA
.3a51d0	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a51d3	90 08		bcc $3a51dd	                BCC set_type
.3a51d5	97 08		sta [$0808],y	                STA [INDEX],Y
.3a51d7	c8		iny		                INY
.3a51d8	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a51db	d0 ec		bne $3a51c9	                BNE name_loop
.3a51dd					set_type
.3a51dd	c2 20		rep #$20	            REP #$20
.3a51df	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.3a51e2	a5 23		lda $0823	                LDA ARGUMENT1
.3a51e4	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a51e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a51e8	c8		iny		                INY
.3a51e9	c8		iny		                INY
.3a51ea	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a51ec	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.3a51ee	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.3a51f1	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a51f3	c8		iny		                INY
.3a51f4	c8		iny		                INY
.3a51f5	e2 20		sep #$20	            SEP #$20
.3a51f7	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a51f9	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a51fb	c2 20		rep #$20	            REP #$20
.3a51fd	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a51ff	85 e4		sta $08e4	                STA VARIABLES
.3a5201	e2 20		sep #$20	            SEP #$20
.3a5203	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a5205	85 e6		sta $08e6	                STA VARIABLES+2
.3a5207	e2 20		sep #$20	            SEP #$20
.3a5209	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.3a520c	a5 27		lda $0827	                LDA ARGTYPE1
.3a520e	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5210	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.3a5212	f0 02		beq $3a5216	                BEQ set_ref             ; Yes: add a reference count to it
.3a5214	28		plp		done            PLP
.3a5215	60		rts		            RTS
.3a5216					set_ref
.3a5216	c2 20		rep #$20	            REP #$20
.3a5218	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.3a521a	85 c0		sta $08c0	                STA CURRBLOCK
.3a521c	e2 20		sep #$20	            SEP #$20
.3a521e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5220	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5222	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a5225	20 73 12	jsr $3a1273	            JSR HEAP_ADDREF
.3a5228	80 ea		bra $3a5214	                BRA done
.3a522a					VAR_SET
.3a522a	08		php		                PHP
.3a522b	c2 30		rep #$30	            REP #$30
.3a522d	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.3a522f	d0 06		bne $3a5237	                BNE use_find
.3a5231	e2 20		sep #$20	            SEP #$20
.3a5233	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a5235	f0 05		beq $3a523c	                BEQ use_create
.3a5237					use_find
.3a5237	20 3a 50	jsr $3a503a	            JSR VAR_FIND
.3a523a	b0 05		bcs $3a5241	                BCS found
.3a523c					use_create
.3a523c	20 5f 51	jsr $3a515f	            JSR VAR_CREATE
.3a523f	80 4e		bra $3a528f	                BRA done
.3a5241					found
.3a5241	e2 20		sep #$20	            SEP #$20
.3a5243	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.3a5245	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a5247	f0 33		beq $3a527c	                BEQ chk_string          ; Yes: check to see if it's string
.3a5249	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.3a524b	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.3a524d	d0 05		bne $3a5254	                BNE chk_float
.3a524f	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a5252	80 2c		bra $3a5280	                BRA set_val
.3a5254	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.3a5256	d0 05		bne $3a525d	                BNE type_error          ; No: throw an error
.3a5258	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a525b	80 23		bra $3a5280	                BRA set_val
.3a525d					type_error
.3a525d	08		php		            PHP
.3a525e	c2 20		rep #$20	            REP #$20
.3a5260	48		pha		            PHA
.3a5261	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5264	5b		tcd		            TCD
.3a5265	68		pla		            PLA
.3a5266	28		plp		            PLP
.3a5267	e2 20		sep #$20	            SEP #$20
.3a5269	a9 04		lda #$04	            LDA #ERR_TYPE
.3a526b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a526f	c2 20		rep #$20	            REP #$20
.3a5271	29 ff 00	and #$00ff	            AND #$00FF
.3a5274	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a5277	e2 20		sep #$20	            SEP #$20
.3a5279	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a527c	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.3a527e	f0 11		beq $3a5291	                BEQ set_string          ; Yes: set the string value of the variable
.3a5280					set_val
.3a5280	c2 30		rep #$30	            REP #$30
.3a5282	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a5285	a5 23		lda $0823	                LDA ARGUMENT1
.3a5287	97 08		sta [$0808],y	                STA [INDEX],Y
.3a5289	c8		iny		                INY
.3a528a	c8		iny		                INY
.3a528b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a528d	97 08		sta [$0808],y	                STA [INDEX],Y
.3a528f					done
.3a528f	28		plp		                PLP
.3a5290	60		rts		            RTS
.3a5291					set_string
.3a5291	20 42 16	jsr $3a1642	            JSR STRCPY
.3a5294	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.3a5297	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5299	85 c0		sta $08c0	                STA CURRBLOCK
.3a529b	c8		iny		                INY
.3a529c	c8		iny		                INY
.3a529d	e2 20		sep #$20	            SEP #$20
.3a529f	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a52a1	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a52a3	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a52a6	20 92 12	jsr $3a1292	            JSR HEAP_REMREF
.3a52a9	e2 20		sep #$20	            SEP #$20
.3a52ab	a5 27		lda $0827	                LDA ARGTYPE1
.3a52ad	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.3a52af	f0 02		beq $3a52b3	                BEQ add_ref             ; Yes: add a reference to it
.3a52b1	80 cd		bra $3a5280	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.3a52b3					add_ref
.3a52b3	c2 20		rep #$20	            REP #$20
.3a52b5	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.3a52b7	85 c0		sta $08c0	                STA CURRBLOCK
.3a52b9	e2 20		sep #$20	            SEP #$20
.3a52bb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a52bd	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a52bf	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a52c2	20 73 12	jsr $3a1273	            JSR HEAP_ADDREF
.3a52c5	80 b9		bra $3a5280	                BRA set_val
.3a52c7					VAR_FINDNAME
.3a52c7	08		php		                PHP
.3a52c8	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a52cb	e2 20		sep #$20	            SEP #$20
.3a52cd	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.3a52cf	20 36 04	jsr $3a0436	            JSR ISALPHA
.3a52d2	90 42		bcc $3a5316	                BCC not_found
.3a52d4	c2 20		rep #$20	            REP #$20
.3a52d6	a5 00		lda $0800	                LDA BIP
.3a52d8	85 e7		sta $08e7	                STA TOFIND
.3a52da	e2 20		sep #$20	            SEP #$20
.3a52dc	a5 02		lda $0802	                LDA BIP+2
.3a52de	85 e9		sta $08e9	                STA TOFIND+2
.3a52e0					loop
.3a52e0	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a52e3	a7 00		lda [$0800]	                LDA [BIP]
.3a52e5	f0 0d		beq $3a52f4	                BEQ is_float        ; If it's EOL, the variable is a float
.3a52e7	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.3a52e9	f0 14		beq $3a52ff	                BEQ is_string
.3a52eb	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.3a52ed	f0 09		beq $3a52f8	                BEQ is_integer
.3a52ef	20 f4 4f	jsr $3a4ff4	            JSR ISVARCHAR
.3a52f2	b0 ec		bcs $3a52e0	                BCS loop            ; Check the next one
.3a52f4	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.3a52f6	80 0c		bra $3a5304	                BRA set_type
.3a52f8					is_integer
.3a52f8	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a52fb	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a52fd	80 05		bra $3a5304	                BRA set_type
.3a52ff					is_string
.3a52ff	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a5302	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5304	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.3a5306	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a5309	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.3a530b	d0 06		bne $3a5313	                BNE done            ; No: we're done... it's just a scalar variable
.3a530d	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.3a530f	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.3a5311	85 ea		sta $08ea	                STA TOFINDTYPE
.3a5313					done
.3a5313	28		plp		                PLP
.3a5314	38		sec		                SEC
.3a5315	60		rts		            RTS
.3a5316	28		plp		not_found       PLP
.3a5317	18		clc		                CLC
.3a5318	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.3a5319					OP_INT_ADD
.3a5319	08		php		            PHP
.3a531a	c2 20		rep #$20	            REP #$20
.3a531c	18		clc		            CLC
.3a531d	a5 23		lda $0823	            LDA ARGUMENT1
.3a531f	65 29		adc $0829	            ADC ARGUMENT2
.3a5321	85 23		sta $0823	            STA ARGUMENT1
.3a5323	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5325	65 2b		adc $082b	            ADC ARGUMENT2+2
.3a5327	85 25		sta $0825	            STA ARGUMENT1+2
.3a5329	28		plp		            PLP
.3a532a	60		rts		            RTS
.3a532b					OP_INT_SUB
.3a532b	08		php		            PHP
.3a532c	c2 20		rep #$20	            REP #$20
.3a532e	38		sec		            SEC
.3a532f	a5 23		lda $0823	            LDA ARGUMENT1
.3a5331	e5 29		sbc $0829	            SBC ARGUMENT2
.3a5333	85 23		sta $0823	            STA ARGUMENT1
.3a5335	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5337	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a5339	85 25		sta $0825	            STA ARGUMENT1+2
.3a533b	28		plp		            PLP
.3a533c	60		rts		            RTS
.3a533d					OP_INT_MUL
.3a533d	08		php		            PHP
.3a533e					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.3a533e	c2 20		rep #$20	            REP #$20
.3a5340	3b		tsc		            TSC
.3a5341	38		sec		            SEC
.3a5342	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a5345	1b		tcs		            TCS
.3a5346	c2 30		rep #$30	            REP #$30
.3a5348	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.3a534b	83 01		sta $01,s	            STA L_SIGN
.3a534d	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.3a534f	83 05		sta $05,s	            STA L_RESULT+2
.3a5351	83 07		sta $07,s	            STA L_RESULT+4
.3a5353	83 09		sta $09,s	            STA L_RESULT+6
.3a5355	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.3a5357	10 18		bpl $3a5371	            BPL chk_sign2
.3a5359	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.3a535c	83 01		sta $01,s	            STA L_SIGN
.3a535e	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.3a5360	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5363	85 25		sta $0825	            STA ARGUMENT1+2
.3a5365	a5 23		lda $0823	            LDA ARGUMENT1
.3a5367	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a536a	1a		inc a		            INC A
.3a536b	85 23		sta $0823	            STA ARGUMENT1
.3a536d	d0 02		bne $3a5371	            BNE chk_sign2
.3a536f	e6 25		inc $0825	            INC ARGUMENT1+2
.3a5371	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.3a5373	10 1a		bpl $3a538f	            BPL chk_over
.3a5375	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.3a5377	49 00 80	eor #$8000	            EOR #$8000
.3a537a	83 01		sta $01,s	            STA L_SIGN
.3a537c	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.3a537e	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5381	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5383	a5 29		lda $0829	            LDA ARGUMENT2
.3a5385	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5388	1a		inc a		            INC A
.3a5389	85 29		sta $0829	            STA ARGUMENT2
.3a538b	d0 02		bne $3a538f	            BNE chk_over
.3a538d	e6 2b		inc $082b	            INC ARGUMENT2+2
.3a538f					chk_over
.3a538f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5391	f0 04		beq $3a5397	            BEQ do_mult
.3a5393	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5395	d0 5a		bne $3a53f1	            BNE overflow
.3a5397					do_mult
.3a5397	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.3a5399	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a539d	a5 29		lda $0829	            LDA ARGUMENT2
.3a539f	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a53a3	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a53a7	83 03		sta $03,s	            STA L_RESULT
.3a53a9	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a53ad	83 05		sta $05,s	            STA L_RESULT+2
.3a53af	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.3a53b1	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a53b5	a5 29		lda $0829	            LDA ARGUMENT2
.3a53b7	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a53bb	18		clc		            CLC
.3a53bc	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a53c0	63 05		adc $05,s	            ADC L_RESULT+2
.3a53c2	83 05		sta $05,s	            STA L_RESULT+2
.3a53c4	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a53c8	63 07		adc $07,s	            ADC L_RESULT+4
.3a53ca	83 07		sta $07,s	            STA L_RESULT+4
.3a53cc	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.3a53ce	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a53d2	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a53d4	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a53d8	18		clc		            CLC
.3a53d9	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a53dd	63 05		adc $05,s	            ADC L_RESULT+2
.3a53df	83 05		sta $05,s	            STA L_RESULT+2
.3a53e1	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a53e5	63 07		adc $07,s	            ADC L_RESULT+4
.3a53e7	83 07		sta $07,s	            STA L_RESULT+4
.3a53e9	a3 07		lda $07,s	            LDA L_RESULT+4
.3a53eb	f0 23		beq $3a5410	            BEQ no_overflow
.3a53ed	a3 09		lda $09,s	            LDA L_RESULT+6
.3a53ef	f0 1f		beq $3a5410	            BEQ no_overflow
.3a53f1					overflow
.3a53f1	08		php		            PHP
.3a53f2	c2 20		rep #$20	            REP #$20
.3a53f4	48		pha		            PHA
.3a53f5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a53f8	5b		tcd		            TCD
.3a53f9	68		pla		            PLA
.3a53fa	28		plp		            PLP
.3a53fb	e2 20		sep #$20	            SEP #$20
.3a53fd	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a53ff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5403	c2 20		rep #$20	            REP #$20
.3a5405	29 ff 00	and #$00ff	            AND #$00FF
.3a5408	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a540b	e2 20		sep #$20	            SEP #$20
.3a540d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5410					no_overflow
.3a5410	c2 30		rep #$30	            REP #$30
.3a5412	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.3a5414	10 16		bpl $3a542c	            BPL ret_result          ; If positive: just return the result
.3a5416	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.3a5418	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a541b	83 05		sta $05,s	            STA L_RESULT+2
.3a541d	a3 03		lda $03,s	            LDA L_RESULT
.3a541f	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5422	1a		inc a		            INC A
.3a5423	83 03		sta $03,s	            STA L_RESULT
.3a5425	d0 05		bne $3a542c	            BNE ret_result
.3a5427	a3 05		lda $05,s	            LDA L_RESULT+2
.3a5429	1a		inc a		            INC A
.3a542a	83 05		sta $05,s	            STA L_RESULT+2
.3a542c					ret_result
.3a542c	a3 03		lda $03,s	            LDA L_RESULT
.3a542e	85 23		sta $0823	            STA ARGUMENT1
.3a5430	a3 05		lda $05,s	            LDA L_RESULT+2
.3a5432	85 25		sta $0825	            STA ARGUMENT1+2
.3a5434	c2 20		rep #$20	            REP #$20
.3a5436	3b		tsc		            TSC
.3a5437	18		clc		            CLC
.3a5438	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a543b	1b		tcs		            TCS
.3a543c	28		plp		            PLP
.3a543d	60		rts		            RTS
.3a543e					OP_INT_LT
.3a543e	08		php		            PHP
.3a543f	c2 20		rep #$20	            REP #$20
.3a5441	a5 23		lda $0823	            LDA ARGUMENT1
.3a5443	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5445	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5447	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a5449	50 03		bvc $3a544e	            BVC skip_eor
.3a544b	49 00 80	eor #$8000	            EOR #$8000
.3a544e	30 06		bmi $3a5456	skip_eor    BMI ret_true
.3a5450	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5452	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5454	80 07		bra $3a545d	            BRA done
.3a5456	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5459	85 23		sta $0823	            STA ARGUMENT1
.3a545b	85 25		sta $0825	            STA ARGUMENT1+2
.3a545d	28		plp		done        PLP
.3a545e	60		rts		            RTS
.3a545f					OP_INT_GT
.3a545f	08		php		            PHP
.3a5460	c2 20		rep #$20	            REP #$20
.3a5462	a5 23		lda $0823	            LDA ARGUMENT1
.3a5464	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5466	d0 0c		bne $3a5474	            BNE test_fully
.3a5468	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a546a	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a546c	d0 06		bne $3a5474	            BNE test_fully
.3a546e	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5470	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5472	80 16		bra $3a548a	            BRA done
.3a5474	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a5476	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5478	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a547a	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a547c	50 03		bvc $3a5481	            BVC skip_eor
.3a547e	49 00 80	eor #$8000	            EOR #$8000
.3a5481	10 eb		bpl $3a546e	skip_eor    BPL ret_false
.3a5483	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5486	85 23		sta $0823	            STA ARGUMENT1
.3a5488	85 25		sta $0825	            STA ARGUMENT1+2
.3a548a	28		plp		done        PLP
.3a548b	60		rts		            RTS
.3a548c					OP_INT_EQ
.3a548c	08		php		            PHP
.3a548d	c2 20		rep #$20	            REP #$20
.3a548f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5491	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a5493	d0 0f		bne $3a54a4	            BNE ret_false
.3a5495	a5 29		lda $0829	            LDA ARGUMENT2
.3a5497	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5499	d0 09		bne $3a54a4	            BNE ret_false
.3a549b	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a549e	85 23		sta $0823	            STA ARGUMENT1
.3a54a0	85 25		sta $0825	            STA ARGUMENT1+2
.3a54a2	80 04		bra $3a54a8	            BRA done
.3a54a4	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a54a6	64 25		stz $0825	            STZ ARGUMENT1+2
.3a54a8	28		plp		done        PLP
.3a54a9	60		rts		            RTS
.3a54aa					OP_INT_NE
.3a54aa	08		php		            PHP
.3a54ab	c2 20		rep #$20	            REP #$20
.3a54ad	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a54af	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a54b1	d0 0c		bne $3a54bf	            BNE ret_true
.3a54b3	a5 29		lda $0829	            LDA ARGUMENT2
.3a54b5	c5 23		cmp $0823	            CMP ARGUMENT1
.3a54b7	d0 06		bne $3a54bf	            BNE ret_true
.3a54b9	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a54bb	64 25		stz $0825	            STZ ARGUMENT1+2
.3a54bd	80 07		bra $3a54c6	            BRA done
.3a54bf	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a54c2	85 23		sta $0823	            STA ARGUMENT1
.3a54c4	85 25		sta $0825	            STA ARGUMENT1+2
.3a54c6	28		plp		done        PLP
.3a54c7	60		rts		            RTS
.3a54c8					OP_INT_GTE
.3a54c8	08		php		            PHP
.3a54c9	c2 20		rep #$20	            REP #$20
.3a54cb	a5 23		lda $0823	            LDA ARGUMENT1
.3a54cd	c5 29		cmp $0829	            CMP ARGUMENT2
.3a54cf	d0 0f		bne $3a54e0	            BNE test_fully
.3a54d1	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a54d3	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a54d5	d0 09		bne $3a54e0	            BNE test_fully
.3a54d7	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a54da	85 23		sta $0823	            STA ARGUMENT1
.3a54dc	85 25		sta $0825	            STA ARGUMENT1+2
.3a54de	80 13		bra $3a54f3	            BRA done
.3a54e0	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a54e2	c5 23		cmp $0823	            CMP ARGUMENT1
.3a54e4	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a54e6	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a54e8	50 03		bvc $3a54ed	            BVC skip_eor
.3a54ea	49 00 80	eor #$8000	            EOR #$8000
.3a54ed	30 e8		bmi $3a54d7	skip_eor    BMI ret_true
.3a54ef	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a54f1	64 25		stz $0825	            STZ ARGUMENT1+2
.3a54f3	28		plp		done        PLP
.3a54f4	60		rts		            RTS
.3a54f5					OP_INT_LTE
.3a54f5	08		php		            PHP
.3a54f6	c2 20		rep #$20	            REP #$20
.3a54f8	a5 23		lda $0823	            LDA ARGUMENT1
.3a54fa	c5 29		cmp $0829	            CMP ARGUMENT2
.3a54fc	d0 0f		bne $3a550d	            BNE test_fully
.3a54fe	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5500	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a5502	d0 09		bne $3a550d	            BNE test_fully
.3a5504	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5507	85 23		sta $0823	            STA ARGUMENT1
.3a5509	85 25		sta $0825	            STA ARGUMENT1+2
.3a550b	80 13		bra $3a5520	            BRA done
.3a550d	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.3a550f	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5511	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5513	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a5515	50 03		bvc $3a551a	            BVC skip_eor
.3a5517	49 00 80	eor #$8000	            EOR #$8000
.3a551a	30 e8		bmi $3a5504	skip_eor    BMI ret_true
.3a551c	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a551e	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5520	28		plp		done        PLP
.3a5521	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.3a5522					UINT_DIV_A_X
.3a5522	08		php		                    PHP
.3a5523	c2 20		rep #$20	            REP #$20
.3a5525	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.3a5529	8a		txa		                    TXA
.3a552a	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.3a552e	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.3a5532	aa		tax		                    TAX
.3a5533	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.3a5537	28		plp		                    PLP
.3a5538	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.3a5539					FIXINT_TO_FP
.3a5539	08		php		                    PHP
.3a553a	e2 20		sep #$20	            SEP #$20
.3a553c	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a553e	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.3a5542	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.3a5544	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.3a5548	c2 20		rep #$20	            REP #$20
.3a554a	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a554c	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.3a5550	a5 25		lda $0825	                    LDA ARGUMENT1+2
.3a5552	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.3a5556	a9 00 00	lda #$0000	                    LDA #0
.3a5559	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.3a555d	a9 00 01	lda #$0100	                    LDA #$0100
.3a5560	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.3a5564	ea		nop		                    NOP
.3a5565	ea		nop		                    NOP
.3a5566	ea		nop		                    NOP
.3a5567	ea		nop		                    NOP
.3a5568	ea		nop		                    NOP
.3a5569	ea		nop		                    NOP
.3a556a	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a556e	85 23		sta $0823	                    STA ARGUMENT1
.3a5570	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.3a5574	85 25		sta $0825	                    STA ARGUMENT1+2
.3a5576	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.3a5579	85 27		sta $0827	                    STA ARGTYPE1
.3a557b	28		plp		                    PLP
.3a557c	60		rts		            RTS
.3a557d	08		php		OP_FP_SUB       PHP
.3a557e	e2 20		sep #$20	            SEP #$20
.3a5580	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5582	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5586	80 09		bra $3a5591	                BRA FP_ADD_SUB
.3a5588	08		php		OP_FP_ADD       PHP
.3a5589	e2 20		sep #$20	            SEP #$20
.3a558b	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a558d	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5591	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.3a5593	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.3a5597	c2 20		rep #$20	            REP #$20
.3a5599	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a559b	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.3a559f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a55a1	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.3a55a5	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a55a7	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.3a55ab	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a55ad	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.3a55b1	ea		nop		                NOP
.3a55b2	ea		nop		                NOP
.3a55b3	ea		nop		                NOP
.3a55b4	e2 20		sep #$20	            SEP #$20
.3a55b6	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.3a55ba	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a55bc	d0 10		bne $3a55ce	                BNE fp_add_error            ; If an issue was raise, process the math error
.3a55be	c2 20		rep #$20	            REP #$20
.3a55c0	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.3a55c4	85 23		sta $0823	                STA ARGUMENT1
.3a55c6	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.3a55ca	85 25		sta $0825	                STA ARGUMENT1+2
.3a55cc	28		plp		fp_add_done     PLP
.3a55cd	60		rts		            RTS
.3a55ce					fp_add_error
.3a55ce	20 69 56	jsr $3a5669	            JSR FP_MATH_ERROR
.3a55d1	80 f9		bra $3a55cc	                BRA fp_add_done
.3a55d3	08		php		OP_FP_DIV       PHP
.3a55d4	e2 20		sep #$20	            SEP #$20
.3a55d6	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a55d8	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a55dc	a9 00		lda #$00	                LDA #0
.3a55de	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a55e2	c2 20		rep #$20	            REP #$20
.3a55e4	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a55e6	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a55ea	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a55ec	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a55f0	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a55f2	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a55f6	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a55f8	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a55fc	ea		nop		                NOP
.3a55fd	ea		nop		                NOP
.3a55fe	ea		nop		                NOP
.3a55ff	e2 20		sep #$20	            SEP #$20
.3a5601	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.3a5605	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.3a5607	d0 10		bne $3a5619	                BNE fp_div_error            ; If an issue was raise, process the math error
.3a5609	c2 20		rep #$20	            REP #$20
.3a560b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a560f	85 23		sta $0823	                STA ARGUMENT1
.3a5611	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5615	85 25		sta $0825	                STA ARGUMENT1+2
.3a5617	28		plp		fp_div_done     PLP
.3a5618	60		rts		            RTS
.3a5619					fp_div_error
.3a5619	20 69 56	jsr $3a5669	            JSR FP_MATH_ERROR
.3a561c	80 f9		bra $3a5617	                BRA fp_div_done
.3a561e	08		php		OP_FP_MUL       PHP
.3a561f	e2 20		sep #$20	            SEP #$20
.3a5621	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5623	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5627	a9 00		lda #$00	                LDA #0
.3a5629	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a562d	c2 20		rep #$20	            REP #$20
.3a562f	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a5631	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5635	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5637	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a563b	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a563d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5641	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a5643	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5647	ea		nop		                NOP
.3a5648	ea		nop		                NOP
.3a5649	ea		nop		                NOP
.3a564a	e2 20		sep #$20	            SEP #$20
.3a564c	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.3a5650	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a5652	d0 10		bne $3a5664	                BNE fp_mul_error            ; If an issue was raise, process the math error
.3a5654	c2 20		rep #$20	            REP #$20
.3a5656	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a565a	85 23		sta $0823	                STA ARGUMENT1
.3a565c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5660	85 25		sta $0825	                STA ARGUMENT1+2
.3a5662	28		plp		fp_mul_done     PLP
.3a5663	60		rts		            RTS
.3a5664					fp_mul_error
.3a5664	20 69 56	jsr $3a5669	            JSR FP_MATH_ERROR
.3a5667	80 f9		bra $3a5662	                BRA fp_mul_done
.3a5669					FP_MATH_ERROR
.3a5669	e2 20		sep #$20	            SEP #$20
.3a566b	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.3a566d	f0 20		beq $3a568f	                BEQ check_over              ; No: check for overflow
.3a566f	00		brk #		                BRK
.3a5670	08		php		            PHP
.3a5671	c2 20		rep #$20	            REP #$20
.3a5673	48		pha		            PHA
.3a5674	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5677	5b		tcd		            TCD
.3a5678	68		pla		            PLA
.3a5679	28		plp		            PLP
.3a567a	e2 20		sep #$20	            SEP #$20
.3a567c	a9 0c		lda #$0c	            LDA #ERR_NAN
.3a567e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5682	c2 20		rep #$20	            REP #$20
.3a5684	29 ff 00	and #$00ff	            AND #$00FF
.3a5687	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a568a	e2 20		sep #$20	            SEP #$20
.3a568c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a568f	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.3a5691	f0 1f		beq $3a56b2	                BEQ check_under             ; No: check for underflow
.3a5693	08		php		            PHP
.3a5694	c2 20		rep #$20	            REP #$20
.3a5696	48		pha		            PHA
.3a5697	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a569a	5b		tcd		            TCD
.3a569b	68		pla		            PLA
.3a569c	28		plp		            PLP
.3a569d	e2 20		sep #$20	            SEP #$20
.3a569f	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a56a1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a56a5	c2 20		rep #$20	            REP #$20
.3a56a7	29 ff 00	and #$00ff	            AND #$00FF
.3a56aa	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a56ad	e2 20		sep #$20	            SEP #$20
.3a56af	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a56b2	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.3a56b4	f0 1f		beq $3a56d5	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.3a56b6	08		php		            PHP
.3a56b7	c2 20		rep #$20	            REP #$20
.3a56b9	48		pha		            PHA
.3a56ba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a56bd	5b		tcd		            TCD
.3a56be	68		pla		            PLA
.3a56bf	28		plp		            PLP
.3a56c0	e2 20		sep #$20	            SEP #$20
.3a56c2	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.3a56c4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a56c8	c2 20		rep #$20	            REP #$20
.3a56ca	29 ff 00	and #$00ff	            AND #$00FF
.3a56cd	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a56d0	e2 20		sep #$20	            SEP #$20
.3a56d2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a56d5					done
.3a56d5	60		rts		            RTS
.3a56d6					FP_MUL10
.3a56d6	08		php		                PHP
.3a56d7	e2 20		sep #$20	            SEP #$20
.3a56d9	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.3a56db	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a56df	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.3a56e1	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a56e5	c2 20		rep #$20	            REP #$20
.3a56e7	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.3a56ea	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a56ee	a9 00 00	lda #$0000	                LDA #0
.3a56f1	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a56f5	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.3a56f7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a56fb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a56fd	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5701	ea		nop		                NOP
.3a5702	ea		nop		                NOP
.3a5703	ea		nop		                NOP
.3a5704	e2 20		sep #$20	            SEP #$20
.3a5706	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.3a570a	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.3a570c	f0 01		beq $3a570f	                BEQ ret_result
.3a570e	00		brk #		                BRK                             ; There was an error...
.3a570f					ret_result
.3a570f	c2 20		rep #$20	            REP #$20
.3a5711	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.3a5715	85 23		sta $0823	                STA ARGUMENT1
.3a5717	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a571b	85 25		sta $0825	                STA ARGUMENT1+2
.3a571d	28		plp		                PLP
.3a571e	60		rts		            RTS
.3a571f					FP_DIV10
.3a571f	08		php		                PHP
.3a5720	e2 20		sep #$20	            SEP #$20
.3a5722	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.3a5724	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5728	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.3a572a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a572e	c2 20		rep #$20	            REP #$20
.3a5730	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.3a5733	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5737	a9 00 00	lda #$0000	                LDA #0
.3a573a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a573e	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.3a5740	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5744	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5746	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a574a	ea		nop		                NOP
.3a574b	ea		nop		                NOP
.3a574c	ea		nop		                NOP
.3a574d	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.3a5751	85 23		sta $0823	                STA ARGUMENT1
.3a5753	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5757	85 25		sta $0825	                STA ARGUMENT1+2
.3a5759	28		plp		                PLP
.3a575a	60		rts		            RTS

;******  Return to file: src\floats.s

.3a575b					FARG1EQ0
.3a575b	08		php		                PHP
.3a575c	c2 20		rep #$20	            REP #$20
.3a575e	a5 23		lda $0823	                LDA ARGUMENT1
.3a5760	d0 0a		bne $3a576c	                BNE return_false
.3a5762	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5764	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.3a5767	d0 03		bne $3a576c	                BNE return_false
.3a5769	28		plp		return_true     PLP
.3a576a	38		sec		                SEC
.3a576b	60		rts		            RTS
.3a576c	28		plp		return_false    PLP
.3a576d	18		clc		                CLC
.3a576e	60		rts		            RTS
.3a576f					SHIFTDEC
.3a576f	08		php		                PHP
.3a5770	e2 20		sep #$20	            SEP #$20
.3a5772	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.3a5773	e9 30		sbc #$30	                SBC #'0'
.3a5775	20 ce 04	jsr $3a04ce	            JSR MULINT10
.3a5778	c2 20		rep #$20	            REP #$20
.3a577a	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.3a577d	18		clc		                CLC
.3a577e	65 23		adc $0823	                ADC ARGUMENT1
.3a5780	85 23		sta $0823	                STA ARGUMENT1
.3a5782	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5784	69 00 00	adc #$0000	                ADC #0
.3a5787	85 25		sta $0825	                STA ARGUMENT1+2
.3a5789	28		plp		                PLP
.3a578a	60		rts		            RTS
.3a578b					SHIFTHEX
.3a578b	08		php		                PHP
.3a578c	e2 20		sep #$20	            SEP #$20
.3a578e	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.3a5790	90 04		bcc $3a5796	                BLT not_09
.3a5792	c9 3a		cmp #$3a	                CMP #'9'+1
.3a5794	90 1c		bcc $3a57b2	                BLT is_09
.3a5796	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.3a5798	90 04		bcc $3a579e	                BLT not_lc
.3a579a	c9 67		cmp #$67	                CMP #'f'+1
.3a579c	90 0a		bcc $3a57a8	                BLT is_lc
.3a579e	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.3a57a0	90 04		bcc $3a57a6	                BLT not_uc
.3a57a2	c9 47		cmp #$47	                CMP #'F'+1
.3a57a4	90 07		bcc $3a57ad	                BLT is_uc
.3a57a6	80 31		bra $3a57d9	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.3a57a8	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.3a57a9	e9 57		sbc #$57	                SBC #'a'-10
.3a57ab	80 08		bra $3a57b5	                BRA shift
.3a57ad	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.3a57ae	e9 37		sbc #$37	                SBC #'A'-10
.3a57b0	80 03		bra $3a57b5	                BRA shift
.3a57b2	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.3a57b3	e9 30		sbc #$30	                SBC #'0'
.3a57b5					shift
.3a57b5	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a57b7	26 24		rol $0824	                ROL ARGUMENT1+1
.3a57b9	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57bb	26 26		rol $0826	                ROL ARGUMENT1+3
.3a57bd	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a57bf	26 24		rol $0824	                ROL ARGUMENT1+1
.3a57c1	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57c3	26 26		rol $0826	                ROL ARGUMENT1+3
.3a57c5	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a57c7	26 24		rol $0824	                ROL ARGUMENT1+1
.3a57c9	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57cb	26 26		rol $0826	                ROL ARGUMENT1+3
.3a57cd	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a57cf	26 24		rol $0824	                ROL ARGUMENT1+1
.3a57d1	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57d3	26 26		rol $0826	                ROL ARGUMENT1+3
.3a57d5	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.3a57d7	85 23		sta $0823	                STA ARGUMENT1
.3a57d9	28		plp		done            PLP
.3a57da	60		rts		            RTS
.3a57db					SHIFTBIN
.3a57db	08		php		                PHP
.3a57dc	e2 20		sep #$20	            SEP #$20
.3a57de	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.3a57e0	f0 06		beq $3a57e8	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.3a57e2	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.3a57e4	f0 0a		beq $3a57f0	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.3a57e6	80 0f		bra $3a57f7	                BRA done
.3a57e8					shift_0
.3a57e8	c2 20		rep #$20	            REP #$20
.3a57ea	06 23		asl $0823	                ASL ARGUMENT1
.3a57ec	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57ee	80 07		bra $3a57f7	                BRA done
.3a57f0					shift_1
.3a57f0	c2 20		rep #$20	            REP #$20
.3a57f2	38		sec		                SEC
.3a57f3	26 23		rol $0823	                ROL ARGUMENT1
.3a57f5	26 25		rol $0825	                ROL ARGUMENT1+2
.3a57f7	28		plp		done            PLP
.3a57f8	60		rts		            RTS
.3a57f9					FP_POW10
.3a57f9	08		php		                PHP
.3a57fa	e2 30		sep #$30	            SEP #$30
.3a57fc	a5 61		lda $0861	                LDA MARG4
.3a57fe	f0 0d		beq $3a580d	                BEQ return_1
.3a5800	aa		tax		                TAX
.3a5801	a5 69		lda $0869	                LDA MARG6
.3a5803	d0 15		bne $3a581a	                BNE do_div
.3a5805	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.3a5807	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a580b	80 15		bra $3a5822	                BRA start_loop
.3a580d					return_1
.3a580d	e2 20		sep #$20	            SEP #$20
.3a580f	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.3a5811	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5815	ea		nop		                NOP
.3a5816	ea		nop		                NOP
.3a5817	ea		nop		                NOP
.3a5818	80 62		bra $3a587c	                BRA ret_result                      ; And return the result
.3a581a					do_div
.3a581a	e2 20		sep #$20	            SEP #$20
.3a581c	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.3a581e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5822					start_loop
.3a5822	e2 20		sep #$20	            SEP #$20
.3a5824	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a5826	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a582a	c2 20		rep #$20	            REP #$20
.3a582c	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.3a582f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5833	a9 00 00	lda #$0000	                LDA #0
.3a5836	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a583a					loop
.3a583a	c2 20		rep #$20	            REP #$20
.3a583c	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.3a583f	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5843	a9 00 00	lda #$0000	                LDA #0
.3a5846	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a584a	ea		nop		                NOP                                 ; Wait for the operation to complete
.3a584b	ea		nop		                NOP
.3a584c	ea		nop		                NOP
.3a584d	ca		dex		                DEX                                 ; Count down
.3a584e	f0 2c		beq $3a587c	                BEQ ret_result                      ; If 0, then we're done
.3a5850	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.3a5854	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.3a5858	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a585c	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.3a5860	e2 20		sep #$20	            SEP #$20
.3a5862	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.3a5864	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a5868	c2 20		rep #$20	            REP #$20
.3a586a	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.3a586e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5872	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.3a5876	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a587a	80 be		bra $3a583a	                BRA loop
.3a587c					ret_result
.3a587c	c2 20		rep #$20	            REP #$20
.3a587e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.3a5882	85 23		sta $0823	                STA ARGUMENT1
.3a5884	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.3a5888	85 25		sta $0825	                STA ARGUMENT1+2
.3a588a	e2 20		sep #$20	            SEP #$20
.3a588c	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a588e	85 27		sta $0827	                STA ARGTYPE1
.3a5890	28		plp		done            PLP
.3a5891	60		rts		            RTS
.3a5892					PACKFLOAT
.3a5892	08		php		                PHP
.3a5893	c2 20		rep #$20	            REP #$20
.3a5895	a5 5d		lda $085d	            LDA MARG3
.3a5897	85 23		sta $0823	            STA ARGUMENT1
.3a5899	a5 5f		lda $085f	            LDA MARG3+2
.3a589b	85 25		sta $0825	            STA ARGUMENT1+2
.3a589d	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a58a0	c2 20		rep #$20	            REP #$20
.3a58a2	a5 23		lda $0823	            LDA ARGUMENT1
.3a58a4	85 29		sta $0829	            STA ARGUMENT2
.3a58a6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a58a8	85 2b		sta $082b	            STA ARGUMENT2+2
.3a58aa	c2 20		rep #$20	            REP #$20
.3a58ac	a5 59		lda $0859	            LDA MARG2
.3a58ae	85 23		sta $0823	            STA ARGUMENT1
.3a58b0	a5 5b		lda $085b	            LDA MARG2+2
.3a58b2	85 25		sta $0825	            STA ARGUMENT1+2
.3a58b4	20 d3 55	jsr $3a55d3	            JSR OP_FP_DIV
.3a58b7	c2 20		rep #$20	            REP #$20
.3a58b9	a5 55		lda $0855	            LDA MARG1
.3a58bb	85 29		sta $0829	            STA ARGUMENT2
.3a58bd	a5 57		lda $0857	            LDA MARG1+2
.3a58bf	85 2b		sta $082b	            STA ARGUMENT2+2
.3a58c1	20 88 55	jsr $3a5588	            JSR OP_FP_ADD
.3a58c4	c2 20		rep #$20	            REP #$20
.3a58c6	a5 23		lda $0823	            LDA ARGUMENT1
.3a58c8	85 29		sta $0829	            STA ARGUMENT2
.3a58ca	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a58cc	85 2b		sta $082b	            STA ARGUMENT2+2
.3a58ce	20 f9 57	jsr $3a57f9	            JSR FP_POW10
.3a58d1	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a58d4	c2 20		rep #$20	            REP #$20
.3a58d6	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.3a58d8	f0 07		beq $3a58e1	                BEQ set_float_type              ; If not, just set the type
.3a58da	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.3a58dc	09 00 80	ora #$8000	                ORA #$8000
.3a58df	85 25		sta $0825	                STA ARGUMENT1+2
.3a58e1					set_float_type
.3a58e1	e2 20		sep #$20	            SEP #$20
.3a58e3	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.3a58e5	85 27		sta $0827	                STA ARGTYPE1
.3a58e7	28		plp		                PLP
.3a58e8	60		rts		            RTS
.3a58e9					PARSENUM
.3a58e9	5a		phy		                PHY
.3a58ea	08		php		                PHP
.3a58eb	c2 30		rep #$30	            REP #$30
.3a58ed	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.3a58ef	64 25		stz $0825	                STZ ARGUMENT1+2
.3a58f1	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.3a58f3	64 57		stz $0857	                STZ MARG1+2
.3a58f5	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.3a58f7	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.3a58f9	64 5b		stz $085b	                STZ MARG2+2
.3a58fb	a9 01 00	lda #$0001	                LDA #1
.3a58fe	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.3a5900	64 5f		stz $085f	                STZ MARG3+2
.3a5902	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.3a5904	64 63		stz $0863	                STZ MARG4+2
.3a5906	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.3a5908					s0
.3a5908	e2 20		sep #$20	            SEP #$20
.3a590a	a0 00 00	ldy #$0000	                LDY #0
.3a590d	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.3a590f	c9 2b		cmp #$2b	                CMP #'+'
.3a5911	f0 33		beq $3a5946	                BEQ s1_drop         ; '+' --> S1, drop
.3a5913	c9 2d		cmp #$2d	                CMP #'-'
.3a5915	f0 2b		beq $3a5942	                BEQ s1_negative     ; Flag that the number is negative
.3a5917	c9 26		cmp #$26	                CMP #'&'
.3a5919	f0 3a		beq $3a5955	                BEQ s2_drop         ; '&' --> S2, drop
.3a591b	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a591e	90 03		bcc $3a5923	                BCC syntax_err
.3a5920	82 ac 00	brl $3a59cf	                BRL s7_shift        ; '0'-'9' --> S7, emit
.3a5923					syntax_err
.3a5923	08		php		            PHP
.3a5924	c2 20		rep #$20	            REP #$20
.3a5926	48		pha		            PHA
.3a5927	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a592a	5b		tcd		            TCD
.3a592b	68		pla		            PLA
.3a592c	28		plp		            PLP
.3a592d	e2 20		sep #$20	            SEP #$20
.3a592f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a5931	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5935	c2 20		rep #$20	            REP #$20
.3a5937	29 ff 00	and #$00ff	            AND #$00FF
.3a593a	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a593d	e2 20		sep #$20	            SEP #$20
.3a593f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5942	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.3a5944	85 65		sta $0865	                STA MARG5
.3a5946	c8		iny		s1_drop         INY                 ; Drop the character...
.3a5947	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.3a5949	c9 26		cmp #$26	                CMP #'&'
.3a594b	f0 08		beq $3a5955	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.3a594d	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a5950	90 d1		bcc $3a5923	                BCC syntax_err
.3a5952	82 7a 00	brl $3a59cf	                BRL s7_shift        ; '0'-'9' --> S7, shift
.3a5955	c8		iny		s2_drop         INY                 ; Drop the character
.3a5956	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a5958	c9 68		cmp #$68	                CMP #'h'
.3a595a	f0 0e		beq $3a596a	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.3a595c	c9 48		cmp #$48	                CMP #'H'
.3a595e	f0 0a		beq $3a596a	                BEQ s3_drop
.3a5960	c9 62		cmp #$62	                CMP #'b'
.3a5962	f0 4c		beq $3a59b0	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.3a5964	c9 42		cmp #$42	                CMP #'B'
.3a5966	f0 48		beq $3a59b0	                BEQ s5_drop
.3a5968	80 b9		bra $3a5923	                BRA syntax_err
.3a596a	c8		iny		s3_drop         INY                 ; Drop the character
.3a596b	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.3a596d	20 60 04	jsr $3a0460	            JSR ISHEX
.3a5970	b0 02		bcs $3a5974	                BCS s4_shift
.3a5972	80 af		bra $3a5923	                BRA syntax_err
.3a5974					s4_shift
.3a5974	20 8b 57	jsr $3a578b	            JSR SHIFTHEX
.3a5977	c8		iny		                INY
.3a5978	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a597a	20 60 04	jsr $3a0460	            JSR ISHEX
.3a597d	b0 f5		bcs $3a5974	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.3a597f					ret_integer
.3a597f	e2 20		sep #$20	            SEP #$20
.3a5981	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.3a5983	f0 11		beq $3a5996	                BEQ set_int_type    ; If not, just set the type and return
.3a5985	c2 20		rep #$20	            REP #$20
.3a5987	38		sec		                SEC                 ; If so, negate it
.3a5988	a9 00 00	lda #$0000	                LDA #0
.3a598b	e5 23		sbc $0823	                SBC ARGUMENT1
.3a598d	85 23		sta $0823	                STA ARGUMENT1
.3a598f	a9 00 00	lda #$0000	                LDA #0
.3a5992	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5994	85 25		sta $0825	                STA ARGUMENT1+2
.3a5996					set_int_type
.3a5996	e2 20		sep #$20	            SEP #$20
.3a5998	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.3a599a	85 27		sta $0827	                STA ARGTYPE1
.3a599c					stop
.3a599c	c2 20		rep #$20	            REP #$20
.3a599e	18		clc		                CLC
.3a599f	98		tya		                TYA
.3a59a0	65 00		adc $0800	                ADC BIP
.3a59a2	85 00		sta $0800	                STA BIP
.3a59a4	a5 02		lda $0802	                LDA BIP+2
.3a59a6	69 00 00	adc #$0000	                ADC #0
.3a59a9	85 02		sta $0802	                STA BIP+2
.3a59ab	e2 20		sep #$20	            SEP #$20
.3a59ad	28		plp		                PLP
.3a59ae	7a		ply		                PLY
.3a59af	60		rts		            RTS
.3a59b0	c8		iny		s5_drop         INY                     ; Drop the character
.3a59b1	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.3a59b3	c9 30		cmp #$30	                CMP #'0'
.3a59b5	f0 07		beq $3a59be	                BEQ s6_shift            ; '0', '1' --> S6, shift
.3a59b7	c9 31		cmp #$31	                CMP #'1'
.3a59b9	f0 03		beq $3a59be	                BEQ s6_shift
.3a59bb	82 65 ff	brl $3a5923	                BRL syntax_err
.3a59be					s6_shift
.3a59be	20 db 57	jsr $3a57db	            JSR SHIFTBIN
.3a59c1	c8		iny		                INY
.3a59c2	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a59c4	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.3a59c6	f0 f6		beq $3a59be	                BEQ s6_shift
.3a59c8	c9 31		cmp #$31	                CMP #'1'
.3a59ca	f0 f2		beq $3a59be	                BEQ s6_shift
.3a59cc	82 b0 ff	brl $3a597f	                BRL ret_integer         ; Return integer
.3a59cf					s7_shift
.3a59cf	20 6f 57	jsr $3a576f	            JSR SHIFTDEC
.3a59d2	c8		iny		                INY
.3a59d3	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a59d5	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.3a59d7	f0 08		beq $3a59e1	                BEQ s8_mantissa
.3a59d9	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a59dc	b0 f1		bcs $3a59cf	                BCS s7_shift
.3a59de	82 9e ff	brl $3a597f	                BRL ret_integer         ; Return integer
.3a59e1					s8_mantissa
.3a59e1	c2 20		rep #$20	            REP #$20
.3a59e3	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a59e6	c2 20		rep #$20	            REP #$20
.3a59e8	a5 23		lda $0823	            LDA ARGUMENT1
.3a59ea	85 55		sta $0855	            STA MARG1
.3a59ec	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a59ee	85 57		sta $0857	            STA MARG1+2
.3a59f0	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.3a59f2	64 25		stz $0825	                STZ ARGUMENT1+2
.3a59f4	e2 20		sep #$20	            SEP #$20
.3a59f6	80 36		bra $3a5a2e	                BRA s8_drop
.3a59f8					s8_shift
.3a59f8	20 6f 57	jsr $3a576f	            JSR SHIFTDEC
.3a59fb	c2 20		rep #$20	            REP #$20
.3a59fd	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.3a59ff	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5a03	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5a06	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5a0a	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.3a5a0e	85 5f		sta $085f	                STA MARG3+2
.3a5a10	a5 5d		lda $085d	                LDA MARG3
.3a5a12	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5a16	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5a19	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5a1d	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.3a5a21	85 5d		sta $085d	                STA MARG3
.3a5a23	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a5a27	18		clc		                CLC
.3a5a28	65 5f		adc $085f	                ADC MARG3+2
.3a5a2a	85 5f		sta $085f	                STA MARG3+2
.3a5a2c	e2 20		sep #$20	            SEP #$20
.3a5a2e					s8_drop
.3a5a2e	c8		iny		                INY
.3a5a2f	b7 00		lda [$0800],y	                LDA [BIP],Y
.3a5a31	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.3a5a33	f0 24		beq $3a5a59	                BEQ s9_drop
.3a5a35	c9 45		cmp #$45	                CMP #'E'
.3a5a37	f0 20		beq $3a5a59	                BEQ s9_drop
.3a5a39	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a5a3c	b0 ba		bcs $3a59f8	                BCS s8_shift
.3a5a3e	c2 20		rep #$20	            REP #$20
.3a5a40	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a5a43	c2 20		rep #$20	            REP #$20
.3a5a45	a5 23		lda $0823	            LDA ARGUMENT1
.3a5a47	85 59		sta $0859	            STA MARG2
.3a5a49	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5a4b	85 5b		sta $085b	            STA MARG2+2
.3a5a4d	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5a4f	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5a51	20 92 58	jsr $3a5892	            JSR PACKFLOAT
.3a5a54	e2 20		sep #$20	            SEP #$20
.3a5a56	82 43 ff	brl $3a599c	                BRL stop
.3a5a59					s9_drop
.3a5a59	c2 20		rep #$20	            REP #$20
.3a5a5b	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a5a5e	c2 20		rep #$20	            REP #$20
.3a5a60	a5 23		lda $0823	            LDA ARGUMENT1
.3a5a62	85 59		sta $0859	            STA MARG2
.3a5a64	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5a66	85 5b		sta $085b	            STA MARG2+2
.3a5a68	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5a6a	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5a6c	e2 20		sep #$20	            SEP #$20
.3a5a6e	c8		iny		                INY
.3a5a6f	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5a71	c9 2b		cmp #$2b	                CMP #'+'
.3a5a73	f0 10		beq $3a5a85	                BEQ s10_drop            ; '+' --> S10, drop
.3a5a75	c9 2d		cmp #$2d	                CMP #'-'
.3a5a77	f0 08		beq $3a5a81	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.3a5a79	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a5a7c	b0 12		bcs $3a5a90	                BCS S11_shift           ; '0'-'9' --> S11, shift
.3a5a7e	82 a2 fe	brl $3a5923	                BRL syntax_err
.3a5a81					s10_setneg
.3a5a81	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.3a5a83	85 69		sta $0869	                STA MARG6
.3a5a85					s10_drop
.3a5a85	c8		iny		                INY
.3a5a86	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5a88	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a5a8b	b0 03		bcs $3a5a90	                BCS s11_shift
.3a5a8d	82 93 fe	brl $3a5923	                BRL syntax_err
.3a5a90					s11_shift
.3a5a90	20 6f 57	jsr $3a576f	            JSR SHIFTDEC
.3a5a93	c8		iny		                INY
.3a5a94	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5a96	20 4f 04	jsr $3a044f	            JSR ISNUMERAL
.3a5a99	b0 f5		bcs $3a5a90	                BCS s11_shift
.3a5a9b	c2 20		rep #$20	            REP #$20
.3a5a9d	a5 23		lda $0823	            LDA ARGUMENT1
.3a5a9f	85 61		sta $0861	            STA MARG4
.3a5aa1	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5aa3	85 63		sta $0863	            STA MARG4+2
.3a5aa5	20 92 58	jsr $3a5892	            JSR PACKFLOAT
.3a5aa8	82 f1 fe	brl $3a599c	                BRL stop
.3a5aab					ITOF
.3a5aab	08		php		                PHP
.3a5aac	20 39 55	jsr $3a5539	            JSR FIXINT_TO_FP
.3a5aaf	28		plp		done            PLP
.3a5ab0	60		rts		            RTS
.3a5ab1					FTOI
.3a5ab1	08		php		                PHP
.3a5ab2					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.3a5ab2	c2 20		rep #$20	            REP #$20
.3a5ab4	a9 a8 5d	lda #$5da8	                LDA #<>FP_1_0
.3a5ab7	85 29		sta $0829	                STA ARGUMENT2
.3a5ab9	a9 3a 00	lda #$003a	                LDA #(FP_1_0 >> 16)
.3a5abc	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5abe	e2 20		sep #$20	            SEP #$20
.3a5ac0	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a5ac2	85 2d		sta $082d	                STA ARGTYPE2
.3a5ac4	c2 20		rep #$20	            REP #$20
.3a5ac6	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5ac9	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5acc	d0 0c		bne $3a5ada	                BNE alloc_locals        ; No: get ready to do the full conversion
.3a5ace	a9 00 00	lda #$0000	                LDA #0
.3a5ad1	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.3a5ad4	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5ad7	82 a1 00	brl $3a5b7b	                BRL done
.3a5ada	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.3a5add	f4 00 00	pea #$0000	                PEA #0
.3a5ae0	f4 00 00	pea #$0000	                PEA #0
.3a5ae3	e2 20		sep #$20	            SEP #$20
.3a5ae5	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.3a5ae8	29 80		and #$80	                AND #$80
.3a5aea	83 01		sta $01,s	                STA l_sign
.3a5aec	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.3a5aef	2a		rol a		                ROL A
.3a5af0	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.3a5af3	2a		rol a		                ROL A
.3a5af4	83 02		sta $02,s	                STA l_exponent
.3a5af6	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.3a5af8	83 06		sta $06,s	                STA l_mantissa+3
.3a5afa	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.3a5afd	09 80		ora #$80	                ORA #$80
.3a5aff	83 05		sta $05,s	                STA l_mantissa+2
.3a5b01	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.3a5b04	83 04		sta $04,s	                STA l_mantissa+1
.3a5b06	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.3a5b09	83 03		sta $03,s	                STA l_mantissa
.3a5b0b	a3 02		lda $02,s	                LDA l_exponent
.3a5b0d	c9 96		cmp #$96	loop            CMP #150
.3a5b0f	f0 3a		beq $3a5b4b	                BEQ adj_sign
.3a5b11	90 1f		bcc $3a5b32	                BLT shift_right
.3a5b13	08		php		            PHP
.3a5b14	c2 20		rep #$20	            REP #$20
.3a5b16	48		pha		            PHA
.3a5b17	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5b1a	5b		tcd		            TCD
.3a5b1b	68		pla		            PLA
.3a5b1c	28		plp		            PLP
.3a5b1d	e2 20		sep #$20	            SEP #$20
.3a5b1f	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a5b21	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5b25	c2 20		rep #$20	            REP #$20
.3a5b27	29 ff 00	and #$00ff	            AND #$00FF
.3a5b2a	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a5b2d	e2 20		sep #$20	            SEP #$20
.3a5b2f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5b32					shift_right
.3a5b32	c2 20		rep #$20	            REP #$20
.3a5b34	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5b36	4a		lsr a		                LSR A
.3a5b37	83 05		sta $05,s	                STA l_mantissa+2
.3a5b39	a3 03		lda $03,s	                LDA l_mantissa
.3a5b3b	6a		ror a		                ROR A
.3a5b3c	83 03		sta $03,s	                STA l_mantissa
.3a5b3e	e2 20		sep #$20	            SEP #$20
.3a5b40	a3 02		lda $02,s	                LDA l_exponent
.3a5b42	1a		inc a		                INC A
.3a5b43	83 02		sta $02,s	                STA l_exponent
.3a5b45	c9 96		cmp #$96	                CMP #150
.3a5b47	f0 02		beq $3a5b4b	                BEQ adj_sign
.3a5b49	80 e7		bra $3a5b32	                BRA shift_right
.3a5b4b	a3 01		lda $01,s	adj_sign        LDA l_sign
.3a5b4d	f0 1b		beq $3a5b6a	                BEQ ret_positive
.3a5b4f	c2 20		rep #$20	            REP #$20
.3a5b51	a3 03		lda $03,s	                LDA l_mantissa
.3a5b53	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5b56	18		clc		                CLC
.3a5b57	69 01 00	adc #$0001	                ADC #1
.3a5b5a	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5b5d	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5b5f	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5b62	69 00 00	adc #$0000	                ADC #0
.3a5b65	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5b68	80 0c		bra $3a5b76	                BRA clean
.3a5b6a					ret_positive
.3a5b6a	c2 20		rep #$20	            REP #$20
.3a5b6c	a3 03		lda $03,s	                LDA l_mantissa
.3a5b6e	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5b71	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5b73	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5b76					clean
.3a5b76	c2 20		rep #$20	            REP #$20
.3a5b78	68		pla		                PLA                     ; Clean up the locals
.3a5b79	68		pla		                PLA
.3a5b7a	68		pla		                PLA
.3a5b7b					done
.3a5b7b	e2 20		sep #$20	            SEP #$20
.3a5b7d	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.3a5b7f	8d 27 08	sta $0827	                STA @w ARGTYPE1
.3a5b82	28		plp		                PLP
.3a5b83	60		rts		            RTS
.3a5b84					FP_COMPARE
.3a5b84	da		phx		                PHX
.3a5b85	08		php		                PHP
.3a5b86	c2 20		rep #$20	            REP #$20
.3a5b88	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.3a5b8a	48		pha		                PHA
.3a5b8b	a5 23		lda $0823	                LDA ARGUMENT1
.3a5b8d	48		pha		                PHA
.3a5b8e	20 7d 55	jsr $3a557d	            JSR OP_FP_SUB
.3a5b91	20 5b 57	jsr $3a575b	            JSR FARG1EQ0
.3a5b94	b0 11		bcs $3a5ba7	                BCS are_equal
.3a5b96	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.3a5b98	89 00 80	bit #$8000	                BIT #$8000
.3a5b9b	d0 05		bne $3a5ba2	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.3a5b9d	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.3a5ba0	80 08		bra $3a5baa	                BRA ret_result
.3a5ba2	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.3a5ba5	80 03		bra $3a5baa	                BRA ret_result
.3a5ba7	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.3a5baa	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.3a5bab	86 23		stx $0823	                STX ARGUMENT1
.3a5bad	fa		plx		                PLX
.3a5bae	86 25		stx $0825	                STX ARGUMENT1+2
.3a5bb0	28		plp		                PLP
.3a5bb1	fa		plx		                PLX
.3a5bb2	60		rts		            RTS
.3a5bb3					OP_FP_LT
.3a5bb3	08		php		                PHP
.3a5bb4	c2 30		rep #$30	            REP #$30
.3a5bb6	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5bb9	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5bbc	d0 05		bne $3a5bc3	                BNE ret_false
.3a5bbe	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5bc1	80 03		bra $3a5bc6	                BRA done
.3a5bc3					ret_false
.3a5bc3	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5bc6	28		plp		done            PLP
.3a5bc7	60		rts		            RTS
.3a5bc8					OP_FP_GT
.3a5bc8	08		php		                PHP
.3a5bc9	c2 30		rep #$30	            REP #$30
.3a5bcb	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5bce	c9 01 00	cmp #$0001	                CMP #1
.3a5bd1	d0 05		bne $3a5bd8	                BNE ret_false
.3a5bd3	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5bd6	80 03		bra $3a5bdb	                BRA done
.3a5bd8					ret_false
.3a5bd8	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5bdb	28		plp		done            PLP
.3a5bdc	60		rts		            RTS
.3a5bdd					OP_FP_EQ
.3a5bdd	08		php		                PHP
.3a5bde	c2 30		rep #$30	            REP #$30
.3a5be0	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5be3	c9 00 00	cmp #$0000	                CMP #0
.3a5be6	d0 05		bne $3a5bed	                BNE ret_false
.3a5be8	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5beb	80 03		bra $3a5bf0	                BRA done
.3a5bed					ret_false
.3a5bed	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5bf0	28		plp		done            PLP
.3a5bf1	60		rts		            RTS
.3a5bf2					OP_FP_LTE
.3a5bf2	08		php		                PHP
.3a5bf3	c2 30		rep #$30	            REP #$30
.3a5bf5	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5bf8	c9 01 00	cmp #$0001	                CMP #1
.3a5bfb	f0 05		beq $3a5c02	                BEQ ret_false
.3a5bfd	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5c00	80 03		bra $3a5c05	                BRA done
.3a5c02					ret_false
.3a5c02	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5c05	28		plp		done            PLP
.3a5c06	60		rts		            RTS
.3a5c07					OP_FP_GTE
.3a5c07	08		php		                PHP
.3a5c08	c2 30		rep #$30	            REP #$30
.3a5c0a	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5c0d	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5c10	f0 05		beq $3a5c17	                BEQ ret_false
.3a5c12	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5c15	80 03		bra $3a5c1a	                BRA done
.3a5c17					ret_false
.3a5c17	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5c1a	28		plp		done            PLP
.3a5c1b	60		rts		            RTS
.3a5c1c					OP_FP_NE
.3a5c1c	08		php		                PHP
.3a5c1d	c2 30		rep #$30	            REP #$30
.3a5c1f	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5c22	c9 00 00	cmp #$0000	                CMP #0
.3a5c25	f0 05		beq $3a5c2c	                BEQ ret_false
.3a5c27	20 81 05	jsr $3a0581	            JSR SET_TRUE
.3a5c2a	80 03		bra $3a5c2f	                BRA done
.3a5c2c					ret_false
.3a5c2c	20 93 05	jsr $3a0593	            JSR SET_FALSE
.3a5c2f	28		plp		done            PLP
.3a5c30	60		rts		            RTS
.3a5c31					STREMIT
.3a5c31	08		php		                PHP
.3a5c32	e2 20		sep #$20	            SEP #$20
.3a5c34	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.3a5c36	c8		iny		                INY                         ; Advance the character pointer in Y
.3a5c37	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.3a5c39	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5c3b	28		plp		                PLP
.3a5c3c	60		rts		            RTS
.3a5c3d					STREMITB
.3a5c3d	da		phx		                PHX
.3a5c3e	08		php		                PHP
.3a5c3f	e2 20		sep #$20	            SEP #$20
.3a5c41	c9 80		cmp #$80	                CMP #$80
.3a5c43	90 0a		bcc $3a5c4f	                BLT emit_digits
.3a5c45	48		pha		                PHA
.3a5c46	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.3a5c48	20 31 5c	jsr $3a5c31	            JSR STREMIT
.3a5c4b	68		pla		                PLA
.3a5c4c	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.3a5c4e	1a		inc a		                INC A
.3a5c4f					emit_digits
.3a5c4f	c2 30		rep #$30	            REP #$30
.3a5c51	29 ff 00	and #$00ff	                AND #$00FF
.3a5c54	c9 64 00	cmp #$0064	                CMP #100
.3a5c57	90 0e		bcc $3a5c67	                BLT chk_tens
.3a5c59	a2 64 00	ldx #$0064	                LDX #100
.3a5c5c	20 22 55	jsr $3a5522	            JSR UINT_DIV_A_X
.3a5c5f	18		clc		                CLC
.3a5c60	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5c63	20 31 5c	jsr $3a5c31	            JSR STREMIT
.3a5c66	8a		txa		                TXA                         ; Put the remainder in A
.3a5c67					chk_tens
.3a5c67	a2 0a 00	ldx #$000a	                LDX #10
.3a5c6a	20 22 55	jsr $3a5522	            JSR UINT_DIV_A_X
.3a5c6d	18		clc		                CLC
.3a5c6e	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5c71	20 31 5c	jsr $3a5c31	            JSR STREMIT
.3a5c74	8a		txa		                TXA                         ; Put the remainder in A
.3a5c75					ones_digit
.3a5c75	18		clc		                CLC
.3a5c76	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.3a5c79	20 31 5c	jsr $3a5c31	            JSR STREMIT
.3a5c7c	28		plp		                PLP
.3a5c7d	fa		plx		                PLX
.3a5c7e	60		rts		            RTS
.3a5c7f					STRFINDEND
.3a5c7f	08		php		                PHP
.3a5c80	e2 20		sep #$20	            SEP #$20
.3a5c82	c2 10		rep #$10	            REP #$10
.3a5c84	a0 00 00	ldy #$0000	                LDY #0
.3a5c87	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.3a5c89	f0 03		beq $3a5c8e	                BEQ done
.3a5c8b	c8		iny		                INY
.3a5c8c	80 f9		bra $3a5c87	                BRA find_end
.3a5c8e	28		plp		done            PLP
.3a5c8f	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.3a5c90					FTOS
.3a5c90	08		php		                PHP
.3a5c91	e2 20		sep #$20	            SEP #$20
.3a5c93	c2 10		rep #$10	            REP #$10
.3a5c95	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.3a5c98	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.3a5c9b	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.3a5c9e	20 5b 57	jsr $3a575b	            JSR FARG1EQ0
.3a5ca1	90 19		bcc $3a5cbc	                BCC chk_negative
.3a5ca3	20 50 14	jsr $3a1450	            JSR TEMPSTRING
.3a5ca6	e2 20		sep #$20	            SEP #$20
.3a5ca8	a0 00 00	ldy #$0000	                LDY #0
.3a5cab	a9 20		lda #$20	                LDA #' '
.3a5cad	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5caf	c8		iny		                INY
.3a5cb0	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.3a5cb2	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5cb4	c8		iny		                INY
.3a5cb5	a9 00		lda #$00	                LDA #0
.3a5cb7	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5cb9	82 ce 00	brl $3a5d8a	                BRL ret_result
.3a5cbc					chk_negative
.3a5cbc	e2 20		sep #$20	            SEP #$20
.3a5cbe	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.3a5cc0	10 08		bpl $3a5cca	                BPL not_negative
.3a5cc2	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.3a5cc4	85 26		sta $0826	                STA ARGUMENT1+3
.3a5cc6	a9 01		lda #$01	                LDA #1
.3a5cc8	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.3a5cca					not_negative
.3a5cca	c2 20		rep #$20	            REP #$20
.3a5ccc	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.3a5ccf	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.3a5cd1	c2 20		rep #$20	            REP #$20
.3a5cd3	af a4 5d 3a	lda $3a5da4	            LDA ten_d_1
.3a5cd7	85 29		sta $0829	            STA ARGUMENT2
.3a5cd9	af a6 5d 3a	lda $3a5da6	            LDA ten_d_1+2
.3a5cdd	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5cdf	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5ce2	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.3a5ce5	d0 12		bne $3a5cf9	                BNE shift_up
.3a5ce7					shift_down
.3a5ce7	20 1f 57	jsr $3a571f	            JSR FP_DIV10
.3a5cea	a3 03		lda $03,s	                LDA L_K
.3a5cec	1a		inc a		                INC A
.3a5ced	83 03		sta $03,s	                STA L_K                     ; Increment K
.3a5cef	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5cf2	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.3a5cf5	f0 12		beq $3a5d09	                BEQ do_digits               ; Yes: we're ready to process digits
.3a5cf7	80 ee		bra $3a5ce7	                BRA shift_down              ; No: keep dividing
.3a5cf9					shift_up
.3a5cf9	20 d6 56	jsr $3a56d6	            JSR FP_MUL10
.3a5cfc	a3 03		lda $03,s	                LDA L_K
.3a5cfe	3a		dec a		                DEC A
.3a5cff	83 03		sta $03,s	                STA L_K                     ; Decrement K
.3a5d01	20 84 5b	jsr $3a5b84	            JSR FP_COMPARE
.3a5d04	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.3a5d07	f0 f0		beq $3a5cf9	                BEQ shift_up                ; No: keep multiplying
.3a5d09					do_digits
.3a5d09	e2 30		sep #$30	            SEP #$30
.3a5d0b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5d0d	0a		asl a		                ASL A
.3a5d0e	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5d10	2a		rol a		                ROL A
.3a5d11	83 05		sta $05,s	                STA L_X1
.3a5d13	38		sec		                SEC
.3a5d14	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.3a5d16	e3 05		sbc $05,s	                SBC L_X1
.3a5d18	aa		tax		                TAX
.3a5d19	f0 0f		beq $3a5d2a	                BEQ emit_digits             ; If X = 0, just emit the digits
.3a5d1b	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.3a5d1d	09 80		ora #$80	                ORA #$80
.3a5d1f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d21	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.3a5d23	66 24		ror $0824	                ROR ARGUMENT1+1
.3a5d25	66 23		ror $0823	                ROR ARGUMENT1
.3a5d27	ca		dex		                DEX
.3a5d28	d0 f7		bne $3a5d21	                BNE shift_r                 ; Until X = 0
.3a5d2a					emit_digits
.3a5d2a	c2 10		rep #$10	            REP #$10
.3a5d2c	e2 20		sep #$20	            SEP #$20
.3a5d2e	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.3a5d30	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.3a5d32	85 27		sta $0827	                STA ARGTYPE1
.3a5d34	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.3a5d36	f0 11		beq $3a5d49	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.3a5d38	c2 20		rep #$20	            REP #$20
.3a5d3a	38		sec		                SEC                         ; Make the raw integer negative
.3a5d3b	a9 00 00	lda #$0000	                LDA #0
.3a5d3e	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5d40	85 23		sta $0823	                STA ARGUMENT1
.3a5d42	a9 00 00	lda #$0000	                LDA #0
.3a5d45	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5d47	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d49					get_raw_digits
.3a5d49	20 af 14	jsr $3a14af	            JSR ITOS
.3a5d4c	c2 20		rep #$20	            REP #$20
.3a5d4e	a5 16		lda $0816	            LDA STRPTR
.3a5d50	85 23		sta $0823	            STA ARGUMENT1
.3a5d52	a5 18		lda $0818	            LDA STRPTR+2
.3a5d54	85 25		sta $0825	            STA ARGUMENT1+2
.3a5d56	20 7f 5c	jsr $3a5c7f	            JSR STRFINDEND
.3a5d59	e2 20		sep #$20	            SEP #$20
.3a5d5b	c8		iny		                INY                         ; Move the NULL up one byte
.3a5d5c	a9 00		lda #$00	                LDA #0
.3a5d5e	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5d60	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.3a5d61	88		dey		                DEY
.3a5d62	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.3a5d64	c8		iny		                INY                         ; Move to the next space
.3a5d65	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.3a5d67	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.3a5d6a	d0 f4		bne $3a5d60	                BNE insert_loop             ; If not, keep moving the characters
.3a5d6c	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.3a5d6e	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5d70	e2 20		sep #$20	            SEP #$20
.3a5d72	18		clc		                CLC                         ; Compute the exponent
.3a5d73	a3 03		lda $03,s	                LDA L_K
.3a5d75	69 05		adc #$05	                ADC #(FP_D - 1)
.3a5d77	83 06		sta $06,s	                STA L_EXP
.3a5d79	f0 19		beq $3a5d94	                BEQ done                    ; If it's 0, just return the number
.3a5d7b	20 7f 5c	jsr $3a5c7f	            JSR STRFINDEND
.3a5d7e	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.3a5d80	20 31 5c	jsr $3a5c31	            JSR STREMIT
.3a5d83	a3 06		lda $06,s	                LDA L_EXP
.3a5d85	20 3d 5c	jsr $3a5c3d	            JSR STREMITB
.3a5d88	80 0a		bra $3a5d94	                BRA done                    ; TODO: reformat integer... add E and exponent...
.3a5d8a					ret_result
.3a5d8a	c2 20		rep #$20	            REP #$20
.3a5d8c	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.3a5d8e	85 23		sta $0823	                STA ARGUMENT1
.3a5d90	a5 18		lda $0818	                LDA STRPTR+2
.3a5d92	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d94					done
.3a5d94	e2 20		sep #$20	            SEP #$20
.3a5d96	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5d98	85 27		sta $0827	                STA ARGTYPE1
.3a5d9a	c2 20		rep #$20	            REP #$20
.3a5d9c	3b		tsc		                TSC                         ; Remove the locals from the stack
.3a5d9d	18		clc		                CLC
.3a5d9e	69 06 00	adc #$0006	                ADC #6
.3a5da1	1b		tcs		                TCS
.3a5da2	28		plp		                PLP
.3a5da3	60		rts		            RTS
>3a5da4	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>3a5da8	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>3a5dac	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>3a5db0	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.3a5db4					Q_POLY_HR
.3a5db4	e2 20		sep #$20	            SEP #$20
.3a5db6	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5db8	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5dbc	c2 20		rep #$20	            REP #$20
.3a5dbe	bd 00 00	lda $0000,x	                LDA 0,X
.3a5dc1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5dc5	bd 02 00	lda $0002,x	                LDA 2,X
.3a5dc8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5dcc	88		dey		                DEY             ; (Y-1) more coefficients.
.3a5dcd	e8		inx		loop            INX             ; point to the next coefficient
.3a5dce	e8		inx		                INX
.3a5dcf	e8		inx		                INX
.3a5dd0	e8		inx		                INX
.3a5dd1	e2 20		sep #$20	            SEP #$20
.3a5dd3	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5dd5	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5dd9	c2 20		rep #$20	            REP #$20
.3a5ddb	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.3a5ddf	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5de3	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5de7	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5deb	ea		nop		                NOP
.3a5dec	ea		nop		                NOP
.3a5ded	ea		nop		                NOP
.3a5dee	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5df2	48		pha		                PHA
.3a5df3	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5df7	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.3a5dfb	68		pla		                PLA
.3a5dfc	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5e00	e2 20		sep #$20	            SEP #$20
.3a5e02	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5e04	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5e08	c2 20		rep #$20	            REP #$20
.3a5e0a	bd 00 00	lda $0000,x	                LDA 0,X
.3a5e0d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5e11	bd 02 00	lda $0002,x	                LDA 2,X
.3a5e14	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5e18	ea		nop		                NOP
.3a5e19	ea		nop		                NOP
.3a5e1a	ea		nop		                NOP
.3a5e1b	88		dey		                DEY
.3a5e1c	f0 14		beq $3a5e32	                BEQ done
.3a5e1e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5e22	48		pha		                PHA
.3a5e23	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5e27	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5e2b	68		pla		                PLA
.3a5e2c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5e30	80 9b		bra $3a5dcd	                BRA loop
.3a5e32	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.3a5e36	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a5e3a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5e3e	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a5e42	60		rts		                RTS
.3a5e43					Q_SQ
.3a5e43	e2 20		sep #$20	            SEP #$20
.3a5e45	a9 00		lda #$00	                LDA #0
.3a5e47	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5e4b	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5e4d	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5e51	c2 20		rep #$20	            REP #$20
.3a5e53	a5 23		lda $0823	                LDA ARGUMENT1
.3a5e55	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5e59	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5e5d	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5e61	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5e65	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5e69	ea		nop		                NOP
.3a5e6a	ea		nop		                NOP
.3a5e6b	ea		nop		                NOP
.3a5e6c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5e70	85 23		sta $0823	                STA ARGUMENT1
.3a5e72	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5e76	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e78	60		rts		                RTS
.3a5e79					Q_INV
.3a5e79	e2 20		sep #$20	            SEP #$20
.3a5e7b	a9 00		lda #$00	                LDA #0
.3a5e7d	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5e81	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5e83	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5e87	c2 20		rep #$20	            REP #$20
.3a5e89	a5 23		lda $0823	                LDA ARGUMENT1
.3a5e8b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5e8f	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5e93	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5e97	af cd 64 3a	lda $3a64cd	                LDA @l fp_one
.3a5e9b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5e9f	af cf 64 3a	lda $3a64cf	                LDA @l fp_one+2
.3a5ea3	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ea7	ea		nop		                NOP
.3a5ea8	ea		nop		                NOP
.3a5ea9	ea		nop		                NOP
.3a5eaa	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5eae	85 23		sta $0823	                STA ARGUMENT1
.3a5eb0	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5eb4	85 25		sta $0825	                STA ARGUMENT1+2
.3a5eb6	60		rts		                RTS
.3a5eb7					Q_FP_SCALE
.3a5eb7	a2 00 00	ldx #$0000	                LDX #0
.3a5eba	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a5ebc	c5 29		cmp $0829	                CMP ARGUMENT2
.3a5ebe	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5ec0	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.3a5ec2	90 1e		bcc $3a5ee2	                BCC done
.3a5ec4	a5 23		lda $0823	                LDA ARGUMENT1
.3a5ec6	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5eca	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5ecc	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ed0	ea		nop		                NOP
.3a5ed1	ea		nop		                NOP
.3a5ed2	ea		nop		                NOP
.3a5ed3	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5ed7	85 23		sta $0823	                STA ARGUMENT1
.3a5ed9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5edd	85 25		sta $0825	                STA ARGUMENT1+2
.3a5edf	e8		inx		                INX
.3a5ee0	80 d8		bra $3a5eba	                BRA loop
.3a5ee2					done
.3a5ee2	60		rts		            RTS
.3a5ee3					Q_FP_SCALE_TAU
.3a5ee3	e2 20		sep #$20	            SEP #$20
.3a5ee5	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5ee7	10 09		bpl $3a5ef2	                BPL notneg
.3a5ee9	29 7f		and #$7f	                AND #$7F
.3a5eeb	85 26		sta $0826	                STA ARGUMENT1+3
.3a5eed	a9 01		lda #$01	                LDA #1
.3a5eef	48		pha		                PHA
.3a5ef0	80 03		bra $3a5ef5	                BRA compute
.3a5ef2	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.3a5ef4	48		pha		                PHA
.3a5ef5	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5ef7	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5efb	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5efd	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f01	c2 30		rep #$30	            REP #$30
.3a5f03	af 35 65 3a	lda $3a6535	                LDA @l twopi
.3a5f07	85 29		sta $0829	                STA ARGUMENT2
.3a5f09	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f0d	af 37 65 3a	lda $3a6537	                LDA @l twopi+2
.3a5f11	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5f13	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f17	20 b7 5e	jsr $3a5eb7	            JSR Q_FP_SCALE
.3a5f1a	e2 20		sep #$20	            SEP #$20
.3a5f1c	68		pla		                PLA
.3a5f1d	c2 20		rep #$20	            REP #$20
.3a5f1f	f0 1e		beq $3a5f3f	                BEQ done
.3a5f21	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f23	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f27	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f29	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f2d	ea		nop		                NOP
.3a5f2e	ea		nop		                NOP
.3a5f2f	ea		nop		                NOP
.3a5f30	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f34	85 23		sta $0823	                STA ARGUMENT1
.3a5f36	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f3a	29 ff 7f	and #$7fff	                AND #$7fff
.3a5f3d	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f3f					done
.3a5f3f	60		rts		            RTS
.3a5f40					Q_FP_NORM_ANGLE
.3a5f40	5a		phy		                PHY
.3a5f41	a2 00 00	ldx #$0000	                LDX #0
.3a5f44	a0 00 00	ldy #$0000	                LDY #0
.3a5f47	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a5f49	df 39 65 3a	cmp $3a6539,x	                CMP @l onepi,x
.3a5f4d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f4f	ff 3b 65 3a	sbc $3a653b,x	                SBC @l onepi+2,x
.3a5f53	90 2c		bcc $3a5f81	                BCC less
.3a5f55	bf 35 65 3a	lda $3a6535,x	                LDA @l twopi,x
.3a5f59	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f5d	bf 37 65 3a	lda $3a6537,x	                LDA @l twopi+2,x
.3a5f61	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f65	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f67	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f6b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f6d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f71	ea		nop		                NOP
.3a5f72	ea		nop		                NOP
.3a5f73	ea		nop		                NOP
.3a5f74	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f78	85 23		sta $0823	                STA ARGUMENT1
.3a5f7a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f7e	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f80	38		sec		                SEC             ; set carry to indicate a reflection
.3a5f81	98		tya		less            TYA             ; carry already cleared if we branched
.3a5f82	2a		rol a		                ROL             ; shift carry into flags...
.3a5f83	a8		tay		                TAY             ; and store back into y
.3a5f84	e8		inx		                INX             ; next set of values
.3a5f85	e8		inx		                INX
.3a5f86	e8		inx		                INX
.3a5f87	e8		inx		                INX
.3a5f88	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.3a5f8b	d0 ba		bne $3a5f47	                BNE loop
.3a5f8d	98		tya		                TYA             ; copy Y to X, as that's what we have
.3a5f8e	aa		tax		                TAX
.3a5f8f	7a		ply		                PLY
.3a5f90	60		rts		            RTS
.3a5f91					Q_FP_COS
.3a5f91	08		php		                PHP
.3a5f92	c2 30		rep #$30	            REP #$30
.3a5f94	48		pha		                PHA
.3a5f95	da		phx		                PHX
.3a5f96	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a5f99	8b		phb		                PHB
.3a5f9a	e2 20		sep #$20	            SEP #$20
.3a5f9c	a9 3a		lda #$3a	                LDA #`cos_coeff
.3a5f9e	48		pha		                PHA
.3a5f9f	ab		plb		                PLB
.3a5fa0	c2 20		rep #$20	            REP #$20
.3a5fa2	a2 75 64	ldx #$6475	                LDX #<>cos_coeff
.3a5fa5	5a		phy		                PHY
.3a5fa6	a0 05 00	ldy #$0005	                LDY #5
.3a5fa9	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a5fac	7a		ply		                PLY
.3a5fad	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a5fb0	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a5fb4	ab		plb		                PLB
.3a5fb5	fa		plx		                PLX
.3a5fb6	68		pla		                PLA
.3a5fb7	28		plp		                PLP
.3a5fb8	60		rts		            RTS
.3a5fb9					Q_FP_SIN
.3a5fb9	08		php		                PHP
.3a5fba	c2 30		rep #$30	            REP #$30
.3a5fbc	48		pha		                PHA
.3a5fbd	da		phx		                PHX
.3a5fbe	a5 23		lda $0823	                LDA ARGUMENT1
.3a5fc0	85 29		sta $0829	                STA ARGUMENT2
.3a5fc2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5fc4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5fc6	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a5fc9	8b		phb		                PHB
.3a5fca	e2 20		sep #$20	            SEP #$20
.3a5fcc	a9 3a		lda #$3a	                LDA #`sin_coeff
.3a5fce	48		pha		                PHA
.3a5fcf	ab		plb		                PLB
.3a5fd0	c2 20		rep #$20	            REP #$20
.3a5fd2	a2 89 64	ldx #$6489	                LDX #<>sin_coeff
.3a5fd5	5a		phy		                PHY
.3a5fd6	a0 05 00	ldy #$0005	                LDY #5
.3a5fd9	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a5fdc	7a		ply		                PLY
.3a5fdd	ab		plb		                PLB
.3a5fde	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a5fe1	fa		plx		                PLX
.3a5fe2	68		pla		                PLA
.3a5fe3	28		plp		                PLP
.3a5fe4	60		rts		            RTS
.3a5fe5					Q_FP_TAN
.3a5fe5	08		php		                PHP
.3a5fe6	c2 30		rep #$30	            REP #$30
.3a5fe8	48		pha		                PHA
.3a5fe9	da		phx		                PHX
.3a5fea	a5 23		lda $0823	                LDA ARGUMENT1
.3a5fec	85 29		sta $0829	                STA ARGUMENT2
.3a5fee	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5ff0	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5ff2	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a5ff5	8b		phb		                PHB
.3a5ff6	e2 20		sep #$20	            SEP #$20
.3a5ff8	a9 3a		lda #$3a	                LDA #`tan_coeff
.3a5ffa	48		pha		                PHA
.3a5ffb	ab		plb		                PLB
.3a5ffc	c2 20		rep #$20	            REP #$20
.3a5ffe	a2 9d 64	ldx #$649d	                LDX #<>tan_coeff
.3a6001	5a		phy		                PHY
.3a6002	a0 05 00	ldy #$0005	                LDY #5
.3a6005	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a6008	7a		ply		                PLY
.3a6009	ab		plb		                PLB
.3a600a	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a600d	fa		plx		                PLX
.3a600e	68		pla		                PLA
.3a600f	28		plp		                PLP
.3a6010	60		rts		            RTS
.3a6011					Q_FP_LN
.3a6011	08		php		                PHP
.3a6012	c2 30		rep #$30	            REP #$30
.3a6014	48		pha		                PHA
.3a6015	da		phx		                PHX
.3a6016	e2 20		sep #$20	            SEP #$20
.3a6018	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a601a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a601e	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a6020	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6024	c2 20		rep #$20	            REP #$20
.3a6026	a5 23		lda $0823	                LDA ARGUMENT1
.3a6028	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a602c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a602e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6032	af cd 64 3a	lda $3a64cd	                LDA @l fp_one
.3a6036	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a603a	af cf 64 3a	lda $3a64cf	                LDA @l fp_one+2
.3a603e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6042	ea		nop		                NOP
.3a6043	ea		nop		                NOP
.3a6044	ea		nop		                NOP
.3a6045	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6049	85 0c		sta $080c	                STA SCRATCH
.3a604b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a604f	85 0e		sta $080e	                STA SCRATCH+2
.3a6051	e2 20		sep #$20	            SEP #$20
.3a6053	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a6055	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6059	c2 20		rep #$20	            REP #$20
.3a605b	ea		nop		                NOP
.3a605c	ea		nop		                NOP
.3a605d	ea		nop		                NOP
.3a605e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6062	85 10		sta $0810	                STA SCRATCH2
.3a6064	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6068	85 12		sta $0812	                STA SCRATCH2+2
.3a606a	e2 20		sep #$20	            SEP #$20
.3a606c	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a606e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6072	c2 20		rep #$20	            REP #$20
.3a6074	a5 0c		lda $080c	                LDA SCRATCH
.3a6076	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a607a	a5 0e		lda $080e	                LDA SCRATCH+2
.3a607c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6080	a5 10		lda $0810	                LDA SCRATCH2
.3a6082	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6086	a5 12		lda $0812	                LDA SCRATCH2+2
.3a6088	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a608c	ea		nop		                NOP
.3a608d	ea		nop		                NOP
.3a608e	ea		nop		                NOP
.3a608f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6093	85 23		sta $0823	                STA ARGUMENT1
.3a6095	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6099	85 25		sta $0825	                STA ARGUMENT1+2
.3a609b	e2 20		sep #$20	            SEP #$20
.3a609d	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.3a609f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a60a3	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a60a5	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a60a9	c2 20		rep #$20	            REP #$20
.3a60ab	a5 23		lda $0823	                LDA ARGUMENT1
.3a60ad	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a60b1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a60b3	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a60b7	ea		nop		                NOP
.3a60b8	ea		nop		                NOP
.3a60b9	ea		nop		                NOP
.3a60ba	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a60be	85 29		sta $0829	                STA ARGUMENT2
.3a60c0	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a60c4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a60c6	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a60c9	8b		phb		                PHB
.3a60ca	e2 20		sep #$20	            SEP #$20
.3a60cc	a9 3a		lda #$3a	                LDA #`ln_coeff
.3a60ce	48		pha		                PHA
.3a60cf	ab		plb		                PLB
.3a60d0	c2 20		rep #$20	            REP #$20
.3a60d2	a2 b1 64	ldx #$64b1	                LDX #<>ln_coeff
.3a60d5	5a		phy		                PHY
.3a60d6	a0 08 00	ldy #$0008	                LDY #8
.3a60d9	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a60dc	7a		ply		                PLY
.3a60dd	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a60e0	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a60e4	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.3a60e8	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a60eb	ab		plb		                PLB
.3a60ec	fa		plx		                PLX
.3a60ed	68		pla		                PLA
.3a60ee	28		plp		                PLP
.3a60ef	60		rts		            RTS
.3a60f0					FP_SIN
.3a60f0	08		php		                PHP
.3a60f1	c2 30		rep #$30	            REP #$30
.3a60f3	48		pha		                PHA
.3a60f4	da		phx		                PHX
.3a60f5	20 e3 5e	jsr $3a5ee3	            JSR Q_FP_SCALE_TAU
.3a60f8	20 40 5f	jsr $3a5f40	            JSR Q_FP_NORM_ANGLE
.3a60fb	da		phx		                PHX
.3a60fc	8a		txa		                TXA
.3a60fd	29 01 00	and #$0001	                AND #1
.3a6100	d0 05		bne $3a6107	                BNE do_cos
.3a6102	20 b9 5f	jsr $3a5fb9	            JSR Q_FP_SIN
.3a6105	80 03		bra $3a610a	                BRA maybe_neg
.3a6107					do_cos
.3a6107	20 91 5f	jsr $3a5f91	            JSR Q_FP_COS
.3a610a	fa		plx		maybe_neg       PLX
.3a610b	8a		txa		                TXA
.3a610c	29 04 00	and #$0004	                AND #4
.3a610f	f0 0a		beq $3a611b	                BEQ done
.3a6111	e2 20		sep #$20	            SEP #$20
.3a6113	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a6115	09 80		ora #$80	                ORA #$80
.3a6117	85 26		sta $0826	                STA ARGUMENT1+3
.3a6119	c2 20		rep #$20	            REP #$20
.3a611b	fa		plx		done            PLX
.3a611c	68		pla		                PLA
.3a611d	28		plp		                PLP
.3a611e	60		rts		            RTS
.3a611f					FP_COS
.3a611f	08		php		                PHP
.3a6120	c2 30		rep #$30	            REP #$30
.3a6122	48		pha		                PHA
.3a6123	da		phx		                PHX
.3a6124	20 e3 5e	jsr $3a5ee3	            JSR Q_FP_SCALE_TAU
.3a6127	20 40 5f	jsr $3a5f40	            JSR Q_FP_NORM_ANGLE
.3a612a	da		phx		                PHX
.3a612b	8a		txa		                TXA
.3a612c	29 01 00	and #$0001	                AND #1
.3a612f	d0 05		bne $3a6136	                BNE do_sin
.3a6131	20 91 5f	jsr $3a5f91	            JSR Q_FP_COS
.3a6134	80 03		bra $3a6139	                BRA maybe_neg
.3a6136					do_sin
.3a6136	20 b9 5f	jsr $3a5fb9	            JSR Q_FP_SIN
.3a6139	fa		plx		maybe_neg       PLX
.3a613a	8a		txa		                TXA
.3a613b	29 02 00	and #$0002	                AND #2
.3a613e	f0 0a		beq $3a614a	                BEQ done
.3a6140	e2 20		sep #$20	            SEP #$20
.3a6142	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a6144	09 80		ora #$80	                ORA #$80
.3a6146	85 26		sta $0826	                STA ARGUMENT1+3
.3a6148	c2 20		rep #$20	            REP #$20
.3a614a	fa		plx		done            PLX
.3a614b	68		pla		                PLA
.3a614c	28		plp		                PLP
.3a614d	60		rts		            RTS
.3a614e					FP_TAN
.3a614e	08		php		                PHP
.3a614f	c2 30		rep #$30	            REP #$30
.3a6151	48		pha		                PHA
.3a6152	da		phx		                PHX
.3a6153	20 e3 5e	jsr $3a5ee3	            JSR Q_FP_SCALE_TAU
.3a6156	20 40 5f	jsr $3a5f40	            JSR Q_FP_NORM_ANGLE
.3a6159	20 e5 5f	jsr $3a5fe5	            JSR Q_FP_TAN
.3a615c	8a		txa		                TXA
.3a615d	29 01 00	and #$0001	                AND #1
.3a6160	f0 03		beq $3a6165	                BEQ no_inv
.3a6162	20 79 5e	jsr $3a5e79	            JSR Q_INV
.3a6165	8a		txa		no_inv          TXA
.3a6166	e2 20		sep #$20	            SEP #$20
.3a6168	4a		lsr a		                LSR
.3a6169	4a		lsr a		                LSR
.3a616a	69 00		adc #$00	                ADC #0
.3a616c	29 01		and #$01	                AND #1
.3a616e	f0 06		beq $3a6176	                BEQ no_neg
.3a6170	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a6172	09 80		ora #$80	                ORA #$80
.3a6174	85 26		sta $0826	                STA ARGUMENT1+3
.3a6176					no_neg
.3a6176	c2 20		rep #$20	            REP #$20
.3a6178	fa		plx		                PLX
.3a6179	68		pla		                PLA
.3a617a	28		plp		                PLP
.3a617b	60		rts		            RTS
.3a617c					FP_LN
.3a617c	08		php		                PHP
.3a617d	c2 30		rep #$30	            REP #$30
.3a617f	48		pha		                PHA
.3a6180	da		phx		                PHX
.3a6181	5a		phy		                PHY
.3a6182	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6184	10 1f		bpl $3a61a5	                BPL arg_ok
.3a6186	08		php		            PHP
.3a6187	c2 20		rep #$20	            REP #$20
.3a6189	48		pha		            PHA
.3a618a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a618d	5b		tcd		            TCD
.3a618e	68		pla		            PLA
.3a618f	28		plp		            PLP
.3a6190	e2 20		sep #$20	            SEP #$20
.3a6192	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a6194	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6198	c2 20		rep #$20	            REP #$20
.3a619a	29 ff 00	and #$00ff	            AND #$00FF
.3a619d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a61a0	e2 20		sep #$20	            SEP #$20
.3a61a2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a61a5					arg_ok
.3a61a5	c2 30		rep #$30	            REP #$30
.3a61a7	a5 23		lda $0823	                LDA ARGUMENT1
.3a61a9	cf cd 64 3a	cmp $3a64cd	                CMP @l fp_one
.3a61ad	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a61af	cf cf 64 3a	cmp $3a64cf	                CMP @l fp_one+2
.3a61b3	b0 04		bcs $3a61b9	                BCS gtone
.3a61b5	20 79 5e	jsr $3a5e79	            JSR Q_INV
.3a61b8	18		clc		                CLC
.3a61b9	a9 00 00	lda #$0000	gtone           LDA #0
.3a61bc	a8		tay		                TAY
.3a61bd	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.3a61be	48		pha		                PHA
.3a61bf	e2 20		sep #$20	            SEP #$20
.3a61c1	a9 00		lda #$00	                LDA #0
.3a61c3	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a61c7	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a61c9	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a61cd	c2 20		rep #$20	            REP #$20
.3a61cf	af 25 65 3a	lda $3a6525	                LDA @l eexp64
.3a61d3	85 29		sta $0829	                STA ARGUMENT2
.3a61d5	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a61d9	af 27 65 3a	lda $3a6527	                LDA @l eexp64+2
.3a61dd	85 2b		sta $082b	                STA ARGUMENT2+2
.3a61df	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a61e3	20 b7 5e	jsr $3a5eb7	            JSR Q_FP_SCALE
.3a61e6	8a		txa		                TXA
.3a61e7	f0 07		beq $3a61f0	                BEQ chk16
.3a61e9	0a		asl a		                ASL             ; multiply counter by 64
.3a61ea	0a		asl a		                ASL
.3a61eb	0a		asl a		                ASL
.3a61ec	0a		asl a		                ASL
.3a61ed	0a		asl a		                ASL
.3a61ee	0a		asl a		                ASL
.3a61ef	a8		tay		                TAY
.3a61f0	af 29 65 3a	lda $3a6529	chk16           LDA @l eexp16
.3a61f4	85 29		sta $0829	                STA ARGUMENT2
.3a61f6	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a61fa	af 2b 65 3a	lda $3a652b	                LDA @l eexp16+2
.3a61fe	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6200	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6204	20 b7 5e	jsr $3a5eb7	            JSR Q_FP_SCALE
.3a6207	8a		txa		                TXA
.3a6208	f0 0b		beq $3a6215	                BEQ chk04
.3a620a	0a		asl a		                ASL             ; multiply counter by 16
.3a620b	0a		asl a		                ASL
.3a620c	0a		asl a		                ASL
.3a620d	0a		asl a		                ASL
.3a620e	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.3a6210	18		clc		                CLC
.3a6211	98		tya		                TYA
.3a6212	65 29		adc $0829	                ADC ARGUMENT2
.3a6214	a8		tay		                TAY
.3a6215	af 2d 65 3a	lda $3a652d	chk04           LDA @l eexp04
.3a6219	85 29		sta $0829	                STA ARGUMENT2
.3a621b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a621f	af 2f 65 3a	lda $3a652f	                LDA @l eexp04+2
.3a6223	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6225	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6229	20 b7 5e	jsr $3a5eb7	            JSR Q_FP_SCALE
.3a622c	8a		txa		                TXA
.3a622d	f0 09		beq $3a6238	                BEQ chk01
.3a622f	0a		asl a		                ASL             ;multiply counter by 4
.3a6230	0a		asl a		                ASL
.3a6231	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.3a6233	18		clc		                CLC
.3a6234	98		tya		                TYA
.3a6235	65 29		adc $0829	                ADC ARGUMENT2
.3a6237	a8		tay		                TAY
.3a6238	af 31 65 3a	lda $3a6531	chk01           LDA @l eexp01
.3a623c	85 29		sta $0829	                STA ARGUMENT2
.3a623e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6242	af 33 65 3a	lda $3a6533	                LDA @l eexp01+2
.3a6246	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6248	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a624c	20 b7 5e	jsr $3a5eb7	            JSR Q_FP_SCALE
.3a624f	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.3a6251	18		clc		                CLC
.3a6252	98		tya		                TYA
.3a6253	65 29		adc $0829	                ADC ARGUMENT2
.3a6255	a8		tay		                TAY
.3a6256	20 11 60	jsr $3a6011	            JSR Q_FP_LN
.3a6259	a5 23		lda $0823	                LDA ARGUMENT1
.3a625b	85 29		sta $0829	                STA ARGUMENT2
.3a625d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a625f	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6261	98		tya		                TYA
.3a6262	85 23		sta $0823	                STA ARGUMENT1
.3a6264	64 25		stz $0825	                STZ ARGUMENT1+2
.3a6266	20 ab 5a	jsr $3a5aab	            JSR ITOF
.3a6269	20 88 55	jsr $3a5588	            JSR OP_FP_ADD
.3a626c	68		pla		                PLA
.3a626d	d0 07		bne $3a6276	                BNE done
.3a626f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6271	09 00 80	ora #$8000	                ORA #$8000
.3a6274	85 25		sta $0825	                STA ARGUMENT1+2
.3a6276	7a		ply		done            PLY
.3a6277	fa		plx		                PLX
.3a6278	68		pla		                PLA
.3a6279	28		plp		                PLP
.3a627a	60		rts		            RTS
.3a627b					FP_ASIN
.3a627b	08		php		                PHP
.3a627c	c2 30		rep #$30	            REP #$30
.3a627e	48		pha		                PHA
.3a627f	da		phx		                PHX
.3a6280	a5 23		lda $0823	                LDA ARGUMENT1
.3a6282	85 29		sta $0829	                STA ARGUMENT2
.3a6284	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6286	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6288	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a628b	8b		phb		                PHB
.3a628c	e2 20		sep #$20	            SEP #$20
.3a628e	a9 3a		lda #$3a	                LDA #`asin_coeff
.3a6290	48		pha		                PHA
.3a6291	ab		plb		                PLB
.3a6292	c2 20		rep #$20	            REP #$20
.3a6294	a2 d5 64	ldx #$64d5	                LDX #<>asin_coeff
.3a6297	a0 05 00	ldy #$0005	                LDY #5
.3a629a	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a629d	ab		plb		                PLB
.3a629e	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a62a1	fa		plx		                PLX
.3a62a2	68		pla		                PLA
.3a62a3	28		plp		                PLP
.3a62a4	60		rts		            RTS
.3a62a5					FP_ACOS
.3a62a5	08		php		                PHP
.3a62a6	c2 30		rep #$30	            REP #$30
.3a62a8	48		pha		                PHA
.3a62a9	da		phx		                PHX
.3a62aa	20 7b 62	jsr $3a627b	            JSR FP_ASIN
.3a62ad	af 3d 65 3a	lda $3a653d	                LDA @l halfpi
.3a62b1	85 29		sta $0829	                STA ARGUMENT2
.3a62b3	af 3f 65 3a	lda $3a653f	                LDA @l halfpi+2
.3a62b7	85 2b		sta $082b	                STA ARGUMENT2+2
.3a62b9	20 7d 55	jsr $3a557d	            JSR OP_FP_SUB
.3a62bc	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a62be	49 00 80	eor #$8000	                EOR #$8000
.3a62c1	85 25		sta $0825	                STA ARGUMENT1+2
.3a62c3	fa		plx		                PLX
.3a62c4	68		pla		                PLA
.3a62c5	28		plp		                PLP
.3a62c6	60		rts		            RTS
.3a62c7					FP_ATAN
.3a62c7	08		php		                PHP
.3a62c8	c2 30		rep #$30	            REP #$30
.3a62ca	48		pha		                PHA
.3a62cb	da		phx		                PHX
.3a62cc	a5 23		lda $0823	                LDA ARGUMENT1
.3a62ce	85 29		sta $0829	                STA ARGUMENT2
.3a62d0	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a62d2	85 2b		sta $082b	                STA ARGUMENT2+2
.3a62d4	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a62d7	8b		phb		                PHB
.3a62d8	e2 20		sep #$20	            SEP #$20
.3a62da	a9 3a		lda #$3a	                LDA #`atan_coeff
.3a62dc	48		pha		                PHA
.3a62dd	ab		plb		                PLB
.3a62de	c2 20		rep #$20	            REP #$20
.3a62e0	a2 e9 64	ldx #$64e9	                LDX #<>atan_coeff
.3a62e3	a0 05 00	ldy #$0005	                LDY #5
.3a62e6	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a62e9	ab		plb		                PLB
.3a62ea	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a62ed	fa		plx		                PLX
.3a62ee	68		pla		                PLA
.3a62ef	28		plp		                PLP
.3a62f0	60		rts		            RTS
.3a62f1					Q_FP_POW_INT
.3a62f1	c2 20		rep #$20	            REP #$20
.3a62f3	a5 23		lda $0823	            LDA ARGUMENT1
.3a62f5	85 29		sta $0829	            STA ARGUMENT2
.3a62f7	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a62f9	85 2b		sta $082b	            STA ARGUMENT2+2
.3a62fb	c2 20		rep #$20	            REP #$20
.3a62fd	af cd 64 3a	lda $3a64cd	            LDA @l fp_one
.3a6301	85 23		sta $0823	            STA ARGUMENT1
.3a6303	af cf 64 3a	lda $3a64cf	            LDA @l fp_one+2
.3a6307	85 25		sta $0825	            STA ARGUMENT1+2
.3a6309	8a		txa		loop            TXA
.3a630a	f0 30		beq $3a633c	                BEQ done
.3a630c	4a		lsr a		                LSR
.3a630d	aa		tax		                TAX
.3a630e	90 03		bcc $3a6313	                BCC next
.3a6310	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a6313					next
.3a6313	c2 20		rep #$20	            REP #$20
.3a6315	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6317	48		pha		            PHA
.3a6318	a5 23		lda $0823	            LDA ARGUMENT1
.3a631a	48		pha		            PHA
.3a631b	c2 20		rep #$20	            REP #$20
.3a631d	a5 29		lda $0829	            LDA ARGUMENT2
.3a631f	85 23		sta $0823	            STA ARGUMENT1
.3a6321	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a6323	85 25		sta $0825	            STA ARGUMENT1+2
.3a6325	20 43 5e	jsr $3a5e43	            JSR Q_SQ
.3a6328	c2 20		rep #$20	            REP #$20
.3a632a	a5 23		lda $0823	            LDA ARGUMENT1
.3a632c	85 29		sta $0829	            STA ARGUMENT2
.3a632e	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6330	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6332	c2 20		rep #$20	            REP #$20
.3a6334	68		pla		            PLA
.3a6335	85 23		sta $0823	            STA ARGUMENT1
.3a6337	68		pla		            PLA
.3a6338	85 25		sta $0825	            STA ARGUMENT1+2
.3a633a	80 cd		bra $3a6309	                BRA loop
.3a633c					done
.3a633c	60		rts		            RTS
.3a633d					Q_FP_EXP
.3a633d	08		php		                PHP
.3a633e	c2 30		rep #$30	            REP #$30
.3a6340	48		pha		                PHA
.3a6341	da		phx		                PHX
.3a6342	8b		phb		                PHB
.3a6343	e2 20		sep #$20	            SEP #$20
.3a6345	a9 3a		lda #$3a	                LDA #`exp_coeff
.3a6347	48		pha		                PHA
.3a6348	ab		plb		                PLB
.3a6349	c2 20		rep #$20	            REP #$20
.3a634b	a2 fd 64	ldx #$64fd	                LDX #<>exp_coeff
.3a634e	5a		phy		                PHY
.3a634f	a0 0a 00	ldy #$000a	                LDY #10
.3a6352	20 b4 5d	jsr $3a5db4	            JSR Q_POLY_HR
.3a6355	7a		ply		                PLY
.3a6356	ab		plb		                PLB
.3a6357	fa		plx		                PLX
.3a6358	68		pla		                PLA
.3a6359	28		plp		                PLP
.3a635a	60		rts		            RTS
.3a635b					FP_EXP
.3a635b	08		php		                PHP
.3a635c	c2 30		rep #$30	            REP #$30
.3a635e	48		pha		                PHA
.3a635f	da		phx		                PHX
.3a6360	5a		phy		                PHY
.3a6361	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.3a6363	05 25		ora $0825	                ORA ARGUMENT1+2
.3a6365	d0 10		bne $3a6377	                BNE notzero
.3a6367	c2 20		rep #$20	            REP #$20
.3a6369	af cd 64 3a	lda $3a64cd	            LDA @l fp_one
.3a636d	85 23		sta $0823	            STA ARGUMENT1
.3a636f	af cf 64 3a	lda $3a64cf	            LDA @l fp_one+2
.3a6373	85 25		sta $0825	            STA ARGUMENT1+2
.3a6375	80 61		bra $3a63d8	                BRA done
.3a6377	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.3a6379	29 00 80	and #$8000	                AND #$8000
.3a637c	a8		tay		                TAY             ; Y != 0 -> arg was negative
.3a637d	f0 07		beq $3a6386	                BEQ notneg
.3a637f	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.3a6381	29 ff 7f	and #$7fff	                AND #$7FFF
.3a6384	85 25		sta $0825	                STA ARGUMENT1+2
.3a6386					notneg
.3a6386	c2 20		rep #$20	            REP #$20
.3a6388	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a638a	48		pha		            PHA
.3a638b	a5 23		lda $0823	            LDA ARGUMENT1
.3a638d	48		pha		            PHA
.3a638e	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a6391	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.3a6393	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a6396	c2 20		rep #$20	            REP #$20
.3a6398	a5 23		lda $0823	            LDA ARGUMENT1
.3a639a	85 29		sta $0829	            STA ARGUMENT2
.3a639c	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a639e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a63a0	c2 20		rep #$20	            REP #$20
.3a63a2	68		pla		            PLA
.3a63a3	85 23		sta $0823	            STA ARGUMENT1
.3a63a5	68		pla		            PLA
.3a63a6	85 25		sta $0825	            STA ARGUMENT1+2
.3a63a8	20 7d 55	jsr $3a557d	            JSR OP_FP_SUB
.3a63ab	20 3d 63	jsr $3a633d	            JSR Q_FP_EXP
.3a63ae	c2 20		rep #$20	            REP #$20
.3a63b0	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a63b2	48		pha		            PHA
.3a63b3	a5 23		lda $0823	            LDA ARGUMENT1
.3a63b5	48		pha		            PHA
.3a63b6	c2 20		rep #$20	            REP #$20
.3a63b8	af 31 65 3a	lda $3a6531	            LDA @leexp01
.3a63bc	85 23		sta $0823	            STA ARGUMENT1
.3a63be	af 33 65 3a	lda $3a6533	            LDA @leexp01+2
.3a63c2	85 25		sta $0825	            STA ARGUMENT1+2
.3a63c4	20 f1 62	jsr $3a62f1	            JSR Q_FP_POW_INT
.3a63c7	c2 20		rep #$20	            REP #$20
.3a63c9	68		pla		            PLA
.3a63ca	85 29		sta $0829	            STA ARGUMENT2
.3a63cc	68		pla		            PLA
.3a63cd	85 2b		sta $082b	            STA ARGUMENT2+2
.3a63cf	20 1e 56	jsr $3a561e	            JSR OP_FP_MUL
.3a63d2	98		tya		                TYA
.3a63d3	f0 03		beq $3a63d8	                BEQ done
.3a63d5	20 79 5e	jsr $3a5e79	            JSR Q_INV
.3a63d8	7a		ply		done            PLY
.3a63d9	fa		plx		                PLX
.3a63da	68		pla		                PLA
.3a63db	28		plp		                PLP
.3a63dc	60		rts		            RTS
.3a63dd					FP_SQR
.3a63dd	08		php		                PHP
.3a63de	c2 30		rep #$30	            REP #$30
.3a63e0	48		pha		                PHA
.3a63e1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a63e3	10 1f		bpl $3a6404	                BPL arg_ok
.3a63e5	08		php		            PHP
.3a63e6	c2 20		rep #$20	            REP #$20
.3a63e8	48		pha		            PHA
.3a63e9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a63ec	5b		tcd		            TCD
.3a63ed	68		pla		            PLA
.3a63ee	28		plp		            PLP
.3a63ef	e2 20		sep #$20	            SEP #$20
.3a63f1	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a63f3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a63f7	c2 20		rep #$20	            REP #$20
.3a63f9	29 ff 00	and #$00ff	            AND #$00FF
.3a63fc	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a63ff	e2 20		sep #$20	            SEP #$20
.3a6401	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6404					arg_ok
.3a6404	c2 30		rep #$30	            REP #$30
.3a6406	05 23		ora $0823	                ORA ARGUMENT1
.3a6408	f0 68		beq $3a6472	                BEQ done
.3a640a	c2 20		rep #$20	            REP #$20
.3a640c	af d1 64 3a	lda $3a64d1	            LDA @l fp_two
.3a6410	85 29		sta $0829	            STA ARGUMENT2
.3a6412	af d3 64 3a	lda $3a64d3	            LDA @l fp_two+2
.3a6416	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6418	e2 20		sep #$20	            SEP #$20
.3a641a	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a641c	85 2d		sta $082d	                STA ARGTYPE2
.3a641e	c2 20		rep #$20	            REP #$20
.3a6420	c2 20		rep #$20	            REP #$20
.3a6422	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6424	48		pha		            PHA
.3a6425	a5 23		lda $0823	            LDA ARGUMENT1
.3a6427	48		pha		            PHA
.3a6428					loop
.3a6428	20 d3 55	jsr $3a55d3	            JSR OP_FP_DIV
.3a642b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a642d	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.3a642f	d0 09		bne $3a643a	                BNE more
.3a6431	a5 23		lda $0823	                LDA ARGUMENT1
.3a6433	45 29		eor $0829	                EOR ARGUMENT2
.3a6435	29 f8 ff	and #$fff8	                AND #$FFF8
.3a6438	f0 30		beq $3a646a	                BEQ exitloop
.3a643a					more
.3a643a	20 88 55	jsr $3a5588	            JSR OP_FP_ADD
.3a643d	c2 20		rep #$20	            REP #$20
.3a643f	af d1 64 3a	lda $3a64d1	            LDA @l fp_two
.3a6443	85 29		sta $0829	            STA ARGUMENT2
.3a6445	af d3 64 3a	lda $3a64d3	            LDA @l fp_two+2
.3a6449	85 2b		sta $082b	            STA ARGUMENT2+2
.3a644b	20 d3 55	jsr $3a55d3	            JSR OP_FP_DIV
.3a644e	c2 20		rep #$20	            REP #$20
.3a6450	a5 23		lda $0823	            LDA ARGUMENT1
.3a6452	85 29		sta $0829	            STA ARGUMENT2
.3a6454	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6456	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6458	c2 20		rep #$20	            REP #$20
.3a645a	68		pla		            PLA
.3a645b	85 23		sta $0823	            STA ARGUMENT1
.3a645d	68		pla		            PLA
.3a645e	85 25		sta $0825	            STA ARGUMENT1+2
.3a6460	c2 20		rep #$20	            REP #$20
.3a6462	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6464	48		pha		            PHA
.3a6465	a5 23		lda $0823	            LDA ARGUMENT1
.3a6467	48		pha		            PHA
.3a6468	80 be		bra $3a6428	                BRA loop
.3a646a					exitloop
.3a646a	c2 20		rep #$20	            REP #$20
.3a646c	68		pla		            PLA
.3a646d	85 29		sta $0829	            STA ARGUMENT2
.3a646f	68		pla		            PLA
.3a6470	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6472	68		pla		done            PLA
.3a6473	28		plp		                PLP
.3a6474	60		rts		            RTS
.3a6475					cos_coeff
>3a6475	01 0d d0 37			                .dword $37D00D01
>3a6479	61 0b b6 ba			                .dword $BAB60B61
>3a647d	ab aa 2a 3d			                .dword $3D2AAAAB
>3a6481	00 00 00 bf			                .dword $BF000000
>3a6485	00 00 80 3f			                .dword $3F800000
.3a6489					sin_coeff
>3a6489	1d ef 38 36			                .dword $3638EF1D
>3a648d	01 0d 50 b9			                .dword $B9500D01
>3a6491	89 88 08 3c			                .dword $3C088889
>3a6495	ab aa 2a be			                .dword $BE2AAAAB
>3a6499	00 00 80 3f			                .dword $3F800000
.3a649d					tan_coeff
>3a649d	a4 27 b3 3c			                .dword $3CB327A4
>3a64a1	d1 0d 5d 3d			                .dword $3D5D0DD1
>3a64a5	89 88 08 3e			                .dword $3E088889
>3a64a9	ab aa aa 3e			                .dword $3EAAAAAB
>3a64ad	00 00 80 3f			                .dword $3F800000
.3a64b1					ln_coeff
>3a64b1	89 88 88 3d			                .dword $3D888889
>3a64b5	d9 89 9d 3d			                .dword $3D9D89D9
>3a64b9	8c 2e ba 3d			                .dword $3DBA2E8C
>3a64bd	39 8e e3 3d			                .dword $3DE38E39
>3a64c1	25 49 12 3e			                .dword $3E124925
>3a64c5	cd cc 4c 3e			                .dword $3E4CCCCD
>3a64c9	ab aa aa 3e			                .dword $3EAAAAAB
>3a64cd	00 00 80 3f			fp_one          .dword $3F800000
>3a64d1	00 00 00 40			fp_two          .dword $40000000
.3a64d5					asin_coeff
>3a64d5	8e e3 f8 3c			                .dword $3CF8E38E
>3a64d9	6e db 36 3d			                .dword $3D36DB6E
>3a64dd	9a 99 99 3d			                .dword $3D99999A
>3a64e1	ab aa 2a 3e			                .dword $3E2AAAAB
>3a64e5	00 00 80 3f			                .dword $3F800000
.3a64e9					atan_coeff
>3a64e9	39 8e e3 3d			                .dword $3DE38E39
>3a64ed	25 49 12 be			                .dword $BE124925
>3a64f1	cd cc 4c 3e			                .dword $3E4CCCCD
>3a64f5	ab aa aa be			                .dword $BEAAAAAB
>3a64f9	00 00 80 3f			                .dword $3F800000
.3a64fd					exp_coeff
>3a64fd	1d ef 38 36			        .dword $3638EF1D
>3a6501	01 0d d0 37			        .dword $37D00D01
>3a6505	01 0d 50 39			        .dword $39500D01
>3a6509	61 0b b6 3a			        .dword $3AB60B61
>3a650d	89 88 08 3c			        .dword $3C088889
>3a6511	ab aa 2a 3d			        .dword $3D2AAAAB
>3a6515	ab aa 2a 3e			        .dword $3E2AAAAB
>3a6519	00 00 00 3f			        .dword $3F000000
>3a651d	00 00 80 3f			        .dword $3F800000
>3a6521	00 00 80 3f			        .dword $3F800000
>3a6525	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>3a6529	5f 97 07 4b			eexp16          .dword $4B07975F
>3a652d	81 64 5a 42			eexp04          .dword $425A6481
>3a6531	54 f8 2d 40			eexp01          .dword $402DF854
>3a6535	db 0f c9 40			twopi           .dword $40C90FDB
>3a6539	db 0f 49 40			onepi           .dword $40490FDB
>3a653d	db 0f c9 3f			halfpi          .dword $3FC90FDB
>3a6541	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.3a6545					ARR_ALLOC
.3a6545	08		php		                PHP
.3a6546	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a6549	c2 20		rep #$20	            REP #$20
.3a654b	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.3a654e	85 23		sta $0823	                STA ARGUMENT1
.3a6550	a9 00 00	lda #$0000	                LDA #0
.3a6553	85 25		sta $0825	                STA ARGUMENT1+2
.3a6555	e2 20		sep #$20	            SEP #$20
.3a6557	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a655b	c2 20		rep #$20	            REP #$20
.3a655d	29 ff 00	and #$00ff	                AND #$00FF
.3a6560	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.3a6562	a8		tay		                TAY                         ; Y := number of dimensions
.3a6563	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.3a6566					size_loop
.3a6566	c2 20		rep #$20	            REP #$20
.3a6568	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.3a656c	85 29		sta $0829	                STA ARGUMENT2
.3a656e	a9 00 00	lda #$0000	                LDA #0
.3a6571	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6573	e2 20		sep #$20	            SEP #$20
.3a6575	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6577	85 2d		sta $082d	                STA ARGTYPE2
.3a6579	c2 20		rep #$20	            REP #$20
.3a657b	20 a9 27	jsr $3a27a9	            JSR OP_MULTIPLY
.3a657e	e8		inx		                INX
.3a657f	e8		inx		                INX
.3a6580	88		dey		                DEY
.3a6581	d0 e3		bne $3a6566	                BNE size_loop               ; If there are more dimensions, take the next one
.3a6583	c2 20		rep #$20	            REP #$20
.3a6585	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.3a6588	85 29		sta $0829	                STA ARGUMENT2
.3a658a	a9 00 00	lda #$0000	                LDA #0
.3a658d	85 2b		sta $082b	                STA ARGUMENT2+2
.3a658f	20 a9 27	jsr $3a27a9	            JSR OP_MULTIPLY
.3a6592	e2 20		sep #$20	            SEP #$20
.3a6594	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.3a6598	85 0c		sta $080c	                STA SCRATCH
.3a659a	a9 00		lda #$00	                LDA #0
.3a659c	85 0d		sta $080d	                STA SCRATCH+1
.3a659e	c2 20		rep #$20	            REP #$20
.3a65a0	06 0c		asl $080c	                ASL SCRATCH
.3a65a2	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.3a65a3	a5 23		lda $0823	                LDA ARGUMENT1
.3a65a5	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.3a65a7	85 23		sta $0823	                STA ARGUMENT1
.3a65a9	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a65ab	69 00 00	adc #$0000	                ADC #0
.3a65ae	85 25		sta $0825	                STA ARGUMENT1+2
.3a65b0	d0 29		bne $3a65db	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.3a65b2	e2 20		sep #$20	            SEP #$20
.3a65b4	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.3a65b6	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.3a65b8	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.3a65ba	20 22 10	jsr $3a1022	            JSR ALLOC
.3a65bd	e2 20		sep #$20	            SEP #$20
.3a65bf	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a65c3	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.3a65c5	a0 01 00	ldy #$0001	                LDY #1
.3a65c8	a2 00 00	ldx #$0000	                LDX #0
.3a65cb					copy_loop
.3a65cb	e2 20		sep #$20	            SEP #$20
.3a65cd	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.3a65d1	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.3a65d3	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.3a65d5	f0 23		beq $3a65fa	                BEQ null_array              ; Yes: clear the array
.3a65d7	e8		inx		                INX                         ; No: move to the next byte
.3a65d8	c8		iny		                INY
.3a65d9	80 f0		bra $3a65cb	                BRA copy_loop
.3a65db					too_big
.3a65db	08		php		            PHP
.3a65dc	c2 20		rep #$20	            REP #$20
.3a65de	48		pha		            PHA
.3a65df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a65e2	5b		tcd		            TCD
.3a65e3	68		pla		            PLA
.3a65e4	28		plp		            PLP
.3a65e5	e2 20		sep #$20	            SEP #$20
.3a65e7	a9 09		lda #$09	            LDA #ERR_RANGE
.3a65e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a65ed	c2 20		rep #$20	            REP #$20
.3a65ef	29 ff 00	and #$00ff	            AND #$00FF
.3a65f2	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a65f5	e2 20		sep #$20	            SEP #$20
.3a65f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a65fa					null_array
.3a65fa	e2 20		sep #$20	            SEP #$20
.3a65fc	38		sec		                SEC                         ; INDEX := pointer to first value
.3a65fd	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a65ff	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.3a6601	85 08		sta $0808	                STA INDEX
.3a6603	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.3a6605	69 00		adc #$00	                ADC #0
.3a6607	85 09		sta $0809	                STA INDEX+1
.3a6609	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a660b	69 00		adc #$00	                ADC #0
.3a660d	85 0a		sta $080a	                STA INDEX+2
.3a660f	64 0b		stz $080b	                STZ INDEX+3
.3a6611	c2 20		rep #$20	            REP #$20
.3a6613	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.3a6616	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a6618	85 0c		sta $080c	                STA SCRATCH
.3a661a	e2 20		sep #$20	            SEP #$20
.3a661c	c8		iny		                INY
.3a661d	c8		iny		                INY
.3a661e	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a6620	85 0e		sta $080e	                STA SCRATCH+2
.3a6622	64 0f		stz $080f	                STZ SCRATCH+3
.3a6624					clr_loop
.3a6624	e2 20		sep #$20	            SEP #$20
.3a6626	a9 00		lda #$00	                LDA #0
.3a6628	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.3a662a	c2 20		rep #$20	            REP #$20
.3a662c	18		clc		                CLC                         ; Increment INDEX
.3a662d	a5 08		lda $0808	                LDA INDEX
.3a662f	69 01 00	adc #$0001	                ADC #1
.3a6632	85 08		sta $0808	                STA INDEX
.3a6634	a5 0a		lda $080a	                LDA INDEX+2
.3a6636	69 00 00	adc #$0000	                ADC #0
.3a6639	85 0a		sta $080a	                STA INDEX+2
.3a663b	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.3a663d	d0 e5		bne $3a6624	                BNE clr_loop                ; No: write to this next byte
.3a663f	a5 08		lda $0808	                LDA INDEX
.3a6641	c5 0c		cmp $080c	                CMP SCRATCH
.3a6643	d0 df		bne $3a6624	                BNE clr_loop
.3a6645					done
.3a6645	28		plp		                PLP
.3a6646	60		rts		            RTS
.3a6647					ARR_CELL
.3a6647	08		php		                PHP
.3a6648	c2 20		rep #$20	            REP #$20
.3a664a	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.3a664c	64 0a		stz $080a	                STZ INDEX+2
.3a664e	e2 20		sep #$20	            SEP #$20
.3a6650	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.3a6654	85 8f		sta $088f	                STA MCOUNT
.3a6656	64 90		stz $0890	                STZ MCOUNT+1
.3a6658	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.3a665b	e2 20		sep #$20	            SEP #$20
.3a665d	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.3a665f	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.3a6661	f0 22		beq $3a6685	                BEQ dims_match          ; Yes: the dimensions match
.3a6663	a6 8f		ldx $088f	                LDX MCOUNT
.3a6665	00		brk #		                BRK
.3a6666					arg_err
.3a6666	08		php		            PHP
.3a6667	c2 20		rep #$20	            REP #$20
.3a6669	48		pha		            PHA
.3a666a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a666d	5b		tcd		            TCD
.3a666e	68		pla		            PLA
.3a666f	28		plp		            PLP
.3a6670	e2 20		sep #$20	            SEP #$20
.3a6672	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6674	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6678	c2 20		rep #$20	            REP #$20
.3a667a	29 ff 00	and #$00ff	            AND #$00FF
.3a667d	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6680	e2 20		sep #$20	            SEP #$20
.3a6682	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6685	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.3a6687	f0 3a		beq $3a66c3	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.3a6689	a0 01 00	ldy #$0001	                LDY #1
.3a668c					index_loop
.3a668c	e2 20		sep #$20	            SEP #$20
.3a668e	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.3a6692	85 23		sta $0823	                STA ARGUMENT1
.3a6694	64 24		stz $0824	                STZ ARGUMENT1+1
.3a6696	64 25		stz $0825	                STZ ARGUMENT1+2
.3a6698	64 26		stz $0826	                STZ ARGUMENT1+3
.3a669a	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.3a669c	85 29		sta $0829	                STA ARGUMENT2
.3a669e	64 2a		stz $082a	                STZ ARGUMENT2+1
.3a66a0	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a66a2	64 2c		stz $082c	                STZ ARGUMENT2+3
.3a66a4	a5 23		lda $0823	                LDA ARGUMENT1
.3a66a6	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.3a66a8	b0 68		bcs $3a6712	                BGE range_err           ; Yes: throw an out-of-range error
.3a66aa	20 a9 27	jsr $3a27a9	            JSR OP_MULTIPLY
.3a66ad	c2 20		rep #$20	            REP #$20
.3a66af	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.3a66b0	a5 08		lda $0808	                LDA INDEX
.3a66b2	65 23		adc $0823	                ADC ARGUMENT1
.3a66b4	85 08		sta $0808	                STA INDEX
.3a66b6	a5 0a		lda $080a	                LDA INDEX+2
.3a66b8	65 25		adc $0825	                ADC ARGUMENT1+2
.3a66ba	85 0a		sta $080a	                STA INDEX+2
.3a66bc	e8		inx		                INX
.3a66bd	e8		inx		                INX
.3a66be	c8		iny		                INY
.3a66bf	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.3a66c1	d0 c9		bne $3a668c	                BNE index_loop          ; No: move to the next index and try again
.3a66c3					add_last
.3a66c3	e2 20		sep #$20	            SEP #$20
.3a66c5	18		clc		                CLC
.3a66c6	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.3a66ca	85 90		sta $0890	                STA MCOUNT+1
.3a66cc	65 08		adc $0808	                ADC INDEX
.3a66ce	85 08		sta $0808	                STA INDEX
.3a66d0	a5 09		lda $0809	                LDA INDEX+1
.3a66d2	69 00		adc #$00	                ADC #0
.3a66d4	85 09		sta $0809	                STA INDEX+1
.3a66d6	c2 20		rep #$20	            REP #$20
.3a66d8	a5 0a		lda $080a	                LDA INDEX+2
.3a66da	69 00 00	adc #$0000	                ADC #0
.3a66dd	85 0a		sta $080a	                STA INDEX+2
.3a66df	c2 20		rep #$20	            REP #$20
.3a66e1	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.3a66e3	26 0a		rol $080a	                ROL INDEX+2
.3a66e5	06 08		asl $0808	                ASL INDEX
.3a66e7	26 0a		rol $080a	                ROL INDEX+2
.3a66e9	e2 20		sep #$20	            SEP #$20
.3a66eb	38		sec		                SEC
.3a66ec	a5 08		lda $0808	                LDA INDEX
.3a66ee	65 8f		adc $088f	                ADC MCOUNT
.3a66f0	85 08		sta $0808	                STA INDEX
.3a66f2	a5 09		lda $0809	                LDA INDEX+1
.3a66f4	69 00		adc #$00	                ADC #0
.3a66f6	85 09		sta $0809	                STA INDEX+1
.3a66f8	c2 20		rep #$20	            REP #$20
.3a66fa	a5 0a		lda $080a	                LDA INDEX+2
.3a66fc	69 00 00	adc #$0000	                ADC #0
.3a66ff	85 0a		sta $080a	                STA INDEX+2
.3a6701	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.3a6702	a5 08		lda $0808	                LDA INDEX
.3a6704	65 c0		adc $08c0	                ADC CURRBLOCK
.3a6706	85 08		sta $0808	                STA INDEX
.3a6708	e2 20		sep #$20	            SEP #$20
.3a670a	a5 0a		lda $080a	                LDA INDEX+2
.3a670c	65 c2		adc $08c2	                ADC CURRBLOCK+2
.3a670e	85 0a		sta $080a	                STA INDEX+2
.3a6710	28		plp		                PLP
.3a6711	60		rts		            RTS
.3a6712					range_err
.3a6712	08		php		            PHP
.3a6713	c2 20		rep #$20	            REP #$20
.3a6715	48		pha		            PHA
.3a6716	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6719	5b		tcd		            TCD
.3a671a	68		pla		            PLA
.3a671b	28		plp		            PLP
.3a671c	e2 20		sep #$20	            SEP #$20
.3a671e	a9 09		lda #$09	            LDA #ERR_RANGE
.3a6720	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6724	c2 20		rep #$20	            REP #$20
.3a6726	29 ff 00	and #$00ff	            AND #$00FF
.3a6729	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a672c	e2 20		sep #$20	            SEP #$20
.3a672e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6731					ARR_SET
.3a6731	08		php		                PHP
.3a6732	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a6735	e2 20		sep #$20	            SEP #$20
.3a6737	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a673a	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a673c	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a673e	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.3a6740	d0 05		bne $3a6747	                BNE chk_integer
.3a6742	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6745	80 10		bra $3a6757	                BRA save_type
.3a6747	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.3a6749	d0 05		bne $3a6750	                BNE chk_float
.3a674b	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a674e	80 07		bra $3a6757	                BRA save_type
.3a6750	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.3a6752	d0 2b		bne $3a677f	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.3a6754	20 13 07	jsr $3a0713	            JSR ASS_ARG1_FLOAT
.3a6757	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.3a6759	48		pha		                PHA
.3a675a	c2 20		rep #$20	            REP #$20
.3a675c	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.3a675e	48		pha		                PHA
.3a675f	a5 23		lda $0823	                LDA ARGUMENT1
.3a6761	48		pha		                PHA
.3a6762	20 47 66	jsr $3a6647	            JSR ARR_CELL
.3a6765	68		pla		                PLA                 ; Restore ARGUMENT1
.3a6766	85 23		sta $0823	                STA ARGUMENT1
.3a6768	68		pla		                PLA
.3a6769	85 25		sta $0825	                STA ARGUMENT1+2
.3a676b	e2 20		sep #$20	            SEP #$20
.3a676d	68		pla		                PLA
.3a676e	85 27		sta $0827	                STA ARGTYPE1
.3a6770	c2 20		rep #$20	            REP #$20
.3a6772	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.3a6774	87 08		sta [$0808]	                STA [INDEX]
.3a6776	a0 02 00	ldy #$0002	                LDY #2
.3a6779	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a677b	97 08		sta [$0808],y	                STA [INDEX],Y
.3a677d	28		plp		                PLP
.3a677e	60		rts		            RTS
.3a677f					type_mismatch
.3a677f	08		php		            PHP
.3a6780	c2 20		rep #$20	            REP #$20
.3a6782	48		pha		            PHA
.3a6783	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6786	5b		tcd		            TCD
.3a6787	68		pla		            PLA
.3a6788	28		plp		            PLP
.3a6789	e2 20		sep #$20	            SEP #$20
.3a678b	a9 04		lda #$04	            LDA #ERR_TYPE
.3a678d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6791	c2 20		rep #$20	            REP #$20
.3a6793	29 ff 00	and #$00ff	            AND #$00FF
.3a6796	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6799	e2 20		sep #$20	            SEP #$20
.3a679b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a679e					ARR_REF
.3a679e	08		php		                PHP
.3a679f	20 5e 12	jsr $3a125e	            JSR HEAP_GETHED
.3a67a2	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.3a67a5	f4 00 00	pea #$0000	                PEA #0
.3a67a8	e2 20		sep #$20	            SEP #$20
.3a67aa	48		pha		                PHA
.3a67ab	20 47 66	jsr $3a6647	            JSR ARR_CELL
.3a67ae	e2 20		sep #$20	            SEP #$20
.3a67b0	68		pla		                PLA
.3a67b1	c2 20		rep #$20	            REP #$20
.3a67b3	68		pla		                PLA
.3a67b4	68		pla		                PLA
.3a67b5	c2 20		rep #$20	            REP #$20
.3a67b7	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.3a67b9	85 23		sta $0823	                STA ARGUMENT1
.3a67bb	a0 02 00	ldy #$0002	                LDY #2
.3a67be	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a67c0	85 25		sta $0825	                STA ARGUMENT1+2
.3a67c2	e2 20		sep #$20	            SEP #$20
.3a67c4	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a67c7	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a67c9	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a67cb	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.3a67cd	20 b2 17	jsr $3a17b2	            JSR STR_NORMAL
.3a67d0	28		plp		                PLP
.3a67d1	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>3af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.3af273					FD_IN
>3af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>3af274					DEV                 .byte ?             ; The ID of the device holding the file
>3af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>3af279					CLUSTER             .dword ?            ; The current cluster of the file.
>3af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>3af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>3af285					FILESIZE            .dword ?            ; The size of the file
>3af289					CREATE_DATE         .word ?             ; The creation date of the file
>3af28b					CREATE_TIME         .word ?             ; The creation time of the file
>3af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>3af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.3a67d2					PR_FILESIZE
.3a67d2	da		phx		                PHX
.3a67d3	0b		phd		                PHD
.3a67d4	08		php		                PHP
.3a67d5	08		php		            PHP
.3a67d6	c2 20		rep #$20	            REP #$20
.3a67d8	48		pha		            PHA
.3a67d9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a67dc	5b		tcd		            TCD
.3a67dd	68		pla		            PLA
.3a67de	28		plp		            PLP
.3a67df	c2 30		rep #$30	            REP #$30
.3a67e1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a67e3	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.3a67e6	d0 29		bne $3a6811	                BNE pr_mb               ; If so, print it in MBs
.3a67e8	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.3a67eb	d0 0c		bne $3a67f9	                BNE pr_kb
.3a67ed	a5 23		lda $0823	                LDA ARGUMENT1
.3a67ef	89 00 fc	bit #$fc00	                BIT #$FC00
.3a67f2	d0 05		bne $3a67f9	                BNE pr_kb               ; If so, print it in KBs
.3a67f4					pr_regular
.3a67f4	20 20 45	jsr $3a4520	            JSR PR_INTEGER
.3a67f7	80 2e		bra $3a6827	                BRA done
.3a67f9	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.3a67fc	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.3a67fe	66 23		ror $0823	                ROR ARGUMENT1
.3a6800	ca		dex		                DEX
.3a6801	d0 f9		bne $3a67fc	                BNE kb_shift
.3a6803	20 20 45	jsr $3a4520	            JSR PR_INTEGER
.3a6806	e2 20		sep #$20	            SEP #$20
.3a6808	a9 4b		lda #$4b	                LDA #'K'
.3a680a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a680d	c2 20		rep #$20	            REP #$20
.3a680f	80 16		bra $3a6827	                BRA done
.3a6811	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.3a6814	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.3a6816	66 23		ror $0823	                ROR ARGUMENT1
.3a6818	ca		dex		                DEX
.3a6819	d0 f9		bne $3a6814	                BNE mb_shift
.3a681b	20 20 45	jsr $3a4520	            JSR PR_INTEGER
.3a681e	e2 20		sep #$20	            SEP #$20
.3a6820	a9 4d		lda #$4d	                LDA #'M'
.3a6822	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6825	c2 20		rep #$20	            REP #$20
.3a6827	28		plp		done            PLP
.3a6828	2b		pld		                PLD
.3a6829	fa		plx		                PLX
.3a682a	60		rts		            RTS
.3a682b					CMD_DIR
.3a682b	0b		phd		                PHD
.3a682c	08		php		                PHP
.3a682d	c2 30		rep #$30	            REP #$30
.3a682f	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.3a6832	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.3a6836	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.3a683a	e2 20		sep #$20	            SEP #$20
.3a683c	20 cd 21	jsr $3a21cd	            JSR PEEK_TOK
.3a683f	c9 00		cmp #$00	                CMP #0
.3a6841	f0 08		beq $3a684b	                BEQ set_null                ; If none provided, set the path to empty
.3a6843	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6846	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6849	80 11		bra $3a685c	                BRA set_fd
.3a684b					set_null
.3a684b	c2 20		rep #$20	            REP #$20
.3a684d	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.3a6850	85 23		sta $0823	                STA ARGUMENT1
.3a6852	85 25		sta $0825	                STA ARGUMENT1+2
.3a6854	e2 20		sep #$20	            SEP #$20
.3a6856	a9 02		lda #$02	                LDA #TYPE_STRING
.3a6858	85 27		sta $0827	                STA ARGTYPE1
.3a685a	c2 20		rep #$20	            REP #$20
.3a685c					set_fd
.3a685c	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a685f	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.3a6863	b0 22		bcs $3a6887	                BCS pr_first
.3a6865	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6868	08		php		            PHP
.3a6869	c2 20		rep #$20	            REP #$20
.3a686b	48		pha		            PHA
.3a686c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a686f	5b		tcd		            TCD
.3a6870	68		pla		            PLA
.3a6871	28		plp		            PLP
.3a6872	e2 20		sep #$20	            SEP #$20
.3a6874	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.3a6876	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a687a	c2 20		rep #$20	            REP #$20
.3a687c	29 ff 00	and #$00ff	            AND #$00FF
.3a687f	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6882	e2 20		sep #$20	            SEP #$20
.3a6884	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6887					pr_first
.3a6887	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a688a					pr_entry
.3a688a	08		php		            PHP
.3a688b	c2 20		rep #$20	            REP #$20
.3a688d	48		pha		            PHA
.3a688e	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6891	5b		tcd		            TCD
.3a6892	68		pla		            PLA
.3a6893	28		plp		            PLP
.3a6894	e2 20		sep #$20	            SEP #$20
.3a6896	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.3a6899	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.3a689b	d0 03		bne $3a68a0	                BNE chk_unused
.3a689d	82 a9 00	brl $3a6949	                BRL done                    ; If it's NULL, we're done
.3a68a0	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.3a68a2	d0 03		bne $3a68a7	                BNE chk_attributes
.3a68a4	82 96 00	brl $3a693d	                BRL next_entry              ; Yes: go to the next entry
.3a68a7	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.3a68aa	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.3a68ac	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a68ae	f0 03		beq $3a68b3	                BEQ chk_hidden
.3a68b0	82 a9 00	brl $3a695c	                BRL pr_volume               ; Print the volume label
.3a68b3	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.3a68b5	f0 03		beq $3a68ba	                BEQ chk_long
.3a68b7	82 83 00	brl $3a693d	                BRL next_entry              ; Yes: go to the next entry
.3a68ba	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a68bc	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a68be	d0 03		bne $3a68c3	                BNE get_short_name
.3a68c0	82 7a 00	brl $3a693d	                BRL next_entry              ; Yes: go to the next entry
.3a68c3	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a68c6	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a68c8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a68cb	c8		iny		                INY                         ; Move to the next character
.3a68cc	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a68cf	d0 f5		bne $3a68c6	                BNE pr_name_loop            ; No: print this new character
.3a68d1	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.3a68d3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a68d6	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.3a68d9	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a68db	20 18 00	jsr $3a0018	                JSR PRINTC                  ; Otherwise: print it.
.3a68de	c8		iny		                INY                         ; Move to the next character
.3a68df	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.3a68e2	d0 f5		bne $3a68d9	                BNE pr_ext_loop             ; No: print this new character
.3a68e4	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.3a68e6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a68e9	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a68ec	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a68ee	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a68f0	d0 1e		bne $3a6910	                BNE pr_attr                 ; Yes: skip printing a file size
.3a68f2	c2 20		rep #$20	            REP #$20
.3a68f4	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.3a68f7	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.3a68f9	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a68fd	c8		iny		                INY
.3a68fe	c8		iny		                INY
.3a68ff	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.3a6901	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a6905	e2 20		sep #$20	            SEP #$20
.3a6907	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6909	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a690d	20 d2 67	jsr $3a67d2	            JSR PR_FILESIZE
.3a6910	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.3a6912	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6915	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a6918	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a691a	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a691c	d0 1c		bne $3a693a	                BNE end_entry               ; Yes: we're done printing this entry
.3a691e	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.3a6920	f0 05		beq $3a6927	                BEQ chk_system
.3a6922	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.3a6924	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6927	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.3a6929	f0 05		beq $3a6930	                BEQ chk_directory
.3a692b	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.3a692d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6930	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a6932	f0 05		beq $3a6939	                BEQ pr_tab2
.3a6934	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.3a6936	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6939	ea		nop		pr_tab2         NOP
.3a693a					end_entry
.3a693a	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a693d					next_entry
.3a693d	20 42 03	jsr $3a0342	            JSR PAGINATE
.3a6940	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.3a6944	90 03		bcc $3a6949	                BCC done
.3a6946	82 41 ff	brl $3a688a	                BRL pr_entry
.3a6949					done
.3a6949	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a694c	08		php		            PHP
.3a694d	c2 20		rep #$20	            REP #$20
.3a694f	48		pha		            PHA
.3a6950	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6953	5b		tcd		            TCD
.3a6954	68		pla		            PLA
.3a6955	28		plp		            PLP
.3a6956	20 b1 20	jsr $3a20b1	            JSR SKIPSTMT
.3a6959	28		plp		                PLP
.3a695a	2b		pld		                PLD
.3a695b	60		rts		            RTS
.3a695c					pr_volume
.3a695c	08		php		            PHP
.3a695d	c2 20		rep #$20	            REP #$20
.3a695f	48		pha		            PHA
.3a6960	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6963	5b		tcd		            TCD
.3a6964	68		pla		            PLA
.3a6965	28		plp		            PLP
.3a6966	e2 20		sep #$20	            SEP #$20
.3a6968	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a696a	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a696c	f0 cf		beq $3a693d	                BEQ next_entry              ; Yes: skip it
.3a696e	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.3a6970	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6973	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6976	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6978	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.3a697a	f0 09		beq $3a6985	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.3a697c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a697f	c8		iny		                INY                         ; Move to the next character
.3a6980	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a6983	d0 f1		bne $3a6976	                BNE pr_vol_loop             ; No: print this new character
.3a6985	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.3a6987	20 18 00	jsr $3a0018	            JSR PRINTC
.3a698a	80 ae		bra $3a693a	                BRA end_entry               ; And try to get the next entry
.3a698c					SETFILEDESC
.3a698c	0b		phd		                PHD
.3a698d	08		php		                PHP
.3a698e	08		php		            PHP
.3a698f	c2 20		rep #$20	            REP #$20
.3a6991	48		pha		            PHA
.3a6992	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6995	5b		tcd		            TCD
.3a6996	68		pla		            PLA
.3a6997	28		plp		            PLP
.3a6998	c2 30		rep #$30	            REP #$30
.3a699a	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.3a699d	85 20		sta $0340	                STA DOS_FD_PTR
.3a699f	a9 3a 00	lda #$003a	                LDA #`FD_IN
.3a69a2	85 22		sta $0342	                STA DOS_FD_PTR+2
.3a69a4	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.3a69a7	e2 20		sep #$20	            SEP #$20
.3a69a9	a9 00		lda #$00	                LDA #0
.3a69ab	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.3a69ad	c8		iny		                INY
.3a69ae	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.3a69b1	d0 f8		bne $3a69ab	                BNE zero_loop
.3a69b3	c2 20		rep #$20	            REP #$20
.3a69b5	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.3a69b8	8f 81 f2 3a	sta $3af281	                STA @l FD_IN.BUFFER
.3a69bc	a9 3a 00	lda #$003a	                LDA #`CLUSTER_BUFF
.3a69bf	8f 83 f2 3a	sta $3af283	                STA @l FD_IN.BUFFER+2
.3a69c3	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.3a69c7	8f 75 f2 3a	sta $3af275	                STA @l FD_IN.PATH
.3a69cb	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a69cf	8f 77 f2 3a	sta $3af277	                STA @l FD_IN.PATH+2
.3a69d3	28		plp		                PLP
.3a69d4	2b		pld		                PLD
.3a69d5	60		rts		            RTS
.3a69d6					S_BLOAD
.3a69d6	08		php		                PHP
.3a69d7	c2 30		rep #$30	            REP #$30
.3a69d9	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a69dc	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a69df	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a69e2	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a69e5	e2 20		sep #$20	            SEP #$20
.3a69e7	a9 2c		lda #$2c	                LDA #','
.3a69e9	85 37		sta $0837	                STA TARGETTOK
.3a69eb	20 ae 21	jsr $3a21ae	            JSR OPT_TOK
.3a69ee	b0 0f		bcs $3a69ff	                BCS get_dest
.3a69f0	c2 20		rep #$20	            REP #$20
.3a69f2	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.3a69f5	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a69f9	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a69fd	80 17		bra $3a6a16	                BRA do_load
.3a69ff					get_dest
.3a69ff	20 6c 20	jsr $3a206c	            JSR INCBIP
.3a6a02	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6a05	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a6a08	c2 20		rep #$20	            REP #$20
.3a6a0a	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.3a6a0c	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6a10	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6a12	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6a16	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.3a6a1a	b0 1f		bcs $3a6a3b	                BCS done
.3a6a1c	08		php		            PHP
.3a6a1d	c2 20		rep #$20	            REP #$20
.3a6a1f	48		pha		            PHA
.3a6a20	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6a23	5b		tcd		            TCD
.3a6a24	68		pla		            PLA
.3a6a25	28		plp		            PLP
.3a6a26	e2 20		sep #$20	            SEP #$20
.3a6a28	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6a2a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6a2e	c2 20		rep #$20	            REP #$20
.3a6a30	29 ff 00	and #$00ff	            AND #$00FF
.3a6a33	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6a36	e2 20		sep #$20	            SEP #$20
.3a6a38	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6a3b	28		plp		done            PLP
.3a6a3c	60		rts		            RTS
.3a6a3d					SET_DOSSTAT
.3a6a3d	8b		phb		                PHB
.3a6a3e	0b		phd		                PHD
.3a6a3f	08		php		                PHP
.3a6a40	08		php		            PHP
.3a6a41	c2 20		rep #$20	            REP #$20
.3a6a43	48		pha		            PHA
.3a6a44	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6a47	5b		tcd		            TCD
.3a6a48	68		pla		            PLA
.3a6a49	28		plp		            PLP
.3a6a4a	08		php		            PHP
.3a6a4b	e2 20		sep #$20	            SEP #$20
.3a6a4d	48		pha		            PHA
.3a6a4e	a9 00		lda #$00	            LDA #BASIC_BANK
.3a6a50	48		pha		            PHA
.3a6a51	ab		plb		            PLB
.3a6a52	68		pla		            PLA
.3a6a53	28		plp		            PLP
.3a6a54	e2 20		sep #$20	            SEP #$20
.3a6a56	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.3a6a5a	85 23		sta $0823	                STA ARGUMENT1
.3a6a5c	a9 00		lda #$00	                LDA #0
.3a6a5e	85 24		sta $0824	                STA ARGUMENT1+1
.3a6a60	85 25		sta $0825	                STA ARGUMENT1+2
.3a6a62	85 26		sta $0826	                STA ARGUMENT1+3
.3a6a64	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6a66	85 27		sta $0827	                STA ARGTYPE1
.3a6a68	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.3a6a6a	a9 3a		lda #$3a	                LDA #`dosstat_name
.3a6a6c	85 e9		sta $08e9	                STA TOFIND+2
.3a6a6e	c2 20		rep #$20	            REP #$20
.3a6a70	a9 a0 6a	lda #$6aa0	                LDA #<>dosstat_name
.3a6a73	85 e7		sta $08e7	                STA TOFIND
.3a6a75	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a6a78	e2 20		sep #$20	            SEP #$20
.3a6a7a	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.3a6a7e	85 23		sta $0823	                STA ARGUMENT1
.3a6a80	a9 00		lda #$00	                LDA #0
.3a6a82	85 24		sta $0824	                STA ARGUMENT1+1
.3a6a84	85 25		sta $0825	                STA ARGUMENT1+2
.3a6a86	85 26		sta $0826	                STA ARGUMENT1+3
.3a6a88	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6a8a	85 27		sta $0827	                STA ARGTYPE1
.3a6a8c	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.3a6a8e	a9 3a		lda #$3a	                LDA #`biosstat_name
.3a6a90	85 e9		sta $08e9	                STA TOFIND+2
.3a6a92	c2 20		rep #$20	            REP #$20
.3a6a94	a9 a8 6a	lda #$6aa8	                LDA #<>biosstat_name
.3a6a97	85 e7		sta $08e7	                STA TOFIND
.3a6a99	20 2a 52	jsr $3a522a	            JSR VAR_SET
.3a6a9c	28		plp		                PLP
.3a6a9d	2b		pld		                PLD
.3a6a9e	ab		plb		                PLB
.3a6a9f	60		rts		            RTS
>3a6aa0	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>3a6aa8	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>3a6ab0	00
.3a6ab1					CMD_BRUN
.3a6ab1	08		php		                PHP
.3a6ab2	c2 30		rep #$30	            REP #$30
.3a6ab4	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a6ab7	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6aba	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6abd	a5 23		lda $0823	                LDA ARGUMENT1
.3a6abf	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.3a6ac3	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6ac5	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.3a6ac9	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6acc	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6ad0	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6ad4	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.3a6ad8	b0 25		bcs $3a6aff	                BCS done                    ; If we got it: try to execute it
.3a6ada	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6add	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6ae0	08		php		            PHP
.3a6ae1	c2 20		rep #$20	            REP #$20
.3a6ae3	48		pha		            PHA
.3a6ae4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ae7	5b		tcd		            TCD
.3a6ae8	68		pla		            PLA
.3a6ae9	28		plp		            PLP
.3a6aea	e2 20		sep #$20	            SEP #$20
.3a6aec	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6aee	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6af2	c2 20		rep #$20	            REP #$20
.3a6af4	29 ff 00	and #$00ff	            AND #$00FF
.3a6af7	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6afa	e2 20		sep #$20	            SEP #$20
.3a6afc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6aff					done
.3a6aff	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6b02	28		plp		                PLP
.3a6b03	60		rts		            RTS
.3a6b04					CMD_LOAD
.3a6b04	08		php		                PHP
.3a6b05	c2 30		rep #$30	            REP #$30
.3a6b07	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a6b0a	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6b0d	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6b10	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a6b13	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6b16	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6b1a	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6b1d	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.3a6b21	20 fb 4e	jsr $3a4efb	            JSR CMD_NEW
.3a6b24	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.3a6b28	b0 22		bcs $3a6b4c	                BCS start_tokenize          ; If we got it: start tokenizing
.3a6b2a	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6b2d	08		php		            PHP
.3a6b2e	c2 20		rep #$20	            REP #$20
.3a6b30	48		pha		            PHA
.3a6b31	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6b34	5b		tcd		            TCD
.3a6b35	68		pla		            PLA
.3a6b36	28		plp		            PLP
.3a6b37	e2 20		sep #$20	            SEP #$20
.3a6b39	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6b3b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6b3f	c2 20		rep #$20	            REP #$20
.3a6b41	29 ff 00	and #$00ff	            AND #$00FF
.3a6b44	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6b47	e2 20		sep #$20	            SEP #$20
.3a6b49	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6b4c					start_tokenize
.3a6b4c	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6b4f	c2 20		rep #$20	            REP #$20
.3a6b51	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.3a6b54	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.3a6b55	bf 73 f2 3a	lda $3af273,x	                LDA FD_IN,X
.3a6b59	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.3a6b5c	85 92		sta $0892	                STA MTEMP
.3a6b5e	bf 75 f2 3a	lda $3af275,x	                LDA FD_IN+2,X
.3a6b62	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.3a6b65	85 94		sta $0894	                STA MTEMP+2
.3a6b67	e2 20		sep #$20	            SEP #$20
.3a6b69	a9 00		lda #$00	                LDA #0
.3a6b6b	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.3a6b6d	c2 20		rep #$20	            REP #$20
.3a6b6f	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.3a6b72	85 7a		sta $087a	                STA MCURSOR
.3a6b74	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6b77	85 7c		sta $087c	                STA MCURSOR+2
.3a6b79	a2 00 00	ldx #$0000	copy_line       LDX #0
.3a6b7c					copy_char
.3a6b7c	e2 20		sep #$20	            SEP #$20
.3a6b7e	a7 7a		lda [$087a]	                LDA [MCURSOR]
.3a6b80	f0 2a		beq $3a6bac	                BEQ clean_up                ; If the character is 0, we're done
.3a6b82	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.3a6b84	f0 12		beq $3a6b98	                BEQ do_process              ; ... we want to process the line
.3a6b86	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.3a6b88	f0 04		beq $3a6b8e	                BEQ next_char               ; ... we want to skip it
.3a6b8a	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.3a6b8d	e8		inx		                INX
.3a6b8e					next_char
.3a6b8e	c2 20		rep #$20	            REP #$20
.3a6b90	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.3a6b92	d0 e8		bne $3a6b7c	                BNE copy_char
.3a6b94	e6 7c		inc $087c	                INC MCURSOR+2
.3a6b96	80 e4		bra $3a6b7c	                BRA copy_char
.3a6b98					do_process
.3a6b98	e2 20		sep #$20	            SEP #$20
.3a6b9a	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.3a6b9c	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6b9f	20 dc 26	jsr $3a26dc	            JSR PROCESS
.3a6ba2	c2 20		rep #$20	            REP #$20
.3a6ba4	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.3a6ba6	d0 d1		bne $3a6b79	                BNE copy_line
.3a6ba8	e6 7c		inc $087c	                INC MCURSOR+2
.3a6baa	80 cd		bra $3a6b79	                BRA copy_line
.3a6bac	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.3a6baf	f0 0a		beq $3a6bbb	                BEQ done                    ; No: just return
.3a6bb1	e2 20		sep #$20	            SEP #$20
.3a6bb3	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.3a6bb5	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6bb8	20 dc 26	jsr $3a26dc	            JSR PROCESS
.3a6bbb	28		plp		done            PLP
.3a6bbc	60		rts		            RTS
.3a6bbd					S_BSAVE
.3a6bbd	08		php		                PHP
.3a6bbe	c2 30		rep #$30	            REP #$30
.3a6bc0	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a6bc3	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6bc6	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6bc9	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a6bcc	e2 20		sep #$20	            SEP #$20
.3a6bce	a9 2c		lda #$2c	                LDA #','
.3a6bd0	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a6bd3	c2 20		rep #$20	            REP #$20
.3a6bd5	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6bd8	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a6bdb	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.3a6bdd	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6be1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6be3	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6be7	e2 20		sep #$20	            SEP #$20
.3a6be9	a9 2c		lda #$2c	                LDA #','
.3a6beb	c2 20		rep #$20	            REP #$20
.3a6bed	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a6bf0	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6bf3	20 a5 05	jsr $3a05a5	            JSR ASS_ARG1_INT
.3a6bf6	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.3a6bf8	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6bfc	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6bfe	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6c02	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.3a6c06	b0 22		bcs $3a6c2a	                BCS done
.3a6c08	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6c0b	08		php		            PHP
.3a6c0c	c2 20		rep #$20	            REP #$20
.3a6c0e	48		pha		            PHA
.3a6c0f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6c12	5b		tcd		            TCD
.3a6c13	68		pla		            PLA
.3a6c14	28		plp		            PLP
.3a6c15	e2 20		sep #$20	            SEP #$20
.3a6c17	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6c19	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6c1d	c2 20		rep #$20	            REP #$20
.3a6c1f	29 ff 00	and #$00ff	            AND #$00FF
.3a6c22	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6c25	e2 20		sep #$20	            SEP #$20
.3a6c27	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6c2a					done
.3a6c2a	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6c2d	28		plp		                PLP
.3a6c2e	60		rts		            RTS
.3a6c2f					COPY2PATHBUF
.3a6c2f	da		phx		                PHX
.3a6c30	5a		phy		                PHY
.3a6c31	08		php		                PHP
.3a6c32	a2 00 00	ldx #$0000	                LDX #0
.3a6c35	a0 00 00	ldy #$0000	                LDY #0
.3a6c38	e2 20		sep #$20	            SEP #$20
.3a6c3a	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.3a6c3c	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.3a6c3f	f0 04		beq $3a6c45	                BEQ done
.3a6c41	e8		inx		                INX
.3a6c42	c8		iny		                INY
.3a6c43	80 f5		bra $3a6c3a	                BRA loop
.3a6c45	28		plp		done            PLP
.3a6c46	7a		ply		                PLY
.3a6c47	fa		plx		                PLX
.3a6c48	60		rts		            RTS
.3a6c49					CMD_SAVE
.3a6c49	08		php		                PHP
.3a6c4a	c2 30		rep #$30	            REP #$30
.3a6c4c	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a6c4f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6c52	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6c55	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a6c58	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6c5b	85 a6		sta $08a6	                STA OBUFFER
.3a6c5d	e2 20		sep #$20	            SEP #$20
.3a6c5f	a9 01		lda #$01	                LDA #`LOADBLOCK
.3a6c61	85 a8		sta $08a8	                STA OBUFFER+2
.3a6c63	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.3a6c65	85 b4		sta $08b4	                STA BCONSOLE
.3a6c67	c2 20		rep #$20	            REP #$20
.3a6c69	a9 00 00	lda #$0000	                LDA #0
.3a6c6c	85 ab		sta $08ab	                STA OBUFFIDX
.3a6c6e	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6c71	85 a9		sta $08a9	                STA OBUFFSIZE
.3a6c73	c2 20		rep #$20	            REP #$20
.3a6c75	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.3a6c78	85 55		sta $0855	                STA MARG1
.3a6c7a	85 57		sta $0857	                STA MARG1+2
.3a6c7c	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.3a6c7f	85 59		sta $0859	                STA MARG2
.3a6c81	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a6c84	85 5b		sta $085b	                STA MARG2+2
.3a6c86	20 da 17	jsr $3a17da	            JSR LISTPROG
.3a6c89	e2 20		sep #$20	            SEP #$20
.3a6c8b	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.3a6c8d	85 b4		sta $08b4	                STA BCONSOLE
.3a6c8f	c2 20		rep #$20	            REP #$20
.3a6c91	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.3a6c93	18		clc		                CLC                         ; Set the range of memory to save
.3a6c94	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6c97	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6c9b	65 ab		adc $08ab	                ADC OBUFFIDX
.3a6c9d	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6ca1	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6ca4	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6ca8	69 00 00	adc #$0000	                ADC #0
.3a6cab	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6caf	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.3a6cb3	b0 22		bcs $3a6cd7	                BCS done
.3a6cb5	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6cb8	08		php		            PHP
.3a6cb9	c2 20		rep #$20	            REP #$20
.3a6cbb	48		pha		            PHA
.3a6cbc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6cbf	5b		tcd		            TCD
.3a6cc0	68		pla		            PLA
.3a6cc1	28		plp		            PLP
.3a6cc2	e2 20		sep #$20	            SEP #$20
.3a6cc4	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6cc6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6cca	c2 20		rep #$20	            REP #$20
.3a6ccc	29 ff 00	and #$00ff	            AND #$00FF
.3a6ccf	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6cd2	e2 20		sep #$20	            SEP #$20
.3a6cd4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6cd7					done
.3a6cd7	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6cda	28		plp		                PLP
.3a6cdb	60		rts		            RTS
.3a6cdc					S_DEL
.3a6cdc	08		php		                PHP
.3a6cdd	c2 30		rep #$30	            REP #$30
.3a6cdf	20 8d 20	jsr $3a208d	            JSR SKIPWS
.3a6ce2	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6ce5	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6ce8	20 2f 6c	jsr $3a6c2f	            JSR COPY2PATHBUF
.3a6ceb	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.3a6cef	b0 22		bcs $3a6d13	                BCS done
.3a6cf1	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6cf4	08		php		            PHP
.3a6cf5	c2 20		rep #$20	            REP #$20
.3a6cf7	48		pha		            PHA
.3a6cf8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6cfb	5b		tcd		            TCD
.3a6cfc	68		pla		            PLA
.3a6cfd	28		plp		            PLP
.3a6cfe	e2 20		sep #$20	            SEP #$20
.3a6d00	a9 13		lda #$13	            LDA #ERR_DELETE
.3a6d02	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6d06	c2 20		rep #$20	            REP #$20
.3a6d08	29 ff 00	and #$00ff	            AND #$00FF
.3a6d0b	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6d0e	e2 20		sep #$20	            SEP #$20
.3a6d10	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6d13					done
.3a6d13	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6d16	28		plp		                PLP
.3a6d17	60		rts		            RTS
.3a6d18					VALIDFILECHAR
.3a6d18	da		phx		                PHX
.3a6d19	08		php		                PHP
.3a6d1a	e2 20		sep #$20	            SEP #$20
.3a6d1c	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.3a6d1e	90 08		bcc $3a6d28	                BLT chk_space
.3a6d20	c9 7b		cmp #$7b	                CMP #'z'+1
.3a6d22	b0 04		bcs $3a6d28	                BGE chk_space
.3a6d24	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.3a6d26	80 13		bra $3a6d3b	                BRA ret_valid
.3a6d28	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.3a6d2a	90 13		bcc $3a6d3f	                BLT is_invalid          ; Yes: it's invalid
.3a6d2c	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.3a6d2f	df 43 6d 3a	cmp $3a6d43,x	loop            CMP invalid_chars,X
.3a6d33	f0 0a		beq $3a6d3f	                BEQ is_invalid
.3a6d35	e8		inx		                INX
.3a6d36	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.3a6d39	d0 f4		bne $3a6d2f	                BNE loop
.3a6d3b	28		plp		ret_valid       PLP
.3a6d3c	38		sec		                SEC
.3a6d3d	fa		plx		                PLX
.3a6d3e	6b		rtl		                RTL
.3a6d3f	28		plp		is_invalid      PLP
.3a6d40	18		clc		                CLC
.3a6d41	fa		plx		                PLX
.3a6d42	6b		rtl		                RTL
>3a6d43	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>3a6d4b	3e 3f 5c 5b 5d 7c 22
.3a6d52					S_RENAME
.3a6d52	08		php		                PHP
.3a6d53	08		php		            PHP
.3a6d54	c2 20		rep #$20	            REP #$20
.3a6d56	48		pha		            PHA
.3a6d57	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6d5a	5b		tcd		            TCD
.3a6d5b	68		pla		            PLA
.3a6d5c	28		plp		            PLP
.3a6d5d	c2 30		rep #$30	            REP #$30
.3a6d5f	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6d62	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6d65	20 2f 6c	jsr $3a6c2f	            JSR COPY2PATHBUF
.3a6d68	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.3a6d6c	b0 22		bcs $3a6d90	                BCS get_new_name            ; If ok: get the new name
.3a6d6e	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6d71	08		php		            PHP
.3a6d72	c2 20		rep #$20	            REP #$20
.3a6d74	48		pha		            PHA
.3a6d75	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6d78	5b		tcd		            TCD
.3a6d79	68		pla		            PLA
.3a6d7a	28		plp		            PLP
.3a6d7b	e2 20		sep #$20	            SEP #$20
.3a6d7d	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.3a6d7f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6d83	c2 20		rep #$20	            REP #$20
.3a6d85	29 ff 00	and #$00ff	            AND #$00FF
.3a6d88	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6d8b	e2 20		sep #$20	            SEP #$20
.3a6d8d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6d90					get_new_name
.3a6d90	e2 20		sep #$20	            SEP #$20
.3a6d92	a9 2c		lda #$2c	                LDA #','
.3a6d94	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a6d97	c2 20		rep #$20	            REP #$20
.3a6d99	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6d9c	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6d9f	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.3a6da2	85 08		sta $0808	                STA INDEX
.3a6da4	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.3a6da7	85 0a		sta $080a	                STA INDEX+2
.3a6da9	e2 20		sep #$20	            SEP #$20
.3a6dab	a2 00 00	ldx #$0000	                LDX #0
.3a6dae	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.3a6db0	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.3a6db2	e8		inx		                INX
.3a6db3	e0 0b 00	cpx #$000b	                CPX #11
.3a6db6	d0 f8		bne $3a6db0	                BNE blank_loop
.3a6db8	a2 00 00	ldx #$0000	                LDX #0
.3a6dbb	a0 00 00	ldy #$0000	                LDY #0
.3a6dbe	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.3a6dc0	f0 76		beq $3a6e38	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6dc2	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6dc4	f0 39		beq $3a6dff	                BEQ skip_dot                ; Yes: move on to the extension characters
.3a6dc6	22 18 6d 3a	jsl $3a6d18	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6dca	b0 1f		bcs $3a6deb	                BCS save_nm_char
.3a6dcc	08		php		            PHP
.3a6dcd	c2 20		rep #$20	            REP #$20
.3a6dcf	48		pha		            PHA
.3a6dd0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6dd3	5b		tcd		            TCD
.3a6dd4	68		pla		            PLA
.3a6dd5	28		plp		            PLP
.3a6dd6	e2 20		sep #$20	            SEP #$20
.3a6dd8	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6dda	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6dde	c2 20		rep #$20	            REP #$20
.3a6de0	29 ff 00	and #$00ff	            AND #$00FF
.3a6de3	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6de6	e2 20		sep #$20	            SEP #$20
.3a6de8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6deb	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.3a6ded	c8		iny		                INY
.3a6dee	e8		inx		                INX
.3a6def	c0 08 00	cpy #$0008	                CPY #8
.3a6df2	d0 ca		bne $3a6dbe	                BNE name_loop
.3a6df4	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.3a6df6	f0 40		beq $3a6e38	                BEQ copy_short_name         ; If null, we're done with the short name
.3a6df8	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6dfa	f0 03		beq $3a6dff	                BEQ skip_dot                ; Yes: skip over it
.3a6dfc	c8		iny		                INY                         ; No: try again with the the next character
.3a6dfd	80 f5		bra $3a6df4	                BRA eat_name
.3a6dff	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.3a6e00	a2 08 00	ldx #$0008	do_ext          LDX #8
.3a6e03	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.3a6e05	f0 31		beq $3a6e38	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6e07	22 18 6d 3a	jsl $3a6d18	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6e0b	b0 22		bcs $3a6e2f	                BCS save_ext_char
.3a6e0d	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6e10	08		php		            PHP
.3a6e11	c2 20		rep #$20	            REP #$20
.3a6e13	48		pha		            PHA
.3a6e14	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e17	5b		tcd		            TCD
.3a6e18	68		pla		            PLA
.3a6e19	28		plp		            PLP
.3a6e1a	e2 20		sep #$20	            SEP #$20
.3a6e1c	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6e1e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e22	c2 20		rep #$20	            REP #$20
.3a6e24	29 ff 00	and #$00ff	            AND #$00FF
.3a6e27	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6e2a	e2 20		sep #$20	            SEP #$20
.3a6e2c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6e2f	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.3a6e31	c8		iny		                INY
.3a6e32	e8		inx		                INX
.3a6e33	c0 0c 00	cpy #$000c	                CPY #12
.3a6e36	d0 cb		bne $3a6e03	                BNE ext_loop
.3a6e38	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.3a6e3b	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.3a6e3e	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.3a6e40	97 08		sta [$0808],y	                STA [INDEX],Y
.3a6e42	e8		inx		                INX
.3a6e43	c8		iny		                INY
.3a6e44	c0 0b 00	cpy #$000b	                CPY #11
.3a6e47	d0 f5		bne $3a6e3e	                BNE copy_loop
.3a6e49	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.3a6e4d	b0 22		bcs $3a6e71	                BCS done
.3a6e4f	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6e52	08		php		            PHP
.3a6e53	c2 20		rep #$20	            REP #$20
.3a6e55	48		pha		            PHA
.3a6e56	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e59	5b		tcd		            TCD
.3a6e5a	68		pla		            PLA
.3a6e5b	28		plp		            PLP
.3a6e5c	e2 20		sep #$20	            SEP #$20
.3a6e5e	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.3a6e60	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e64	c2 20		rep #$20	            REP #$20
.3a6e66	29 ff 00	and #$00ff	            AND #$00FF
.3a6e69	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6e6c	e2 20		sep #$20	            SEP #$20
.3a6e6e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6e71					done
.3a6e71	20 3d 6a	jsr $3a6a3d	            JSR SET_DOSSTAT
.3a6e74	28		plp		                PLP
.3a6e75	60		rts		            RTS
.3a6e76					S_COPY
.3a6e76	08		php		                PHP
.3a6e77	08		php		            PHP
.3a6e78	c2 20		rep #$20	            REP #$20
.3a6e7a	48		pha		            PHA
.3a6e7b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6e7e	5b		tcd		            TCD
.3a6e7f	68		pla		            PLA
.3a6e80	28		plp		            PLP
.3a6e81	c2 30		rep #$30	            REP #$30
.3a6e83	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6e86	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6e89	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6e8b	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.3a6e8f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6e91	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.3a6e95	e2 20		sep #$20	            SEP #$20
.3a6e97	a9 2c		lda #$2c	                LDA #','
.3a6e99	20 79 21	jsr $3a2179	            JSR EXPECT_TOK
.3a6e9c	c2 20		rep #$20	            REP #$20
.3a6e9e	20 5b 1c	jsr $3a1c5b	            JSR EVALEXPR
.3a6ea1	20 37 06	jsr $3a0637	            JSR ASS_ARG1_STR
.3a6ea4	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6ea6	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.3a6eaa	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6eac	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.3a6eb0	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.3a6eb4	b0 1f		bcs $3a6ed5	                BCS done
.3a6eb6	08		php		            PHP
.3a6eb7	c2 20		rep #$20	            REP #$20
.3a6eb9	48		pha		            PHA
.3a6eba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ebd	5b		tcd		            TCD
.3a6ebe	68		pla		            PLA
.3a6ebf	28		plp		            PLP
.3a6ec0	e2 20		sep #$20	            SEP #$20
.3a6ec2	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.3a6ec4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6ec8	c2 20		rep #$20	            REP #$20
.3a6eca	29 ff 00	and #$00ff	            AND #$00FF
.3a6ecd	20 ad 1d	jsr $3a1dad	            JSR SET_ERRERL
.3a6ed0	e2 20		sep #$20	            SEP #$20
.3a6ed2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6ed5	28		plp		done            PLP
.3a6ed6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.3a6ed7	5c 94 88 3a	jmp $3a8894	MRETURN         JML IMRETURN
.3a6edb	5c e5 86 3a	jmp $3a86e5	MPARSE          JML IMPARSE
.3a6edf	5c 95 88 3a	jmp $3a8895	MPARSE1         JML IMPARSE1
.3a6ee3	5c 11 78 3a	jmp $3a7811	MEXECUTE        JML IMEXECUTE
.3a6ee7	5c 6e 78 3a	jmp $3a786e	MASSEMBLE       JML IMASSEMBLE
.3a6eeb	5c a1 77 3a	jmp $3a77a1	MRMODIFY        JML IMRMODIFY
.3a6eef	5c 27 77 3a	jmp $3a7727	MCOMPARE        JML IMCOMPARE
.3a6ef3	5c a4 7c 3a	jmp $3a7ca4	MDISASSEMBLE    JML IMDISASSEMBLE
.3a6ef7	5c 92 73 3a	jmp $3a7392	MFILL           JML IMFILL
.3a6efb	5c bf 76 3a	jmp $3a76bf	MGO             JML IMGO
.3a6eff	5c 7a 76 3a	jmp $3a767a	MJUMP           JML IMJUMP
.3a6f03	5c 04 76 3a	jmp $3a7604	MHUNT           JML IMHUNT
.3a6f07	5c a3 87 3a	jmp $3a87a3	MLOAD           JML IMLOAD
.3a6f0b	5c a0 74 3a	jmp $3a74a0	MMEMORY         JML IMMEMORY
.3a6f0f	5c f0 72 3a	jmp $3a72f0	MREGISTERS      JML IMREGISTERS
.3a6f13	5c 1e 88 3a	jmp $3a881e	MSAVE           JML IMSAVE
.3a6f17	5c ce 73 3a	jmp $3a73ce	MTRANSFER       JML IMTRANSFER
.3a6f1b	5c 97 88 3a	jmp $3a8897	MVERIFY         JML IMVERIFY
.3a6f1f	5c 90 88 3a	jmp $3a8890	MEXIT           JML IMEXIT
.3a6f23	5c bd 75 3a	jmp $3a75bd	MMODIFY         JML IMMODIFY
.3a6f27	5c 98 88 3a	jmp $3a8898	MDOS            JML IMDOS
.3a6f2b	18		clc		IMONITOR        CLC                 ; clear the carry flag
.3a6f2c	fb		xce		                XCE                 ; move carry to emulation flags
.3a6f2d	58		cli		                CLI                 ; Re-enable interrupts
.3a6f2e	5c 32 6f 3a	jmp $3a6f32	                JML IMREADY
.3a6f32					IMREADY
.3a6f32	c2 30		rep #$30	            REP #$30
.3a6f34	22 f0 72 3a	jsl $3a72f0	                JSL IMREGISTERS
.3a6f38					ready_loop
.3a6f38	20 08 00	jsr $3a0008	            JSR READLINE
.3a6f3b	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a6f3e	8b		phb		                PHB
.3a6f3f	e2 20		sep #$20	            SEP #$20
.3a6f41	a9 00		lda #$00	                LDA #`INPUTBUF
.3a6f43	48		pha		                PHA
.3a6f44	ab		plb		                PLB
.3a6f45	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.3a6f48	20 b9 04	jsr $3a04b9	            JSR TOUPPER
.3a6f4b	ab		plb		                PLB
.3a6f4c	22 db 6e 3a	jsl $3a6edb	                JSL MPARSE          ; Parse the command
.3a6f50	22 e3 6e 3a	jsl $3a6ee3	                JSL MEXECUTE        ; And execute the parsed command
.3a6f54	80 e2		bra $3a6f38	                BRA ready_loop
.3a6f56					IMHELP
.3a6f56	08		php		                PHP
.3a6f57	8b		phb		                PHB
.3a6f58	e2 20		sep #$20	            SEP #$20
.3a6f5a	a9 3a		lda #$3a	                LDA #`help_text
.3a6f5c	48		pha		                PHA
.3a6f5d	ab		plb		                PLB
.3a6f5e	c2 10		rep #$10	            REP #$10
.3a6f60	a2 69 6f	ldx #$6f69	                LDX #<>help_text
.3a6f63	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a6f66	ab		plb		                PLB
.3a6f67	28		plp		                PLP
.3a6f68	6b		rtl		                RTL
>3a6f69	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>3a6f71	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>3a6f7e	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>3a6f86	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>3a6f94	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>3a6f9c	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>3a6fac	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>3a6fbb	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>3a6fc3	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>3a6fd3	20 6d 65 6d 6f 72 79 0d 0d
>3a6fdc	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>3a6fe4	3e 20 5b 65 6e 64 5d 0d
>3a6fec	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>3a6ff4	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>3a7004	0d
>3a7005	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>3a700d	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>3a701c	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>3a7024	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>3a7034	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>3a7042	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>3a704a	73 73 5d 0d
>3a704e	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>3a7056	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>3a7066	6f 63 61 74 69 6f 6e 0d 0d
>3a706f	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>3a7077	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>3a7087	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>3a7097	72 79 0d
>3a709a	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>3a70a2	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>3a70b2	6d 65 6d 6f 72 79 0d 0d
>3a70ba	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>3a70c2	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>3a70d2	62 79 74 65 5d 2e 2e 0d
>3a70da	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>3a70e2	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>3a70f2	6f 72 79 0d 0d
>3a70f7	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>3a70ff	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a710f	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>3a711f	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>3a7127	3e 20 5b 65 6e 64 5d 0d
>3a712f	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>3a7137	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>3a7147	72 79 0d 0d
>3a714b	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>3a7153	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>3a7163	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>3a7173	0d
>3a7174	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>3a717c	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>3a718c	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>3a719c	44 49 5a 43 3e 0d
>3a71a2	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>3a71aa	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>3a71ba	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>3a71ca	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>3a71d2	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a71e2	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>3a71f2	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>3a71fa	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>3a720a	74 69 6f 6e 3e 0d
>3a7210	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>3a7218	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>3a7228	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a7236	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>3a723e	0d
>3a723f	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>3a7247	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>3a7257	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>3a7267	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>3a7274	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>3a727c	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>3a7289	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>3a7291	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>3a72a1	2e 2e 0d
>3a72a4	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>3a72ac	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a72bb	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>3a72c3	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>3a72d3	20 73 63 72 65 65 6e 0d 0d 00
.3a72dd					IMWIDTH
.3a72dd	08		php		                PHP
.3a72de	08		php		            PHP
.3a72df	c2 20		rep #$20	            REP #$20
.3a72e1	48		pha		            PHA
.3a72e2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a72e5	5b		tcd		            TCD
.3a72e6	68		pla		            PLA
.3a72e7	28		plp		            PLP
.3a72e8	e2 20		sep #$20	            SEP #$20
.3a72ea	a5 0d		lda $0855	                LDA MARG1
.3a72ec	85 4e		sta $0896	                STA MCPUSTAT
.3a72ee	28		plp		                PLP
.3a72ef	6b		rtl		                RTL
.3a72f0					IMREGISTERS
.3a72f0	20 cc 01	jsr $3a01cc	            JSR ENSURETEXT
.3a72f3	08		php		            PHP
.3a72f4	e2 20		sep #$20	            SEP #$20
.3a72f6	48		pha		            PHA
.3a72f7	a9 3a		lda #$3a	            LDA #`mregisters_msg
.3a72f9	48		pha		            PHA
.3a72fa	ab		plb		            PLB
.3a72fb	68		pla		            PLA
.3a72fc	28		plp		            PLP
.3a72fd	a2 d5 88	ldx #$88d5	                LDX #<>mregisters_msg
.3a7300	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a7303	e2 20		sep #$20	            SEP #$20
.3a7305	a9 3b		lda #$3b	                LDA #';'
.3a7307	20 18 00	jsr $3a0018	            JSR PRINTC
.3a730a	a9 20		lda #$20	                LDA #' '
.3a730c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a730f	c2 30		rep #$30	            REP #$30
.3a7311	08		php		            PHP
.3a7312	e2 20		sep #$20	            SEP #$20
.3a7314	48		pha		            PHA
.3a7315	a9 00		lda #$00	            LDA #$0
.3a7317	48		pha		            PHA
.3a7318	ab		plb		            PLB
.3a7319	68		pla		            PLA
.3a731a	28		plp		            PLP
.3a731b	a0 03 00	ldy #$0003	                LDY #3
.3a731e	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.3a7321	20 3b 03	jsr $3a033b	            JSR PRINTH
.3a7324	c2 20		rep #$20	            REP #$20
.3a7326	a9 20 00	lda #$0020	                LDA #' '
.3a7329	20 18 00	jsr $3a0018	            JSR PRINTC
.3a732c	af 44 02 00	lda $000244	                LDA @lCPUA
.3a7330	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a7333	a9 20 00	lda #$0020	                LDA #' '
.3a7336	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7339	af 46 02 00	lda $000246	                LDA @lCPUX
.3a733d	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a7340	a9 20 00	lda #$0020	                LDA #' '
.3a7343	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7346	af 48 02 00	lda $000248	                LDA @lCPUY
.3a734a	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a734d	a9 20 00	lda #$0020	                LDA #' '
.3a7350	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7353	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.3a7357	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a735a	a9 20 00	lda #$0020	                LDA #' '
.3a735d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7360	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.3a7364	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a7367	a9 20 00	lda #$0020	                LDA #' '
.3a736a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a736d	a9 20 00	lda #$0020	                LDA #' '
.3a7370	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7373	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.3a7377	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a737a	a9 20 00	lda #$0020	                LDA #' '
.3a737d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7380	08		php		                PHP
.3a7381	e2 20		sep #$20	            SEP #$20
.3a7383	ad 4f 02	lda $024f	                LDA CPUFLAGS
.3a7386	22 ee 85 3a	jsl $3a85ee	                JSL MPRINTB
.3a738a	28		plp		                PLP
.3a738b	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a738e	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7391	6b		rtl		                RTL
.3a7392					IMFILL
.3a7392	08		php		                PHP                 ; Save the caller's context
.3a7393	0b		phd		                PHD
.3a7394	08		php		            PHP
.3a7395	c2 20		rep #$20	            REP #$20
.3a7397	48		pha		            PHA
.3a7398	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a739b	5b		tcd		            TCD
.3a739c	68		pla		            PLA
.3a739d	28		plp		            PLP
.3a739e					do_copy
.3a739e	e2 20		sep #$20	            SEP #$20
.3a73a0	a5 15		lda $085d	                LDA MARG3
.3a73a2	87 0d		sta [$0855]	                STA [MARG1]
.3a73a4	e2 20		sep #$20	            SEP #$20
.3a73a6	a5 0f		lda $0857	                LDA MARG1+2
.3a73a8	c5 13		cmp $085b	                CMP MARG2+2
.3a73aa	d0 0e		bne $3a73ba	                BNE go_next         ; No: we haven't reached end address yet
.3a73ac	c2 20		rep #$20	            REP #$20
.3a73ae	a5 0d		lda $0855	                LDA MARG1
.3a73b0	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.3a73b2	d0 06		bne $3a73ba	                BNE go_next         ; No: we haven't reached end address yet
.3a73b4	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a73b7	2b		pld		                PLD                 ; Restore the caller's context
.3a73b8	28		plp		                PLP
.3a73b9	6b		rtl		                RTL
.3a73ba					go_next
.3a73ba	c2 20		rep #$20	            REP #$20
.3a73bc	18		clc		                CLC
.3a73bd	a5 0d		lda $0855	                LDA MARG1
.3a73bf	69 01 00	adc #$0001	                ADC #1
.3a73c2	85 0d		sta $0855	                STA MARG1
.3a73c4	e2 20		sep #$20	            SEP #$20
.3a73c6	a5 0e		lda $0856	                LDA MARG1+1
.3a73c8	69 00		adc #$00	                ADC #0
.3a73ca	85 0e		sta $0856	                STA MARG1+1
.3a73cc	80 d0		bra $3a739e	                BRA do_copy
.3a73ce					IMTRANSFER
.3a73ce	08		php		                PHP
.3a73cf	0b		phd		                PHD
.3a73d0	08		php		            PHP
.3a73d1	c2 20		rep #$20	            REP #$20
.3a73d3	48		pha		            PHA
.3a73d4	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a73d7	5b		tcd		            TCD
.3a73d8	68		pla		            PLA
.3a73d9	28		plp		            PLP
.3a73da	e2 20		sep #$20	            SEP #$20
.3a73dc	a5 0f		lda $0857	                LDA MARG1+2
.3a73de	c5 17		cmp $085f	                CMP MARG3+2
.3a73e0	90 45		bcc $3a7427	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a73e2	c2 20		rep #$20	            REP #$20
.3a73e4	a5 0d		lda $0855	                LDA MARG1
.3a73e6	c5 15		cmp $085d	                CMP MARG3
.3a73e8	90 3d		bcc $3a7427	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a73ea					copy_byte_down
.3a73ea	e2 20		sep #$20	            SEP #$20
.3a73ec	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.3a73ee	87 15		sta [$085d]	                STA [MARG3]
.3a73f0	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.3a73f2	c5 13		cmp $085b	                CMP MARG2+2
.3a73f4	d0 0b		bne $3a7401	                BNE inc_pointers    ; No: we're not done yet
.3a73f6	c2 20		rep #$20	            REP #$20
.3a73f8	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.3a73fa	c5 11		cmp $0859	                CMP MARG2
.3a73fc	d0 03		bne $3a7401	                BNE inc_pointers    ; No: we're not done yet
.3a73fe	4c 85 74	jmp $3a7485	                JMP done            ; Yes: we've copied the last byte, exit
.3a7401					inc_pointers
.3a7401	c2 20		rep #$20	            REP #$20
.3a7403	18		clc		                CLC
.3a7404	a5 0d		lda $0855	                LDA MARG1
.3a7406	69 01 00	adc #$0001	                ADC #1
.3a7409	85 0d		sta $0855	                STA MARG1
.3a740b	e2 20		sep #$20	            SEP #$20
.3a740d	a5 0e		lda $0856	                LDA MARG1+1
.3a740f	69 00		adc #$00	                ADC #0
.3a7411	85 0e		sta $0856	                STA MARG1+1
.3a7413	c2 20		rep #$20	            REP #$20
.3a7415	18		clc		                CLC
.3a7416	a5 15		lda $085d	                LDA MARG3
.3a7418	69 01 00	adc #$0001	                ADC #1
.3a741b	85 15		sta $085d	                STA MARG3
.3a741d	e2 20		sep #$20	            SEP #$20
.3a741f	a5 16		lda $085e	                LDA MARG3+1
.3a7421	69 00		adc #$00	                ADC #0
.3a7423	85 16		sta $085e	                STA MARG3+1
.3a7425	80 c3		bra $3a73ea	                BRA copy_byte_down  ; And copy that next byte over
.3a7427					copy_up
.3a7427	c2 20		rep #$20	            REP #$20
.3a7429	38		sec		                SEC
.3a742a	a5 11		lda $0859	                LDA MARG2
.3a742c	e5 0d		sbc $0855	                SBC MARG1
.3a742e	85 19		sta $0861	                STA MARG4
.3a7430	e2 20		sep #$20	            SEP #$20
.3a7432	a5 13		lda $085b	                LDA MARG2+2
.3a7434	e5 0f		sbc $0857	                SBC MARG1+2
.3a7436	85 1b		sta $0863	                STA MARG4+2
.3a7438	c2 20		rep #$20	            REP #$20
.3a743a	18		clc		                CLC
.3a743b	a5 19		lda $0861	                LDA MARG4
.3a743d	65 15		adc $085d	                ADC MARG3
.3a743f	85 15		sta $085d	                STA MARG3
.3a7441	e2 20		sep #$20	            SEP #$20
.3a7443	a5 1b		lda $0863	                LDA MARG4+2
.3a7445	65 17		adc $085f	                ADC MARG3+2
.3a7447	85 17		sta $085f	                STA MARG3+2
.3a7449					copy_byte_up
.3a7449	e2 20		sep #$20	            SEP #$20
.3a744b	a7 11		lda [$0859]	                LDA [MARG2]
.3a744d	87 15		sta [$085d]	                STA [MARG3]
.3a744f	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.3a7451	c5 0f		cmp $0857	                CMP MARG1+2
.3a7453	d0 0a		bne $3a745f	                BNE dec_pointers    ; No: we're not done yet
.3a7455	c2 20		rep #$20	            REP #$20
.3a7457	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.3a7459	c5 0d		cmp $0855	                CMP MARG1
.3a745b	d0 02		bne $3a745f	                BNE dec_pointers    ; No: we're not done yet
.3a745d	80 26		bra $3a7485	                BRA done            ; Yes: we've copied the last byte, exit
.3a745f					dec_pointers
.3a745f	c2 20		rep #$20	            REP #$20
.3a7461	38		sec		                SEC
.3a7462	a5 11		lda $0859	                LDA MARG2
.3a7464	e9 01 00	sbc #$0001	                SBC #1
.3a7467	85 11		sta $0859	                STA MARG2
.3a7469	e2 20		sep #$20	            SEP #$20
.3a746b	a5 12		lda $085a	                LDA MARG2+1
.3a746d	e9 00		sbc #$00	                SBC #0
.3a746f	85 12		sta $085a	                STA MARG2+1
.3a7471	c2 20		rep #$20	            REP #$20
.3a7473	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.3a7474	a5 15		lda $085d	                LDA MARG3
.3a7476	e9 01 00	sbc #$0001	                SBC #1
.3a7479	85 15		sta $085d	                STA MARG3
.3a747b	e2 20		sep #$20	            SEP #$20
.3a747d	a5 16		lda $085e	                LDA MARG3+1
.3a747f	e9 00		sbc #$00	                SBC #0
.3a7481	85 16		sta $085e	                STA MARG3+1
.3a7483	80 c4		bra $3a7449	                BRA copy_byte_up    ; And copy that next byte
.3a7485					done
.3a7485	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7488	2b		pld		                PLD
.3a7489	28		plp		                PLP
.3a748a	6b		rtl		                RTL
.3a748b					IS_PRINTABLE
.3a748b	08		php		                PHP
.3a748c	e2 20		sep #$20	            SEP #$20
.3a748e	c9 21		cmp #$21	                CMP #33
.3a7490	90 0b		bcc $3a749d	                BLT not_printable   ; 0 .. 31 are not printable
.3a7492	c9 7f		cmp #$7f	                CMP #127
.3a7494	90 04		bcc $3a749a	                BLT printable       ; 32 .. 126 are printable
.3a7496	c9 a0		cmp #$a0	                CMP #160
.3a7498	90 03		bcc $3a749d	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.3a749a	28		plp		printable       PLP
.3a749b	38		sec		                SEC
.3a749c	6b		rtl		                RTL
.3a749d	28		plp		not_printable   PLP
.3a749e	18		clc		                CLC
.3a749f	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.3a74a0					IMMEMORY
.3a74a0	08		php		                PHP
.3a74a1	8b		phb		                PHB
.3a74a2	0b		phd		                PHD
.3a74a3	08		php		            PHP
.3a74a4	c2 20		rep #$20	            REP #$20
.3a74a6	48		pha		            PHA
.3a74a7	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a74aa	5b		tcd		            TCD
.3a74ab	68		pla		            PLA
.3a74ac	28		plp		            PLP
.3a74ad	e2 20		sep #$20	            SEP #$20
.3a74af	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.3a74b1	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.3a74b5	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a74b7	c9 02		cmp #$02	                CMP #2
.3a74b9	b0 16		bcs $3a74d1	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a74bb	c9 01		cmp #$01	                CMP #1
.3a74bd	90 20		bcc $3a74df	                BLT no_args         ; No arguments passed? Use defaults
.3a74bf	c2 20		rep #$20	            REP #$20
.3a74c1	18		clc		                CLC
.3a74c2	a5 0d		lda $0855	                LDA MARG1
.3a74c4	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a74c7	85 11		sta $0859	                STA MARG2
.3a74c9	e2 20		sep #$20	            SEP #$20
.3a74cb	a5 0f		lda $0857	                LDA MARG1+2
.3a74cd	69 00		adc #$00	                ADC #0
.3a74cf	85 13		sta $085b	                STA MARG2+2
.3a74d1					set_cursor
.3a74d1	c2 20		rep #$20	            REP #$20
.3a74d3	a5 0d		lda $0855	                LDA MARG1
.3a74d5	85 32		sta $087a	                STA MCURSOR
.3a74d7	e2 20		sep #$20	            SEP #$20
.3a74d9	a5 0f		lda $0857	                LDA MARG1+2
.3a74db	85 34		sta $087c	                STA MCURSOR+2
.3a74dd	80 12		bra $3a74f1	                BRA dump_line
.3a74df					no_args
.3a74df	c2 20		rep #$20	            REP #$20
.3a74e1	18		clc		                CLC
.3a74e2	a5 32		lda $087a	                LDA MCURSOR
.3a74e4	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a74e7	85 11		sta $0859	                STA MARG2
.3a74e9	e2 20		sep #$20	            SEP #$20
.3a74eb	a5 34		lda $087c	                LDA MCURSOR+2
.3a74ed	69 00		adc #$00	                ADC #0
.3a74ef	85 13		sta $085b	                STA MARG2+2
.3a74f1					dump_line
.3a74f1	e2 20		sep #$20	            SEP #$20
.3a74f3	a0 00 00	ldy #$0000	                LDY #0
.3a74f6	c2 20		rep #$20	            REP #$20
.3a74f8	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.3a74fa	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.3a74fc	e2 20		sep #$20	            SEP #$20
.3a74fe	a5 34		lda $087c	                LDA MCURSOR+2
.3a7500	85 1b		sta $0863	                STA MARG4+2
.3a7502	e2 20		sep #$20	            SEP #$20
.3a7504	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.3a7506	22 8b 74 3a	jsl $3a748b	                JSL IS_PRINTABLE        ; Is it printable?
.3a750a	b0 02		bcs $3a750e	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.3a750c	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.3a750e	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.3a7511	c2 20		rep #$20	            REP #$20
.3a7513	18		clc		                CLC
.3a7514	a5 19		lda $0861	                LDA MARG4
.3a7516	69 01 00	adc #$0001	                ADC #1
.3a7519	85 19		sta $0861	                STA MARG4
.3a751b	e2 20		sep #$20	            SEP #$20
.3a751d	a5 1b		lda $0863	                LDA MARG4+2
.3a751f	69 00		adc #$00	                ADC #0
.3a7521	85 1b		sta $0863	                STA MARG4+2
.3a7523	c8		iny		                INY
.3a7524	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.3a7527	90 db		bcc $3a7504	                BLT copy_loop
.3a7529	a9 00		lda #$00	                LDA #0
.3a752b	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.3a752e	a9 3e		lda #$3e	                LDA #'>'
.3a7530	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7533	a9 20		lda #$20	                LDA #' '
.3a7535	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7538	e2 20		sep #$20	            SEP #$20
.3a753a	a5 34		lda $087c	                LDA MCURSOR+2
.3a753c	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a753f	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.3a7541	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7544	c2 20		rep #$20	            REP #$20
.3a7546	a5 32		lda $087a	                LDA MCURSOR
.3a7548	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a754b	c2 20		rep #$20	            REP #$20
.3a754d	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.3a7550	85 47		sta $088f	                STA MCOUNT
.3a7552					prhex_loop
.3a7552	e2 20		sep #$20	            SEP #$20
.3a7554	a9 20		lda #$20	                LDA #' '
.3a7556	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7559	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a755b	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a755e	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.3a7562					check_line
.3a7562	e2 20		sep #$20	            SEP #$20
.3a7564	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.3a7566	d0 ea		bne $3a7552	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.3a7568	a9 20		lda #$20	                LDA #' '
.3a756a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a756d	a9 20		lda #$20	                LDA #' '
.3a756f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7572	08		php		            PHP
.3a7573	e2 20		sep #$20	            SEP #$20
.3a7575	48		pha		            PHA
.3a7576	a9 00		lda #$00	            LDA #`MLINEBUF
.3a7578	48		pha		            PHA
.3a7579	ab		plb		            PLB
.3a757a	68		pla		            PLA
.3a757b	28		plp		            PLP
.3a757c	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.3a757f	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a7582	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7585	20 42 03	jsr $3a0342	            JSR PAGINATE
.3a7588	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a758a	c5 13		cmp $085b	                CMP MARG2+2
.3a758c	90 0f		bcc $3a759d	                BLT continue            ; No: continue
.3a758e	c2 20		rep #$20	            REP #$20
.3a7590	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7592	c5 11		cmp $0859	                CMP MARG2
.3a7594	90 07		bcc $3a759d	                BLT continue            ; Nope... keep going
.3a7596					done
.3a7596	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7599	2b		pld		                PLD
.3a759a	ab		plb		                PLB
.3a759b	28		plp		                PLP
.3a759c	6b		rtl		                RTL
.3a759d	4c f1 74	jmp $3a74f1	continue        JMP dump_line
.3a75a0					M_COPY_ARGB
.3a75a0	08		php		                PHP
.3a75a1	8d 92 08	sta $0892	                STA MTEMP
.3a75a4	e2 20		sep #$20	            SEP #$20
.3a75a6	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.3a75a9	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.3a75ac	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.3a75af	f0 0a		beq $3a75bb	                BEQ done        ; If it's 0, we're done
.3a75b1	c8		iny		                INY             ; Point to the next destination byte
.3a75b2	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.3a75b3	e8		inx		                INX
.3a75b4	e8		inx		                INX
.3a75b5	e8		inx		                INX
.3a75b6	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.3a75b9	80 eb		bra $3a75a6	                BRA loop
.3a75bb	28		plp		done            PLP
.3a75bc	6b		rtl		                RTL
.3a75bd					IMMODIFY
.3a75bd	08		php		                PHP
.3a75be	0b		phd		                PHD
.3a75bf	8b		phb		                PHB
.3a75c0	08		php		            PHP
.3a75c1	c2 20		rep #$20	            REP #$20
.3a75c3	48		pha		            PHA
.3a75c4	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a75c7	5b		tcd		            TCD
.3a75c8	68		pla		            PLA
.3a75c9	28		plp		            PLP
.3a75ca	08		php		            PHP
.3a75cb	e2 20		sep #$20	            SEP #$20
.3a75cd	48		pha		            PHA
.3a75ce	a9 00		lda #$00	            LDA #0
.3a75d0	48		pha		            PHA
.3a75d1	ab		plb		            PLB
.3a75d2	68		pla		            PLA
.3a75d3	28		plp		            PLP
.3a75d4	c2 30		rep #$30	            REP #$30
.3a75d6	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.3a75d8	85 32		sta $087a	                STA MCURSOR
.3a75da	a5 0f		lda $0857	                LDA MARG1+2
.3a75dc	85 34		sta $087c	                STA MCURSOR+2
.3a75de	e2 20		sep #$20	            SEP #$20
.3a75e0	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a75e2	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.3a75e3	85 47		sta $088f	                STA MCOUNT
.3a75e5	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.3a75e8	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.3a75eb	22 a0 75 3a	jsl $3a75a0	                JSL M_COPY_ARGB
.3a75ef	a0 00 00	ldy #$0000	                LDY #0
.3a75f2	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.3a75f5	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.3a75f7	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR    ; Advance the cursor
.3a75fb	c8		iny		                INY                 ; Go to the next buffered byte
.3a75fc	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.3a75fe	d0 f2		bne $3a75f2	                BNE loop            ; No: continue writing
.3a7600	ab		plb		                PLB
.3a7601	2b		pld		                PLD
.3a7602	28		plp		                PLP
.3a7603	6b		rtl		                RTL
.3a7604					IMHUNT
.3a7604	08		php		                PHP
.3a7605	0b		phd		                PHD
.3a7606	8b		phb		                PHB
.3a7607	08		php		            PHP
.3a7608	c2 20		rep #$20	            REP #$20
.3a760a	48		pha		            PHA
.3a760b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a760e	5b		tcd		            TCD
.3a760f	68		pla		            PLA
.3a7610	28		plp		            PLP
.3a7611	08		php		            PHP
.3a7612	e2 20		sep #$20	            SEP #$20
.3a7614	48		pha		            PHA
.3a7615	a9 00		lda #$00	            LDA #0
.3a7617	48		pha		            PHA
.3a7618	ab		plb		            PLB
.3a7619	68		pla		            PLA
.3a761a	28		plp		            PLP
.3a761b	e2 20		sep #$20	            SEP #$20
.3a761d	c2 10		rep #$10	            REP #$10
.3a761f	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a7621	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.3a7622	3a		dec a		                DEC A
.3a7623	85 47		sta $088f	                STA MCOUNT
.3a7625	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.3a7628	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.3a762b	22 a0 75 3a	jsl $3a75a0	                JSL M_COPY_ARGB
.3a762f	c2 20		rep #$20	            REP #$20
.3a7631	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.3a7633	85 32		sta $087a	                STA MCURSOR
.3a7635	a5 0f		lda $0857	                LDA MARG1+2
.3a7637	85 34		sta $087c	                STA MCURSOR+2
.3a7639					outer_loop
.3a7639	c2 20		rep #$20	            REP #$20
.3a763b	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.3a763d	c5 13		cmp $085b	                CMP MARG2+2
.3a763f	d0 06		bne $3a7647	                BNE not_done
.3a7641	a5 32		lda $087a	                LDA MCURSOR
.3a7643	c5 11		cmp $0859	                CMP MARG2
.3a7645	f0 2c		beq $3a7673	                BEQ done            ; MCURSOR = MARG2: we're done
.3a7647					not_done
.3a7647	e2 20		sep #$20	            SEP #$20
.3a7649	a0 00 00	ldy #$0000	                LDY #0
.3a764c	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.3a764e	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.3a7651	d0 1a		bne $3a766d	                BNE advance         ; If not equal, we need to move on
.3a7653	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.3a7654	c4 47		cpy $088f	                CPY MCOUNT
.3a7656	d0 f4		bne $3a764c	                BNE cmp_loop        ; No: check more
.3a7658	c2 20		rep #$20	            REP #$20
.3a765a	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.3a765c	85 4a		sta $0892	                STA MTEMP
.3a765e	a5 34		lda $087c	                LDA MCURSOR+2
.3a7660	85 4c		sta $0894	                STA MTEMP+2
.3a7662	22 77 80 3a	jsl $3a8077	                JSL M_PR_ADDR
.3a7666	e2 20		sep #$20	            SEP #$20
.3a7668	a9 20		lda #$20	                LDA #' '
.3a766a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a766d	22 cd 85 3a	jsl $3a85cd	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.3a7671	80 c6		bra $3a7639	                BRA outer_loop      ; And try to compare that to the pattern
.3a7673					done
.3a7673	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7676	ab		plb		                PLB
.3a7677	2b		pld		                PLD
.3a7678	28		plp		                PLP
.3a7679	6b		rtl		                RTL
.3a767a					IMJUMP
.3a767a	08		php		            PHP
.3a767b	c2 20		rep #$20	            REP #$20
.3a767d	48		pha		            PHA
.3a767e	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7681	5b		tcd		            TCD
.3a7682	68		pla		            PLA
.3a7683	28		plp		            PLP
.3a7684	e2 20		sep #$20	            SEP #$20
.3a7686	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a7688	f0 0e		beq $3a7698	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a768a	c2 30		rep #$30	            REP #$30
.3a768c	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a768e	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a7692	a5 0f		lda $0857	                LDA MARG1+2
.3a7694	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a7698	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.3a769c	aa		tax		                TAX
.3a769d	af 48 02 00	lda $000248	                LDA @lCPUY
.3a76a1	a8		tay		                TAY
.3a76a2	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a76a6	1b		tcs		                TCS
.3a76a7	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a76ab	5b		tcd		                TCD
.3a76ac	e2 20		sep #$20	            SEP #$20
.3a76ae	a9 3a		lda #$3a	                LDA #`MJUMPSTART
.3a76b0	48		pha		                PHA
.3a76b1	a9 76		lda #$76	                LDA #>MJUMPSTART
.3a76b3	48		pha		                PHA
.3a76b4	a9 ba		lda #$ba	                LDA #<MJUMPSTART
.3a76b6	48		pha		                PHA
.3a76b7	4c f1 76	jmp $3a76f1	                JMP MGOSTACK        ; And push remaining registers and restart execution
.3a76ba	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.3a76bb	5c 04 00 3a	jmp $3a0004	                JML MONITOR
.3a76bf					IMGO
.3a76bf	08		php		            PHP
.3a76c0	c2 20		rep #$20	            REP #$20
.3a76c2	48		pha		            PHA
.3a76c3	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a76c6	5b		tcd		            TCD
.3a76c7	68		pla		            PLA
.3a76c8	28		plp		            PLP
.3a76c9	e2 20		sep #$20	            SEP #$20
.3a76cb	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a76cd	f0 c9		beq $3a7698	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a76cf	c2 30		rep #$30	            REP #$30
.3a76d1	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a76d3	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a76d7	a5 0f		lda $0857	                LDA MARG1+2
.3a76d9	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a76dd	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.3a76e1	aa		tax		                TAX
.3a76e2	af 48 02 00	lda $000248	                LDA @lCPUY
.3a76e6	a8		tay		                TAY
.3a76e7	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a76eb	1b		tcs		                TCS
.3a76ec	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a76f0	5b		tcd		                TCD
.3a76f1					MGOSTACK
.3a76f1	e2 20		sep #$20	            SEP #$20
.3a76f3	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.3a76f7	48		pha		                PHA
.3a76f8	ab		plb		                PLB
.3a76f9	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.3a76fb	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.3a76ff	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.3a7703	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.3a7707	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.3a770b	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.3a770f	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.3a7713	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.3a7717	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.3a771b	48		pha		                PHA
.3a771c	c2 20		rep #$20	            REP #$20
.3a771e	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.3a7722	28		plp		                PLP                 ; And the status register
.3a7723	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.3a7727					IMCOMPARE
.3a7727	08		php		                PHP
.3a7728	0b		phd		                PHD
.3a7729	8b		phb		                PHB
.3a772a	08		php		            PHP
.3a772b	e2 20		sep #$20	            SEP #$20
.3a772d	48		pha		            PHA
.3a772e	a9 3a		lda #$3a	            LDA #`MERRARGS
.3a7730	48		pha		            PHA
.3a7731	ab		plb		            PLB
.3a7732	68		pla		            PLA
.3a7733	28		plp		            PLP
.3a7734	08		php		            PHP
.3a7735	c2 20		rep #$20	            REP #$20
.3a7737	48		pha		            PHA
.3a7738	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a773b	5b		tcd		            TCD
.3a773c	68		pla		            PLA
.3a773d	28		plp		            PLP
.3a773e	c2 10		rep #$10	            REP #$10
.3a7740	e2 20		sep #$20	            SEP #$20
.3a7742	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.3a7744	c9 02		cmp #$02	                CMP #2
.3a7746	f0 0c		beq $3a7754	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.3a7748	c9 03		cmp #$03	                CMP #3
.3a774a	d0 11		bne $3a775d	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.3a774c	c2 20		rep #$20	            REP #$20
.3a774e	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.3a7750	85 47		sta $088f	                STA MCOUNT
.3a7752	80 11		bra $3a7765	                BRA compare
.3a7754					default_len
.3a7754	c2 20		rep #$20	            REP #$20
.3a7756	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.3a7759	85 47		sta $088f	                STA MCOUNT
.3a775b	80 08		bra $3a7765	                BRA compare
.3a775d	a2 99 88	ldx #$8899	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.3a7760	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a7763	80 35		bra $3a779a	                BRA done
.3a7765	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.3a7767	85 4a		sta $0892	                STA MTEMP
.3a7769	a5 0f		lda $0857	                LDA MARG1+2
.3a776b	85 4c		sta $0894	                STA MTEMP+2
.3a776d	a0 00 00	ldy #$0000	                LDY #0
.3a7770					loop
.3a7770	e2 20		sep #$20	            SEP #$20
.3a7772	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.3a7774	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.3a7776	f0 09		beq $3a7781	                BEQ continue                ; If they're the same, keep going
.3a7778	22 77 80 3a	jsl $3a8077	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.3a777c	a9 20		lda #$20	                LDA #' '
.3a777e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7781					continue
.3a7781	c2 20		rep #$20	            REP #$20
.3a7783	18		clc		                CLC                         ; Either way, increment MTEMP
.3a7784	a5 4a		lda $0892	                LDA MTEMP
.3a7786	69 01 00	adc #$0001	                ADC #1
.3a7789	85 4a		sta $0892	                STA MTEMP
.3a778b	a5 4c		lda $0894	                LDA MTEMP+2
.3a778d	69 00 00	adc #$0000	                ADC #0
.3a7790	85 4c		sta $0894	                STA MTEMP+2
.3a7792	c8		iny		                INY                         ; Increment Y
.3a7793	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.3a7795	d0 d9		bne $3a7770	                BNE loop
.3a7797	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a779a					done
.3a779a	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a779d	ab		plb		                PLB
.3a779e	2b		pld		                PLD
.3a779f	28		plp		                PLP
.3a77a0	6b		rtl		                RTL
.3a77a1					IMRMODIFY
.3a77a1	08		php		                PHP
.3a77a2	0b		phd		                PHD
.3a77a3	8b		phb		                PHB
.3a77a4	08		php		            PHP
.3a77a5	e2 20		sep #$20	            SEP #$20
.3a77a7	48		pha		            PHA
.3a77a8	a9 00		lda #$00	            LDA #0
.3a77aa	48		pha		            PHA
.3a77ab	ab		plb		            PLB
.3a77ac	68		pla		            PLA
.3a77ad	28		plp		            PLP
.3a77ae	08		php		            PHP
.3a77af	c2 20		rep #$20	            REP #$20
.3a77b1	48		pha		            PHA
.3a77b2	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a77b5	5b		tcd		            TCD
.3a77b6	68		pla		            PLA
.3a77b7	28		plp		            PLP
.3a77b8	e2 20		sep #$20	            SEP #$20
.3a77ba	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a77bc	f0 4f		beq $3a780d	                BEQ done            ; 0? Just quit
.3a77be	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.3a77c0	8e 40 02	stx $0240	                STX #CPUPC,B
.3a77c3	a6 0f		ldx $0857	                LDX MARG1+2
.3a77c5	8e 42 02	stx $0242	                STX #CPUPBR,B
.3a77c8	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.3a77ca	f0 41		beq $3a780d	                BEQ done            ; 1? Just quit
.3a77cc	a6 11		ldx $0859	                LDX MARG2           ; Set A
.3a77ce	8e 44 02	stx $0244	                STX #CPUA,B
.3a77d1	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.3a77d3	f0 38		beq $3a780d	                BEQ done            ; 2? Just quit
.3a77d5	a6 15		ldx $085d	                LDX MARG3           ; Set X
.3a77d7	8e 46 02	stx $0246	                STX #CPUX,B
.3a77da	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.3a77dc	f0 2f		beq $3a780d	                BEQ done            ; 3? Just quit
.3a77de	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.3a77e0	8e 48 02	stx $0248	                STX #CPUY,B
.3a77e3	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.3a77e5	f0 26		beq $3a780d	                BEQ done            ; 4? Just quit
.3a77e7	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.3a77e9	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.3a77ec	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.3a77ee	f0 1d		beq $3a780d	                BEQ done            ; 5? Just quit
.3a77f0	e2 10		sep #$10	            SEP #$10
.3a77f2	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.3a77f4	8e 4e 02	stx $024e	                STX #CPUDBR,B
.3a77f7	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.3a77f9	f0 12		beq $3a780d	                BEQ done            ; 6? Just quit
.3a77fb	c2 10		rep #$10	            REP #$10
.3a77fd	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.3a77ff	8e 4c 02	stx $024c	                STX #CPUDP,B
.3a7802	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.3a7804	f0 07		beq $3a780d	                BEQ done            ; 7? Just quit
.3a7806	e2 10		sep #$10	            SEP #$10
.3a7808	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.3a780a	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.3a780d	ab		plb		done            PLB
.3a780e	2b		pld		                PLD
.3a780f	28		plp		                PLP
.3a7810	6b		rtl		                RTL
.3a7811					IMEXECUTE
.3a7811	08		php		                PHP
.3a7812	0b		phd		                PHD
.3a7813	8b		phb		                PHB
.3a7814	08		php		            PHP
.3a7815	c2 20		rep #$20	            REP #$20
.3a7817	48		pha		            PHA
.3a7818	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a781b	5b		tcd		            TCD
.3a781c	68		pla		            PLA
.3a781d	28		plp		            PLP
.3a781e	e2 20		sep #$20	            SEP #$20
.3a7820	c2 10		rep #$10	            REP #$10
.3a7822	a2 00 00	ldx #$0000	                LDX #0
.3a7825	bf 06 89 3a	lda $3a8906,x	loop            LDA @lMCOMMANDS,X
.3a7829	f0 18		beq $3a7843	                BEQ done
.3a782b	c7 08		cmp [$0850]	                CMP [MCMD]
.3a782d	f0 03		beq $3a7832	                BEQ found
.3a782f	e8		inx		                INX
.3a7830	80 f3		bra $3a7825	                BRA loop
.3a7832					found
.3a7832	c2 20		rep #$20	            REP #$20
.3a7834	8a		txa		                TXA
.3a7835	0a		asl a		                ASL A
.3a7836	aa		tax		                TAX
.3a7837	bf 47 78 3a	lda $3a7847,x	                LDA dispatch,X
.3a783b	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.3a783f	22 6b 78 3a	jsl $3a786b	                JSL MDOCMD
.3a7843	ab		plb		done            PLB
.3a7844	2b		pld		                PLD
.3a7845	28		plp		                PLP
.3a7846	6b		rtl		                RTL
>3a7847	e7 6e				dispatch        .word <>MASSEMBLE
>3a7849	ef 6e				                .word <>MCOMPARE
>3a784b	f3 6e				                .word <>MDISASSEMBLE
>3a784d	f7 6e				                .word <>MFILL
>3a784f	fb 6e				                .word <>MGO
>3a7851	ff 6e				                .word <>MJUMP
>3a7853	03 6f				                .word <>MHUNT
>3a7855	07 6f				                .word <>MLOAD
>3a7857	0b 6f				                .word <>MMEMORY
>3a7859	0f 6f				                .word <>MREGISTERS
>3a785b	eb 6e				                .word <>MRMODIFY
>3a785d	13 6f				                .word <>MSAVE
>3a785f	17 6f				                .word <>MTRANSFER
>3a7861	1b 6f				                .word <>MVERIFY
>3a7863	dd 72				                .word <>IMWIDTH
>3a7865	1f 6f				                .word <>MEXIT
>3a7867	23 6f				                .word <>MMODIFY
>3a7869	56 6f				                .word <>IMHELP
.3a786b					MDOCMD
.3a786b	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.3a786e					IMASSEMBLE
.3a786e	08		php		                PHP
.3a786f	8b		phb		                PHB
.3a7870	0b		phd		                PHD
.3a7871	08		php		            PHP
.3a7872	c2 20		rep #$20	            REP #$20
.3a7874	48		pha		            PHA
.3a7875	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7878	5b		tcd		            TCD
.3a7879	68		pla		            PLA
.3a787a	28		plp		            PLP
.3a787b	e2 20		sep #$20	            SEP #$20
.3a787d	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.3a787f	c9 02		cmp #$02	                CMP #2
.3a7881	b0 03		bcs $3a7886	                BGE has_args            ; Yes: try to assemble the line
.3a7883	4c 14 7a	jmp $3a7a14	                JMP done                ; No: just return
.3a7886					has_args
.3a7886	c2 20		rep #$20	            REP #$20
.3a7888	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.3a788a	85 32		sta $087a	                STA MCURSOR
.3a788c	a5 0f		lda $0857	                LDA MARG1+2
.3a788e	85 34		sta $087c	                STA MCURSOR+2
.3a7890	c2 20		rep #$20	            REP #$20
.3a7892	22 16 7c 3a	jsl $3a7c16	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.3a7896	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a7899	f0 10		beq $3a78ab	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.3a789b	85 54		sta $089c	                STA MMNEMONIC
.3a789d	e2 20		sep #$20	            SEP #$20
.3a789f	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.3a78a1	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.3a78a3	f0 36		beq $3a78db	                BEQ get_operand         ; Yes: parse the operand
.3a78a5	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.3a78a7	85 4f		sta $0897	                STA MADDR_MODE
.3a78a9	80 4c		bra $3a78f7	                BRA get_opcode
.3a78ab					bad_mnemonic
.3a78ab	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a78ae	08		php		            PHP
.3a78af	e2 20		sep #$20	            SEP #$20
.3a78b1	48		pha		            PHA
.3a78b2	a9 3a		lda #$3a	            LDA #`MERRBADMNEMO
.3a78b4	48		pha		            PHA
.3a78b5	ab		plb		            PLB
.3a78b6	68		pla		            PLA
.3a78b7	28		plp		            PLP
.3a78b8	c2 10		rep #$10	            REP #$10
.3a78ba	a2 4b 7a	ldx #$7a4b	                LDX #<>MERRBADMNEMO
.3a78bd	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a78c0	4c 14 7a	jmp $3a7a14	                JMP done
.3a78c3					bad_operand
.3a78c3	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a78c6	08		php		            PHP
.3a78c7	e2 20		sep #$20	            SEP #$20
.3a78c9	48		pha		            PHA
.3a78ca	a9 3a		lda #$3a	            LDA #`MERRBADOPER
.3a78cc	48		pha		            PHA
.3a78cd	ab		plb		            PLB
.3a78ce	68		pla		            PLA
.3a78cf	28		plp		            PLP
.3a78d0	c2 10		rep #$10	            REP #$10
.3a78d2	a2 5a 7a	ldx #$7a5a	                LDX #<>MERRBADOPER
.3a78d5	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a78d8	4c 14 7a	jmp $3a7a14	                JMP done
.3a78db					get_operand
.3a78db	e2 20		sep #$20	            SEP #$20
.3a78dd	22 4c 7c 3a	jsl $3a7c4c	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.3a78e1	c9 ff		cmp #$ff	compare         CMP #$FF
.3a78e3	f0 de		beq $3a78c3	                BEQ bad_operand         ; If not found, print bad operand error message
.3a78e5	85 4f		sta $0897	                STA MADDR_MODE
.3a78e7	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.3a78e9	f0 62		beq $3a794d	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.3a78eb	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.3a78ed	f0 5e		beq $3a794d	                BEQ check_for_pcrel
.3a78ef	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.3a78f1	f0 04		beq $3a78f7	                BEQ get_opcode
.3a78f3	c9 08		cmp #$08	                CMP #ADDR_ACC
.3a78f5	f0 00		beq $3a78f7	                BEQ get_opcode
.3a78f7	22 44 7b 3a	jsl $3a7b44	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.3a78fb	b0 03		bcs $3a7900	                BCS save_opcode
.3a78fd	4c dd 79	jmp $3a79dd	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.3a7900	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.3a7902	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR        ; And point to the next byte
.3a7906	08		php		            PHP
.3a7907	e2 20		sep #$20	            SEP #$20
.3a7909	48		pha		            PHA
.3a790a	a9 00		lda #$00	            LDA #0
.3a790c	48		pha		            PHA
.3a790d	ab		plb		            PLB
.3a790e	68		pla		            PLA
.3a790f	28		plp		            PLP
.3a7910	c2 20		rep #$20	            REP #$20
.3a7912	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.3a7914	85 56		sta $089e	                STA MTEMPPTR
.3a7916	a5 34		lda $087c	                LDA MCURSOR+2
.3a7918	85 58		sta $08a0	                STA MTEMPPTR+2
.3a791a	e2 20		sep #$20	            SEP #$20
.3a791c	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.3a791e	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.3a7920	f0 6c		beq $3a798e	                BEQ compute_rel         ; Convert the address to an offset
.3a7922	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a7924	f0 68		beq $3a798e	                BEQ compute_rel
.3a7926	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.3a7928	f0 7c		beq $3a79a6	                BEQ emit_2
.3a792a	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.3a792c	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.3a792e	d0 03		bne $3a7933	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.3a7930	4c 0b 7a	jmp $3a7a0b	                JMP emit_imm
.3a7933					fixed_length
.3a7933	c2 20		rep #$20	            REP #$20
.3a7935	29 ff 00	and #$00ff	                AND #$00FF
.3a7938	aa		tax		                TAX
.3a7939	e2 20		sep #$20	            SEP #$20
.3a793b	bf 13 85 3a	lda $3a8513,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.3a793f	c9 03		cmp #$03	                CMP #$03
.3a7941	f0 57		beq $3a799a	                BEQ emit_3
.3a7943	c9 02		cmp #$02	                CMP #$02
.3a7945	f0 5f		beq $3a79a6	                BEQ emit_2
.3a7947	c9 01		cmp #$01	                CMP #$01
.3a7949	f0 67		beq $3a79b2	                BEQ emit_1
.3a794b	80 71		bra $3a79be	                BRA next_line
.3a794d					check_for_pcrel
.3a794d	c2 20		rep #$20	            REP #$20
.3a794f	a5 54		lda $089c	                LDA MMNEMONIC
.3a7951	c9 8b 81	cmp #$818b	                CMP #<>MN_BRA
.3a7954	f0 26		beq $3a797c	                BEQ is_pcrel
.3a7956	c9 ef 81	cmp #$81ef	                CMP #<>MN_BRL
.3a7959	f0 2a		beq $3a7985	                BEQ is_pcrel_long
.3a795b	c9 6f 81	cmp #$816f	                CMP #<>MN_BCC
.3a795e	f0 1c		beq $3a797c	                BEQ is_pcrel
.3a7960	c9 73 81	cmp #$8173	                CMP #<>MN_BCS
.3a7963	f0 17		beq $3a797c	                BEQ is_pcrel
.3a7965	c9 7b 81	cmp #$817b	                CMP #<>MN_BEQ
.3a7968	f0 12		beq $3a797c	                BEQ is_pcrel
.3a796a	c9 63 81	cmp #$8163	                CMP #<>MN_BMI
.3a796d	f0 0d		beq $3a797c	                BEQ is_pcrel
.3a796f	c9 77 81	cmp #$8177	                CMP #<>MN_BNE
.3a7972	f0 08		beq $3a797c	                BEQ is_pcrel
.3a7974	c9 5f 81	cmp #$815f	                CMP #<>MN_BPL
.3a7977	f0 03		beq $3a797c	                BEQ is_pcrel
.3a7979	4c f7 78	jmp $3a78f7	                JMP get_opcode
.3a797c					is_pcrel
.3a797c	e2 20		sep #$20	            SEP #$20
.3a797e	a9 12		lda #$12	                LDA #ADDR_PC_REL
.3a7980	85 4f		sta $0897	                STA MADDR_MODE
.3a7982	4c f7 78	jmp $3a78f7	                JMP get_opcode
.3a7985					is_pcrel_long
.3a7985	e2 20		sep #$20	            SEP #$20
.3a7987	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.3a7989	85 4f		sta $0897	                STA MADDR_MODE
.3a798b	4c f7 78	jmp $3a78f7	                JMP get_opcode
.3a798e	22 87 7a 3a	jsl $3a7a87	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.3a7992	90 60		bcc $3a79f4	                BCC bad_offset          ; If failed, it's a bad offset operand
.3a7994	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.3a7996	f0 0e		beq $3a79a6	                BEQ emit_2              ; Emit those two bytes
.3a7998	80 18		bra $3a79b2	                BRA emit_1              ; Otherwise emit just the one
.3a799a	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.3a799d	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a79a0	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a79a2	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a79a6	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.3a79a9	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a79ac	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a79ae	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a79b2	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.3a79b5	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a79b8	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a79ba	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a79be					next_line
.3a79be	e2 20		sep #$20	            SEP #$20
.3a79c0	a9 41		lda #$41	                LDA #'A'
.3a79c2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a79c5	a9 20		lda #$20	                LDA #' '
.3a79c7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a79ca	a6 32		ldx $087a	                LDX MCURSOR
.3a79cc	86 4a		stx $0892	                STX MTEMP
.3a79ce	a6 34		ldx $087c	                LDX MCURSOR+2
.3a79d0	86 4c		stx $0894	                STX MTEMP+2
.3a79d2	22 77 80 3a	jsl $3a8077	                JSL M_PR_ADDR
.3a79d6	a9 20		lda #$20	                LDA #' '
.3a79d8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a79db	80 37		bra $3a7a14	                BRA done
.3a79dd					bad_mode
.3a79dd	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a79e0	08		php		            PHP
.3a79e1	e2 20		sep #$20	            SEP #$20
.3a79e3	48		pha		            PHA
.3a79e4	a9 3a		lda #$3a	            LDA #`MERRBADMODE
.3a79e6	48		pha		            PHA
.3a79e7	ab		plb		            PLB
.3a79e8	68		pla		            PLA
.3a79e9	28		plp		            PLP
.3a79ea	c2 10		rep #$10	            REP #$10
.3a79ec	a2 18 7a	ldx #$7a18	                LDX #<>MERRBADMODE
.3a79ef	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a79f2	80 20		bra $3a7a14	                BRA done
.3a79f4					bad_offset
.3a79f4	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a79f7	08		php		            PHP
.3a79f8	e2 20		sep #$20	            SEP #$20
.3a79fa	48		pha		            PHA
.3a79fb	a9 3a		lda #$3a	            LDA #`MERRBADOFFSET
.3a79fd	48		pha		            PHA
.3a79fe	ab		plb		            PLB
.3a79ff	68		pla		            PLA
.3a7a00	28		plp		            PLP
.3a7a01	c2 10		rep #$10	            REP #$10
.3a7a03	a2 68 7a	ldx #$7a68	                LDX #<>MERRBADOFFSET
.3a7a06	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a7a09	80 09		bra $3a7a14	                BRA done
.3a7a0b	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.3a7a0d	29 c0		and #$c0	                AND #%11000000
.3a7a0f	d0 95		bne $3a79a6	                BNE emit_2              ; Yes: emit two bytes
.3a7a11	4c b2 79	jmp $3a79b2	                JMP emit_1              ; No: emit one byte
.3a7a14	2b		pld		done            PLD
.3a7a15	ab		plb		                PLB
.3a7a16	28		plp		                PLP
.3a7a17	6b		rtl		                RTL
>3a7a18	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>3a7a20	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>3a7a30	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>3a7a40	74 72 75 63 74 69 6f 6e 2e 0d 00
>3a7a4b	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>3a7a53	6f 6e 69 63 2e 0d 00
>3a7a5a	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>3a7a62	61 6e 64 2e 0d 00
>3a7a68	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>3a7a70	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>3a7a80	61 72 67 65 2e 0d 00
.3a7a87					AS_PC_OFFSET
.3a7a87	08		php		                PHP
.3a7a88	0b		phd		                PHD
.3a7a89	08		php		            PHP
.3a7a8a	c2 20		rep #$20	            REP #$20
.3a7a8c	48		pha		            PHA
.3a7a8d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7a90	5b		tcd		            TCD
.3a7a91	68		pla		            PLA
.3a7a92	28		plp		            PLP
.3a7a93	e2 20		sep #$20	            SEP #$20
.3a7a95	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.3a7a97	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.3a7a99	f0 0a		beq $3a7aa5	                BEQ is_short
.3a7a9b	c2 20		rep #$20	            REP #$20
.3a7a9d	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.3a7a9e	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.3a7aa0	69 02 00	adc #$0002	                ADC #2
.3a7aa3	80 08		bra $3a7aad	                BRA compute_cursor
.3a7aa5					is_short
.3a7aa5	c2 20		rep #$20	            REP #$20
.3a7aa7	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.3a7aa8	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.3a7aaa	69 01 00	adc #$0001	                ADC #1
.3a7aad	85 4a		sta $0892	compute_cursor  STA MTEMP
.3a7aaf	a5 34		lda $087c	                LDA MCURSOR+2
.3a7ab1	69 00 00	adc #$0000	                ADC #0
.3a7ab4	85 4c		sta $0894	                STA MTEMP+2
.3a7ab6	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.3a7ab7	a5 50		lda $0898	                LDA MPARSEDNUM
.3a7ab9	e5 4a		sbc $0892	                SBC MTEMP
.3a7abb	85 50		sta $0898	                STA MPARSEDNUM
.3a7abd	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7abf	e5 4c		sbc $0894	                SBC MTEMP+2
.3a7ac1	85 52		sta $089a	                STA MPARSEDNUM+2
.3a7ac3	e2 20		sep #$20	            SEP #$20
.3a7ac5	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7ac7	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a7ac9	f0 1e		beq $3a7ae9	                BEQ check_long
.3a7acb	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.3a7acd	30 0c		bmi $3a7adb	                BMI check_short_neg
.3a7acf	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.3a7ad1	d0 2a		bne $3a7afd	                BNE failure             ; Must be 0 or it's an overflow
.3a7ad3	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7ad5	d0 26		bne $3a7afd	                BNE failure
.3a7ad7	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.3a7ad9	80 26		bra $3a7b01	                BRA success
.3a7adb	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.3a7add	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.3a7adf	d0 1c		bne $3a7afd	                BNE failure
.3a7ae1	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7ae3	c9 ff		cmp #$ff	                CMP #$FF
.3a7ae5	d0 16		bne $3a7afd	                BNE failure
.3a7ae7	80 18		bra $3a7b01	                BRA success
.3a7ae9	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.3a7aeb	30 06		bmi $3a7af3	                BMI check_long_neg
.3a7aed	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.3a7aef	d0 0c		bne $3a7afd	                BNE failure             ; Must be 0 or it's an overflow
.3a7af1	80 0e		bra $3a7b01	                BRA success
.3a7af3	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.3a7af5	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.3a7af7	d0 04		bne $3a7afd	                BNE failure
.3a7af9	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.3a7afb	80 04		bra $3a7b01	                BRA success
.3a7afd	2b		pld		failure         PLD
.3a7afe	28		plp		                PLP
.3a7aff	18		clc		                CLC
.3a7b00	6b		rtl		                RTL
.3a7b01	2b		pld		success         PLD
.3a7b02	28		plp		                PLP
.3a7b03	38		sec		                SEC
.3a7b04	6b		rtl		                RTL
.3a7b05					AS_SHIFT_HEX
.3a7b05	08		php		                PHP
.3a7b06	0b		phd		                PHD
.3a7b07	c2 10		rep #$10	            REP #$10
.3a7b09	da		phx		                PHX
.3a7b0a	08		php		            PHP
.3a7b0b	c2 20		rep #$20	            REP #$20
.3a7b0d	48		pha		            PHA
.3a7b0e	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7b11	5b		tcd		            TCD
.3a7b12	68		pla		            PLA
.3a7b13	28		plp		            PLP
.3a7b14	e2 20		sep #$20	            SEP #$20
.3a7b16	a2 00 00	ldx #$0000	                LDX #0
.3a7b19	df 00 d0 3a	cmp $3ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.3a7b1d	f0 08		beq $3a7b27	                BEQ found
.3a7b1f	e8		inx		                INX                 ; Go to the next hex digit
.3a7b20	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.3a7b23	f0 1b		beq $3a7b40	                BEQ done            ; Yes... just return
.3a7b25	80 f2		bra $3a7b19	                BRA seek_loop
.3a7b27					found
.3a7b27	c2 20		rep #$20	            REP #$20
.3a7b29	06 50		asl $0898	                ASL MPARSEDNUM
.3a7b2b	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7b2d	06 50		asl $0898	                ASL MPARSEDNUM
.3a7b2f	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7b31	06 50		asl $0898	                ASL MPARSEDNUM
.3a7b33	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7b35	06 50		asl $0898	                ASL MPARSEDNUM
.3a7b37	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7b39	e2 20		sep #$20	            SEP #$20
.3a7b3b	8a		txa		                TXA
.3a7b3c	05 50		ora $0898	                ORA MPARSEDNUM
.3a7b3e	85 50		sta $0898	                STA MPARSEDNUM
.3a7b40	fa		plx		done            PLX
.3a7b41	2b		pld		                PLD
.3a7b42	28		plp		                PLP
.3a7b43	6b		rtl		                RTL
.3a7b44					AS_FIND_OPCODE
.3a7b44	0b		phd		                PHD
.3a7b45	8b		phb		                PHB
.3a7b46	08		php		            PHP
.3a7b47	c2 20		rep #$20	            REP #$20
.3a7b49	48		pha		            PHA
.3a7b4a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7b4d	5b		tcd		            TCD
.3a7b4e	68		pla		            PLA
.3a7b4f	28		plp		            PLP
.3a7b50	08		php		            PHP
.3a7b51	e2 20		sep #$20	            SEP #$20
.3a7b53	48		pha		            PHA
.3a7b54	a9 3a		lda #$3a	            LDA #`MNEMONIC_TAB
.3a7b56	48		pha		            PHA
.3a7b57	ab		plb		            PLB
.3a7b58	68		pla		            PLA
.3a7b59	28		plp		            PLP
.3a7b5a	e2 20		sep #$20	            SEP #$20
.3a7b5c	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7b5e	29 3f		and #$3f	                AND #%00111111
.3a7b60	85 4a		sta $0892	                STA MTEMP
.3a7b62	c2 30		rep #$30	            REP #$30
.3a7b64	a2 00 00	ldx #$0000	                LDX #0
.3a7b67	a0 00 00	ldy #$0000	                LDY #0
.3a7b6a	bd 11 82	lda $3a8211,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.3a7b6d	f0 1b		beq $3a7b8a	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.3a7b6f	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.3a7b71	d0 0d		bne $3a7b80	                BNE next_opcode         ; No: go to the next opcode
.3a7b73					check_mode
.3a7b73	e2 20		sep #$20	            SEP #$20
.3a7b75	b9 13 84	lda $3a8413,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.3a7b78	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.3a7b7a	c5 4a		cmp $0892	                CMP MTEMP
.3a7b7c	f0 07		beq $3a7b85	                BEQ found               ; Yes: we found the opcode
.3a7b7e	c2 20		rep #$20	            REP #$20
.3a7b80	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.3a7b81	e8		inx		                INX
.3a7b82	c8		iny		                INY
.3a7b83	80 e5		bra $3a7b6a	                BRA mnemonic_loop       ; And check it
.3a7b85	98		tya		found           TYA
.3a7b86	38		sec		                SEC                     ; Set carry to show success
.3a7b87	ab		plb		                PLB
.3a7b88	2b		pld		                PLD
.3a7b89	6b		rtl		                RTL
.3a7b8a	18		clc		not_found       CLC                     ; Clear carry to show failure
.3a7b8b	ab		plb		                PLB
.3a7b8c	2b		pld		                PLD
.3a7b8d	6b		rtl		                RTL
.3a7b8e					AS_STR_MATCH
.3a7b8e	08		php		                PHP
.3a7b8f	0b		phd		                PHD
.3a7b90	08		php		            PHP
.3a7b91	c2 20		rep #$20	            REP #$20
.3a7b93	48		pha		            PHA
.3a7b94	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7b97	5b		tcd		            TCD
.3a7b98	68		pla		            PLA
.3a7b99	28		plp		            PLP
.3a7b9a	e2 20		sep #$20	            SEP #$20
.3a7b9c	c2 10		rep #$10	            REP #$10
.3a7b9e	a0 00 00	ldy #$0000	                LDY #0
.3a7ba1	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.3a7ba3	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.3a7ba5	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.3a7ba7	f0 11		beq $3a7bba	                BEQ nul_check       ; If at end of pattern, check for end of test string
.3a7ba9	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.3a7bab	f0 19		beq $3a7bc6	                BEQ check_digit     ; Yes: do special check for hex digit
.3a7bad	48		pha		compare         PHA
.3a7bae	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7bb0	85 4a		sta $0892	                STA MTEMP
.3a7bb2	68		pla		                PLA
.3a7bb3	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.3a7bb5	d0 0b		bne $3a7bc2	                BNE return_false    ; No: return fail
.3a7bb7	c8		iny		next_char       INY                 ; Yes: test the next character
.3a7bb8	80 eb		bra $3a7ba5	                BRA match_loop
.3a7bba	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.3a7bbc	d0 04		bne $3a7bc2	                BNE return_false    ; If not: return false
.3a7bbe	2b		pld		return_true     PLD
.3a7bbf	28		plp		                PLP                 ; Return true
.3a7bc0	38		sec		                SEC
.3a7bc1	6b		rtl		                RTL
.3a7bc2	2b		pld		return_false    PLD
.3a7bc3	28		plp		                PLP                 ; Return false
.3a7bc4	18		clc		                CLC
.3a7bc5	6b		rtl		                RTL
.3a7bc6					check_digit
.3a7bc6	e2 20		sep #$20	            SEP #$20
.3a7bc8	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7bca	c9 3a		cmp #$3a	                CMP #'9'+1
.3a7bcc	b0 04		bcs $3a7bd2	                BCS check_AF
.3a7bce	c9 30		cmp #$30	                CMP #'0'
.3a7bd0	b0 14		bcs $3a7be6	                BCS shift_digit     ; character is in [0..9]
.3a7bd2	c9 47		cmp #$47	check_AF        CMP #'F'+1
.3a7bd4	b0 04		bcs $3a7bda	                BCS check_lc        ; check lower case
.3a7bd6	c9 41		cmp #$41	                CMP #'A'
.3a7bd8	b0 0c		bcs $3a7be6	                BCS shift_digit     ; character is in [A..F]
.3a7bda	c9 67		cmp #$67	check_lc        CMP #'f'+1
.3a7bdc	b0 e4		bcs $3a7bc2	                BCS return_false    ; check lower case
.3a7bde	c9 61		cmp #$61	                CMP #'a'
.3a7be0	b0 02		bcs $3a7be4	                BCS to_upcase       ; character is in [A..F]
.3a7be2	80 de		bra $3a7bc2	                BRA return_false    ; No match found... return false
.3a7be4	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.3a7be6	22 05 7b 3a	jsl $3a7b05	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.3a7bea	80 cb		bra $3a7bb7	                BRA next_char       ; And check the next character
.3a7bec					AS_MCMP_NEXT
.3a7bec	0b		phd		                PHD
.3a7bed	08		php		            PHP
.3a7bee	c2 20		rep #$20	            REP #$20
.3a7bf0	48		pha		            PHA
.3a7bf1	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7bf4	5b		tcd		            TCD
.3a7bf5	68		pla		            PLA
.3a7bf6	28		plp		            PLP
.3a7bf7	a0 00 00	ldy #$0000	                LDY #0
.3a7bfa	e2 20		sep #$20	            SEP #$20
.3a7bfc	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.3a7bfe	f0 03		beq $3a7c03	                BEQ found_nul
.3a7c00	c8		iny		                INY
.3a7c01	80 f9		bra $3a7bfc	                BRA loop
.3a7c03					found_nul
.3a7c03	c2 20		rep #$20	            REP #$20
.3a7c05	c8		iny		                INY                 ; Got to NUL... point to next byte
.3a7c06	5a		phy		                PHY
.3a7c07	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.3a7c08	18		clc		                CLC
.3a7c09	65 03		adc $084b	                ADC MCMP_TEXT
.3a7c0b	85 03		sta $084b	                STA MCMP_TEXT
.3a7c0d	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7c0f	69 00 00	adc #$0000	                ADC #0
.3a7c12	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7c14	2b		pld		                PLD
.3a7c15	6b		rtl		                RTL
.3a7c16					AS_FIND_MNEMO
.3a7c16	0b		phd		                PHD
.3a7c17	08		php		            PHP
.3a7c18	c2 20		rep #$20	            REP #$20
.3a7c1a	48		pha		            PHA
.3a7c1b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7c1e	5b		tcd		            TCD
.3a7c1f	68		pla		            PLA
.3a7c20	28		plp		            PLP
.3a7c21	c2 20		rep #$20	            REP #$20
.3a7c23	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.3a7c25	85 36		sta $087e	                STA MLINEBUF
.3a7c27	a5 13		lda $085b	                LDA MARG2+2
.3a7c29	85 38		sta $0880	                STA MLINEBUF+2
.3a7c2b	a9 9f 80	lda #$809f	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.3a7c2e	85 03		sta $084b	                STA MCMP_TEXT
.3a7c30	a9 3a 00	lda #$003a	                LDA #`MNEMONICS_TAB
.3a7c33	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7c35	22 8e 7b 3a	jsl $3a7b8e	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.3a7c39	b0 0d		bcs $3a7c48	                BCS found_mnemonic          ; If so: return that we found it
.3a7c3b	22 ec 7b 3a	jsl $3a7bec	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.3a7c3f	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.3a7c41	d0 f2		bne $3a7c35	                BNE match_loop              ; If not, check this next mnemonic
.3a7c43	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.3a7c46	80 02		bra $3a7c4a	                BRA done
.3a7c48	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.3a7c4a	2b		pld		done            PLD
.3a7c4b	6b		rtl		                RTL
.3a7c4c					AS_FIND_MODE
.3a7c4c	08		php		                PHP
.3a7c4d	0b		phd		                PHD
.3a7c4e	08		php		            PHP
.3a7c4f	c2 20		rep #$20	            REP #$20
.3a7c51	48		pha		            PHA
.3a7c52	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7c55	5b		tcd		            TCD
.3a7c56	68		pla		            PLA
.3a7c57	28		plp		            PLP
.3a7c58	c2 30		rep #$30	            REP #$30
.3a7c5a	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.3a7c5c	85 36		sta $087e	                STA MLINEBUF
.3a7c5e	a5 17		lda $085f	                LDA MARG3+2
.3a7c60	85 38		sta $0880	                STA MLINEBUF+2
.3a7c62	a9 2b 85	lda #$852b	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.3a7c65	85 03		sta $084b	                STA MCMP_TEXT
.3a7c67	a9 3a 00	lda #$003a	                LDA #`ADDR_PATTERNS
.3a7c6a	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7c6c	22 8e 7b 3a	jsl $3a7b8e	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.3a7c70	b0 22		bcs $3a7c94	                BCS is_match                ; Yes: Find address mode code
.3a7c72	22 ec 7b 3a	jsl $3a7bec	                JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7c76	c2 20		rep #$20	            REP #$20
.3a7c78	18		clc		                CLC                         ; Point to the first byte of the next pattern
.3a7c79	a5 03		lda $084b	                LDA MCMP_TEXT
.3a7c7b	69 01 00	adc #$0001	                ADC #1
.3a7c7e	85 03		sta $084b	                STA MCMP_TEXT
.3a7c80	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7c82	69 00 00	adc #$0000	                ADC #0
.3a7c85	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7c87	e2 20		sep #$20	            SEP #$20
.3a7c89	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.3a7c8b	d0 df		bne $3a7c6c	                BNE match_loop              ; No: check this next pattern
.3a7c8d	c2 20		rep #$20	            REP #$20
.3a7c8f	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.3a7c92	80 0d		bra $3a7ca1	                BRA done
.3a7c94	22 ec 7b 3a	jsl $3a7bec	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7c98	e2 20		sep #$20	            SEP #$20
.3a7c9a	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.3a7c9c	c2 20		rep #$20	            REP #$20
.3a7c9e	29 ff 00	and #$00ff	                AND #$00FF
.3a7ca1	2b		pld		done            PLD
.3a7ca2	28		plp		                PLP
.3a7ca3	6b		rtl		                RTL
.3a7ca4					IMDISASSEMBLE
.3a7ca4	08		php		                PHP
.3a7ca5	8b		phb		                PHB
.3a7ca6	0b		phd		                PHD
.3a7ca7	08		php		            PHP
.3a7ca8	c2 20		rep #$20	            REP #$20
.3a7caa	48		pha		            PHA
.3a7cab	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7cae	5b		tcd		            TCD
.3a7caf	68		pla		            PLA
.3a7cb0	28		plp		            PLP
.3a7cb1	e2 20		sep #$20	            SEP #$20
.3a7cb3	a9 00		lda #$00	                LDA #0
.3a7cb5	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.3a7cb9	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7cbb	c9 02		cmp #$02	                CMP #2
.3a7cbd	b0 16		bcs $3a7cd5	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7cbf	c9 01		cmp #$01	                CMP #1
.3a7cc1	90 20		bcc $3a7ce3	                BLT no_args         ; No arguments passed? Use defaults
.3a7cc3	c2 20		rep #$20	            REP #$20
.3a7cc5	18		clc		                CLC
.3a7cc6	a5 0d		lda $0855	                LDA MARG1
.3a7cc8	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7ccb	85 11		sta $0859	                STA MARG2
.3a7ccd	e2 20		sep #$20	            SEP #$20
.3a7ccf	a5 0f		lda $0857	                LDA MARG1+2
.3a7cd1	69 00		adc #$00	                ADC #0
.3a7cd3	85 13		sta $085b	                STA MARG2+2
.3a7cd5					set_cursor
.3a7cd5	c2 20		rep #$20	            REP #$20
.3a7cd7	a5 0d		lda $0855	                LDA MARG1
.3a7cd9	85 32		sta $087a	                STA MCURSOR
.3a7cdb	e2 20		sep #$20	            SEP #$20
.3a7cdd	a5 0f		lda $0857	                LDA MARG1+2
.3a7cdf	85 34		sta $087c	                STA MCURSOR+2
.3a7ce1	80 12		bra $3a7cf5	                BRA dasm_loop
.3a7ce3					no_args
.3a7ce3	c2 20		rep #$20	            REP #$20
.3a7ce5	18		clc		                CLC
.3a7ce6	a5 32		lda $087a	                LDA MCURSOR
.3a7ce8	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7ceb	85 11		sta $0859	                STA MARG2
.3a7ced	e2 20		sep #$20	            SEP #$20
.3a7cef	a5 34		lda $087c	                LDA MCURSOR+2
.3a7cf1	69 00		adc #$00	                ADC #0
.3a7cf3	85 13		sta $085b	                STA MARG2+2
.3a7cf5	22 10 7d 3a	jsl $3a7d10	dasm_loop       JSL DS_PR_LINE
.3a7cf9	e2 20		sep #$20	            SEP #$20
.3a7cfb	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a7cfd	c5 13		cmp $085b	                CMP MARG2+2
.3a7cff	90 f4		bcc $3a7cf5	                BLT dasm_loop           ; No: continue
.3a7d01	c2 20		rep #$20	            REP #$20
.3a7d03	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7d05	c5 11		cmp $0859	                CMP MARG2
.3a7d07	90 ec		bcc $3a7cf5	                BLT dasm_loop           ; Nope... keep going
.3a7d09					done
.3a7d09	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7d0c	2b		pld		                PLD
.3a7d0d	ab		plb		                PLB
.3a7d0e	28		plp		                PLP
.3a7d0f	6b		rtl		                RTL
.3a7d10					DS_PR_LINE
.3a7d10	08		php		                PHP
.3a7d11	0b		phd		                PHD
.3a7d12	e2 20		sep #$20	            SEP #$20
.3a7d14	a9 41		lda #$41	                LDA #'A'
.3a7d16	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d19	a9 20		lda #$20	                LDA #' '
.3a7d1b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d1e	08		php		            PHP
.3a7d1f	c2 20		rep #$20	            REP #$20
.3a7d21	48		pha		            PHA
.3a7d22	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7d25	5b		tcd		            TCD
.3a7d26	68		pla		            PLA
.3a7d27	28		plp		            PLP
.3a7d28	c2 20		rep #$20	            REP #$20
.3a7d2a	a5 00		lda $087a	                LDA MCURSOR
.3a7d2c	85 18		sta $0892	                STA MTEMP
.3a7d2e	e2 20		sep #$20	            SEP #$20
.3a7d30	a5 02		lda $087c	                LDA MCURSOR+2
.3a7d32	85 1a		sta $0894	                STA MTEMP+2
.3a7d34	22 77 80 3a	jsl $3a8077	                JSL M_PR_ADDR
.3a7d38	a9 20		lda #$20	                LDA #' '
.3a7d3a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d3d	c2 20		rep #$20	            REP #$20
.3a7d3f	18		clc		                CLC
.3a7d40	a5 00		lda $087a	                LDA MCURSOR
.3a7d42	69 01 00	adc #$0001	                ADC #1
.3a7d45	85 18		sta $0892	                STA MTEMP
.3a7d47	e2 20		sep #$20	            SEP #$20
.3a7d49	a5 02		lda $087c	                LDA MCURSOR+2
.3a7d4b	69 00		adc #$00	                ADC #0
.3a7d4d	85 1a		sta $0894	                STA MTEMP+2
.3a7d4f	e2 20		sep #$20	            SEP #$20
.3a7d51	c2 10		rep #$10	            REP #$10
.3a7d53	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.3a7d55	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.3a7d57	d0 0b		bne $3a7d64	                BNE check_sep           ; No: check to see if it is SEP
.3a7d59	48		pha		handle_rep      PHA
.3a7d5a	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7d5c	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.3a7d5e	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.3a7d62	80 0b		bra $3a7d6f	                BRA save_stat
.3a7d64	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.3a7d66	d0 0c		bne $3a7d74	                BNE get_op_index        ; No: process the instruction regularly
.3a7d68	48		pha		handle_sep      PHA
.3a7d69	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7d6b	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.3a7d6f	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.3a7d73	68		pla		                PLA
.3a7d74					get_op_index
.3a7d74	c2 20		rep #$20	            REP #$20
.3a7d76	29 ff 00	and #$00ff	                AND #$00FF
.3a7d79	0a		asl a		                ASL A
.3a7d7a	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.3a7d7b	bf 11 82 3a	lda $3a8211,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.3a7d7f	aa		tax		                TAX
.3a7d80	22 f1 7f 3a	jsl $3a7ff1	                JSL DS_PR_MNEMONIC      ; And print it
.3a7d84	e2 20		sep #$20	            SEP #$20
.3a7d86	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7d88	aa		tax		                TAX
.3a7d89	bf 13 84 3a	lda $3a8413,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.3a7d8d	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.3a7d91	22 9e 7d 3a	jsl $3a7d9e	                JSL DS_PR_OPERAND       ; And print the correct operand
.3a7d95	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a7d98	20 42 03	jsr $3a0342	            JSR PAGINATE
.3a7d9b	2b		pld		                PLD
.3a7d9c	28		plp		                PLP
.3a7d9d	6b		rtl		                RTL
.3a7d9e					DS_PR_OPERAND
.3a7d9e	08		php		                PHP
.3a7d9f	e2 20		sep #$20	            SEP #$20
.3a7da1	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.3a7da2	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.3a7da4	0a		asl a		                ASL A           ; Compute the index to the table
.3a7da5	c2 10		rep #$10	            REP #$10
.3a7da7	aa		tax		                TAX
.3a7da8	68		pla		                PLA             ; Restore A
.3a7da9	7c ac 7d	jmp ($3a7dac,x)	                JMP (dispatch,X)
>3a7dac	dc 7d				dispatch        .word <>is_dp_ind_x
>3a7dae	f7 7d				                .word <>is_dp
>3a7db0	fe 7d				                .word <>is_imm
>3a7db2	23 7e				                .word <>is_abs
>3a7db4	2a 7e				                .word <>is_dp_ind_y
>3a7db6	45 7e				                .word <>is_dp_x
>3a7db8	67 7e				                .word <>is_abs_y
>3a7dba	78 7e				                .word <>is_abs_x
>3a7dbc	b5 7e				                .word <>is_accumulator
>3a7dbe	bd 7e				                .word <>is_stack_r
>3a7dc0	ce 7e				                .word <>is_dp_long
>3a7dc2	df 7e				                .word <>is_abs_long
>3a7dc4	e6 7e				                .word <>is_stack_r_y
>3a7dc6	0b 7f				                .word <>is_dp_y_long
>3a7dc8	38 7f				                .word <>is_abs_x_long
>3a7dca	a4 7e				                .word <>is_dp_ind
>3a7dcc	89 7e				                .word <>is_abs_x_id
>3a7dce	56 7e				                .word <>is_dp_y
>3a7dd0	2b 7f				                .word <>is_pc_rel
>3a7dd2	35 7f				                .word <>is_implied
>3a7dd4	49 7f				                .word <>is_xyc
>3a7dd6	78 7f				                .word <>is_abs_ind
>3a7dd8	26 7f				                .word <>is_pc_rel_long
>3a7dda	89 7f				                .word <>is_abs_ind_long
.3a7ddc	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.3a7dde	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7de1	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print dd
.3a7de5	a9 2c		lda #$2c	                LDA #','
.3a7de7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dea	a9 58		lda #$58	                LDA #'X'
.3a7dec	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7def	a9 29		lda #$29	                LDA #')'
.3a7df1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7df4	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7df7	22 a0 7f 3a	jsl $3a7fa0	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.3a7dfb	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7dfe					is_imm
.3a7dfe	e2 20		sep #$20	            SEP #$20
.3a7e00	48		pha		                PHA
.3a7e01	a9 23		lda #$23	                LDA #'#'
.3a7e03	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e06	68		pla		                PLA
.3a7e07	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.3a7e09	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.3a7e0b	f0 0f		beq $3a7e1c	                BEQ is_imm_short        ; No: treat it as a short always
.3a7e0d	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.3a7e0e	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.3a7e0f	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.3a7e13	d0 07		bne $3a7e1c	                BNE is_imm_short        ; If it is set, immediate operation is short
.3a7e15	22 aa 7f 3a	jsl $3a7faa	                JSL DS_PR_OPERAND2      ; Print dddd
.3a7e19	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e1c	22 a0 7f 3a	jsl $3a7fa0	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.3a7e20	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e23	22 aa 7f 3a	jsl $3a7faa	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.3a7e27	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e2a	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.3a7e2c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e2f	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print dd
.3a7e33	a9 29		lda #$29	                LDA #')'
.3a7e35	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e38	a9 2c		lda #$2c	                LDA #','
.3a7e3a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e3d	a9 59		lda #$59	                LDA #'Y'
.3a7e3f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e42	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e45	22 a0 7f 3a	jsl $3a7fa0	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.3a7e49	a9 2c		lda #$2c	                LDA #','
.3a7e4b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e4e	a9 58		lda #$58	                LDA #'X'
.3a7e50	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e53	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e56	22 a0 7f 3a	jsl $3a7fa0	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.3a7e5a	a9 2c		lda #$2c	                LDA #','
.3a7e5c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e5f	a9 59		lda #$59	                LDA #'Y'
.3a7e61	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e64	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e67	22 aa 7f 3a	jsl $3a7faa	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.3a7e6b	a9 2c		lda #$2c	                LDA #','
.3a7e6d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e70	a9 59		lda #$59	                LDA #'Y'
.3a7e72	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e75	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e78	22 aa 7f 3a	jsl $3a7faa	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.3a7e7c	a9 2c		lda #$2c	                LDA #','
.3a7e7e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e81	a9 58		lda #$58	                LDA #'X'
.3a7e83	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e86	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7e89	a9 28		lda #$28	is_abs_x_id     LDA #'('
.3a7e8b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e8e	22 aa 7f 3a	jsl $3a7faa	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.3a7e92	a9 2c		lda #$2c	                LDA #','
.3a7e94	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e97	a9 58		lda #$58	                LDA #'X'
.3a7e99	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e9c	a9 29		lda #$29	                LDA #')'
.3a7e9e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ea1	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7ea4	a9 28		lda #$28	is_dp_ind       LDA #'('
.3a7ea6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ea9	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print (dd)
.3a7ead	a9 29		lda #$29	                LDA #')'
.3a7eaf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eb2	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7eb5	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.3a7eb7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eba	4c 9e 7f	jmp $3a7f9e	                JMP done
.3a7ebd	22 a0 7f 3a	jsl $3a7fa0	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.3a7ec1	a9 2c		lda #$2c	                LDA #','
.3a7ec3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ec6	a9 53		lda #$53	                LDA #'S'
.3a7ec8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ecb	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7ece	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.3a7ed0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ed3	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print dd
.3a7ed7	a9 5d		lda #$5d	                LDA #']'
.3a7ed9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7edc	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7edf	22 b8 7f 3a	jsl $3a7fb8	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.3a7ee3	4c 9e 7f	jmp $3a7f9e	                JMP done
.3a7ee6	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.3a7ee8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eeb	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print dd
.3a7eef	a9 2c		lda #$2c	                LDA #','
.3a7ef1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ef4	a9 53		lda #$53	                LDA #'S'
.3a7ef6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ef9	a9 29		lda #$29	                LDA #')'
.3a7efb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7efe	a9 2c		lda #$2c	                LDA #','
.3a7f00	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f03	a9 59		lda #$59	                LDA #'Y'
.3a7f05	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f08	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7f0b	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.3a7f0d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f10	22 a0 7f 3a	jsl $3a7fa0	                JSL DS_PR_OPERAND1      ; Print dd
.3a7f14	a9 5d		lda #$5d	                LDA #']'
.3a7f16	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f19	a9 2c		lda #$2c	                LDA #','
.3a7f1b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f1e	a9 59		lda #$59	                LDA #'Y'
.3a7f20	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f23	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7f26	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.3a7f29	80 03		bra $3a7f2e	                BRA do_pcrel
.3a7f2b	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.3a7f2e	22 1e 80 3a	jsl $3a801e	do_pcrel        JSL DS_PR_PCREL
.3a7f32	4c 9e 7f	jmp $3a7f9e	                JMP done
.3a7f35	4c 9e 7f	jmp $3a7f9e	is_implied      JMP done
.3a7f38	22 b8 7f 3a	jsl $3a7fb8	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.3a7f3c	a9 2c		lda #$2c	                LDA #','
.3a7f3e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f41	a9 58		lda #$58	                LDA #'X'
.3a7f43	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f46	4c 9e 7f	jmp $3a7f9e	                JMP done
.3a7f49	a9 23		lda #$23	is_xyc          LDA #'#'
.3a7f4b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f4e	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.3a7f4f	a5 02		lda $087c	                LDA MCURSOR+2
.3a7f51	48		pha		                PHA
.3a7f52	ab		plb		                PLB
.3a7f53	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a7f55	e8		inx		                INX
.3a7f56	a0 01 00	ldy #$0001	                LDY #1
.3a7f59	22 3b 03 3a	jsl $3a033b	                JSL PRINTH
.3a7f5d	a9 2c		lda #$2c	                LDA #','
.3a7f5f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f62	a9 23		lda #$23	                LDA #'#'
.3a7f64	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f67	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a7f69	a0 01 00	ldy #$0001	                LDY #1
.3a7f6c	22 3b 03 3a	jsl $3a033b	                JSL PRINTH
.3a7f70	ab		plb		                PLB                     ; Get our old data bank back
.3a7f71	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a7f75	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7f78	a9 28		lda #$28	is_abs_ind      LDA #'('
.3a7f7a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f7d	22 aa 7f 3a	jsl $3a7faa	                JSL DS_PR_OPERAND2      ; Print (dddd)
.3a7f81	a9 29		lda #$29	                LDA #')'
.3a7f83	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f86	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7f89	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.3a7f8b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f8e	22 aa 7f 3a	jsl $3a7faa	                JSL DS_PR_OPERAND2      ; Print [dddd]
.3a7f92	a9 5d		lda #$5d	                LDA #']'
.3a7f94	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f97	4c 9a 7f	jmp $3a7f9a	                JMP done_1
.3a7f9a	22 cd 85 3a	jsl $3a85cd	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.3a7f9e	28		plp		done            PLP
.3a7f9f	6b		rtl		                RTL
.3a7fa0					DS_PR_OPERAND1
.3a7fa0	08		php		                PHP
.3a7fa1	e2 20		sep #$20	            SEP #$20
.3a7fa3	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7fa5	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a7fa8	28		plp		                PLP
.3a7fa9	6b		rtl		                RTL
.3a7faa					DS_PR_OPERAND2
.3a7faa	08		php		                PHP
.3a7fab	c2 30		rep #$30	            REP #$30
.3a7fad	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7faf	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a7fb2	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a7fb6	28		plp		                PLP
.3a7fb7	6b		rtl		                RTL
.3a7fb8					DS_PR_OPERAND3
.3a7fb8	08		php		                PHP
.3a7fb9	8b		phb		                PHB
.3a7fba	0b		phd		                PHD
.3a7fbb	c2 30		rep #$30	            REP #$30
.3a7fbd	5a		phy		                PHY
.3a7fbe	08		php		            PHP
.3a7fbf	c2 20		rep #$20	            REP #$20
.3a7fc1	48		pha		            PHA
.3a7fc2	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7fc5	5b		tcd		            TCD
.3a7fc6	68		pla		            PLA
.3a7fc7	28		plp		            PLP
.3a7fc8	08		php		            PHP
.3a7fc9	e2 20		sep #$20	            SEP #$20
.3a7fcb	48		pha		            PHA
.3a7fcc	a9 00		lda #$00	            LDA #`MTEMP
.3a7fce	48		pha		            PHA
.3a7fcf	ab		plb		            PLB
.3a7fd0	68		pla		            PLA
.3a7fd1	28		plp		            PLP
.3a7fd2	e2 20		sep #$20	            SEP #$20
.3a7fd4	a0 00 00	ldy #$0000	                LDY #0
.3a7fd7	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.3a7fd9	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.3a7fdc	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a7fe0	c8		iny		                INY
.3a7fe1	c0 03 00	cpy #$0003	                CPY #3
.3a7fe4	d0 f1		bne $3a7fd7	                BNE copy_loop
.3a7fe6	22 77 80 3a	jsl $3a8077	                JSL M_PR_ADDR       ; Print the address
.3a7fea	c2 30		rep #$30	            REP #$30
.3a7fec	7a		ply		                PLY
.3a7fed	2b		pld		                PLD
.3a7fee	ab		plb		                PLB
.3a7fef	28		plp		                PLP
.3a7ff0	6b		rtl		                RTL
.3a7ff1					DS_PR_MNEMONIC
.3a7ff1	08		php		                PHP
.3a7ff2	8b		phb		                PHB
.3a7ff3	e2 20		sep #$20	            SEP #$20
.3a7ff5	c2 10		rep #$10	            REP #$10
.3a7ff7	08		php		            PHP
.3a7ff8	e2 20		sep #$20	            SEP #$20
.3a7ffa	48		pha		            PHA
.3a7ffb	a9 3a		lda #$3a	            LDA #`MN_ORA
.3a7ffd	48		pha		            PHA
.3a7ffe	ab		plb		            PLB
.3a7fff	68		pla		            PLA
.3a8000	28		plp		            PLP
.3a8001	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a8004	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8007	e8		inx		                INX
.3a8008	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a800b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a800e	e8		inx		                INX
.3a800f	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a8012	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8015	e8		inx		                INX
.3a8016	a9 20		lda #$20	                LDA #' '            ; Print a space
.3a8018	20 18 00	jsr $3a0018	            JSR PRINTC
.3a801b	ab		plb		                PLB
.3a801c	28		plp		                PLP
.3a801d	6b		rtl		                RTL
.3a801e					DS_PR_PCREL
.3a801e	08		php		                PHP
.3a801f	0b		phd		                PHD
.3a8020	08		php		            PHP
.3a8021	c2 20		rep #$20	            REP #$20
.3a8023	48		pha		            PHA
.3a8024	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a8027	5b		tcd		            TCD
.3a8028	68		pla		            PLA
.3a8029	28		plp		            PLP
.3a802a	e2 20		sep #$20	            SEP #$20
.3a802c	c0 02 00	cpy #$0002	                CPY #2
.3a802f	f0 14		beq $3a8045	                BEQ offset_2
.3a8031	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a8033	85 18		sta $0892	                STA MTEMP
.3a8035	30 06		bmi $3a803d	                BMI is_negative
.3a8037	64 19		stz $0893	                STZ MTEMP+1
.3a8039	64 1a		stz $0894	                STZ MTEMP+2
.3a803b	80 1e		bra $3a805b	                BRA add_offset
.3a803d	a9 ff		lda #$ff	is_negative     LDA #$FF
.3a803f	85 19		sta $0893	                STA MTEMP+1
.3a8041	85 1a		sta $0894	                STA MTEMP+2
.3a8043	80 16		bra $3a805b	                BRA add_offset
.3a8045	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.3a8047	85 18		sta $0892	                STA MTEMP
.3a8049	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a804d	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a804f	85 19		sta $0893	                STA MTEMP+1
.3a8051	30 04		bmi $3a8057	                BMI is_negative2
.3a8053	64 1a		stz $0894	                STZ MTEMP+2
.3a8055	80 04		bra $3a805b	                BRA add_offset
.3a8057	a9 ff		lda #$ff	is_negative2    LDA #$FF
.3a8059	85 1a		sta $0894	                STA MTEMP+2
.3a805b					add_offset
.3a805b	c2 20		rep #$20	            REP #$20
.3a805d	38		sec		                SEC             ; Add 1 to the offset
.3a805e	a5 00		lda $087a	                LDA MCURSOR
.3a8060	65 18		adc $0892	                ADC MTEMP
.3a8062	85 18		sta $0892	                STA MTEMP
.3a8064	e2 20		sep #$20	            SEP #$20
.3a8066	a5 02		lda $087c	                LDA MCURSOR+2
.3a8068	65 1a		adc $0894	                ADC MTEMP+2
.3a806a	85 1a		sta $0894	                STA MTEMP+2
.3a806c	22 77 80 3a	jsl $3a8077	                JSL M_PR_ADDR
.3a8070	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a8074	2b		pld		                PLD
.3a8075	28		plp		                PLP
.3a8076	6b		rtl		                RTL
.3a8077					M_PR_ADDR
.3a8077	08		php		                PHP
.3a8078	0b		phd		                PHD
.3a8079	c2 20		rep #$20	            REP #$20
.3a807b	48		pha		                PHA
.3a807c	08		php		            PHP
.3a807d	c2 20		rep #$20	            REP #$20
.3a807f	48		pha		            PHA
.3a8080	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8083	5b		tcd		            TCD
.3a8084	68		pla		            PLA
.3a8085	28		plp		            PLP
.3a8086	e2 20		sep #$20	            SEP #$20
.3a8088	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.3a808a	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a808d	e2 20		sep #$20	            SEP #$20
.3a808f	a9 3a		lda #$3a	                LDA #':'
.3a8091	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8094	c2 20		rep #$20	            REP #$20
.3a8096	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.3a8098	20 c8 03	jsr $3a03c8	            JSR PRHEXW
.3a809b	68		pla		                PLA
.3a809c	2b		pld		                PLD
.3a809d	28		plp		                PLP
.3a809e	6b		rtl		                RTL
.3a809f					MNEMONICS_TAB
.3a809f					MN_ORA
>3a809f	4f 52 41 00			            .null "ORA"
.3a80a3					MN_AND
>3a80a3	41 4e 44 00			            .null "AND"
.3a80a7					MN_EOR
>3a80a7	45 4f 52 00			            .null "EOR"
.3a80ab					MN_ADC
>3a80ab	41 44 43 00			            .null "ADC"
.3a80af					MN_STA
>3a80af	53 54 41 00			            .null "STA"
.3a80b3					MN_LDA
>3a80b3	4c 44 41 00			            .null "LDA"
.3a80b7					MN_CMP
>3a80b7	43 4d 50 00			            .null "CMP"
.3a80bb					MN_SBC
>3a80bb	53 42 43 00			            .null "SBC"
.3a80bf					MN_ASL
>3a80bf	41 53 4c 00			            .null "ASL"
.3a80c3					MN_ROL
>3a80c3	52 4f 4c 00			            .null "ROL"
.3a80c7					MN_LSR
>3a80c7	4c 53 52 00			            .null "LSR"
.3a80cb					MN_ROR
>3a80cb	52 4f 52 00			            .null "ROR"
.3a80cf					MN_STX
>3a80cf	53 54 58 00			            .null "STX"
.3a80d3					MN_LDX
>3a80d3	4c 44 58 00			            .null "LDX"
.3a80d7					MN_DEC
>3a80d7	44 45 43 00			            .null "DEC"
.3a80db					MN_INC
>3a80db	49 4e 43 00			            .null "INC"
.3a80df					MN_BIT
>3a80df	42 49 54 00			            .null "BIT"
.3a80e3					MN_JMP
>3a80e3	4a 4d 50 00			            .null "JMP"
.3a80e7					MN_STY
>3a80e7	53 54 59 00			            .null "STY"
.3a80eb					MN_LDY
>3a80eb	4c 44 59 00			            .null "LDY"
.3a80ef					MN_CPY
>3a80ef	43 50 59 00			            .null "CPY"
.3a80f3					MN_CPX
>3a80f3	43 50 58 00			            .null "CPX"
.3a80f7					MN_BRK
>3a80f7	42 52 4b 00			            .null "BRK"
.3a80fb					MN_JSR
>3a80fb	4a 53 52 00			            .null "JSR"
.3a80ff					MN_RTI
>3a80ff	52 54 49 00			            .null "RTI"
.3a8103					MN_RTS
>3a8103	52 54 53 00			            .null "RTS"
.3a8107					MN_PHP
>3a8107	50 48 50 00			            .null "PHP"
.3a810b					MN_PLP
>3a810b	50 4c 50 00			            .null "PLP"
.3a810f					MN_PHA
>3a810f	50 48 41 00			            .null "PHA"
.3a8113					MN_PLA
>3a8113	50 4c 41 00			            .null "PLA"
.3a8117					MN_DEY
>3a8117	44 45 59 00			            .null "DEY"
.3a811b					MN_TAY
>3a811b	54 41 59 00			            .null "TAY"
.3a811f					MN_INY
>3a811f	49 4e 59 00			            .null "INY"
.3a8123					MN_INX
>3a8123	49 4e 58 00			            .null "INX"
.3a8127					MN_CLC
>3a8127	43 4c 43 00			            .null "CLC"
.3a812b					MN_SEC
>3a812b	53 45 43 00			            .null "SEC"
.3a812f					MN_CLI
>3a812f	43 4c 49 00			            .null "CLI"
.3a8133					MN_SEI
>3a8133	53 45 49 00			            .null "SEI"
.3a8137					MN_TYA
>3a8137	54 59 41 00			            .null "TYA"
.3a813b					MN_CLV
>3a813b	43 4c 56 00			            .null "CLV"
.3a813f					MN_CLD
>3a813f	43 4c 44 00			            .null "CLD"
.3a8143					MN_SED
>3a8143	53 45 44 00			            .null "SED"
.3a8147					MN_TXA
>3a8147	54 58 41 00			            .null "TXA"
.3a814b					MN_TXS
>3a814b	54 58 53 00			            .null "TXS"
.3a814f					MN_TAX
>3a814f	54 41 58 00			            .null "TAX"
.3a8153					MN_TSX
>3a8153	54 53 58 00			            .null "TSX"
.3a8157					MN_DEX
>3a8157	44 45 58 00			            .null "DEX"
.3a815b					MN_NOP
>3a815b	4e 4f 50 00			            .null "NOP"
.3a815f					MN_BPL
>3a815f	42 50 4c 00			            .null "BPL"
.3a8163					MN_BMI
>3a8163	42 4d 49 00			            .null "BMI"
.3a8167					MN_BVC
>3a8167	42 56 43 00			            .null "BVC"
.3a816b					MN_BVS
>3a816b	42 56 53 00			            .null "BVS"
.3a816f					MN_BCC
>3a816f	42 43 43 00			            .null "BCC"
.3a8173					MN_BCS
>3a8173	42 43 53 00			            .null "BCS"
.3a8177					MN_BNE
>3a8177	42 4e 45 00			            .null "BNE"
.3a817b					MN_BEQ
>3a817b	42 45 51 00			            .null "BEQ"
.3a817f					MN_TSB
>3a817f	54 53 42 00			            .null "TSB"
.3a8183					MN_TRB
>3a8183	54 52 42 00			            .null "TRB"
.3a8187					MN_STZ
>3a8187	53 54 5a 00			            .null "STZ"
.3a818b					MN_BRA
>3a818b	42 52 41 00			            .null "BRA"
.3a818f					MN_PHY
>3a818f	50 48 59 00			            .null "PHY"
.3a8193					MN_PLY
>3a8193	50 4c 59 00			            .null "PLY"
.3a8197					MN_PHX
>3a8197	50 48 58 00			            .null "PHX"
.3a819b					MN_PLX
>3a819b	50 4c 58 00			            .null "PLX"
.3a819f					MN_PHD
>3a819f	50 48 44 00			            .null "PHD"
.3a81a3					MN_PLD
>3a81a3	50 4c 44 00			            .null "PLD"
.3a81a7					MN_PHK
>3a81a7	50 48 4b 00			            .null "PHK"
.3a81ab					MN_RTL
>3a81ab	52 54 4c 00			            .null "RTL"
.3a81af					MN_PHB
>3a81af	50 48 42 00			            .null "PHB"
.3a81b3					MN_PLB
>3a81b3	50 4c 42 00			            .null "PLB"
.3a81b7					MN_WAI
>3a81b7	57 41 49 00			            .null "WAI"
.3a81bb					MN_XBA
>3a81bb	58 42 41 00			            .null "XBA"
.3a81bf					MN_TCS
>3a81bf	54 43 53 00			            .null "TCS"
.3a81c3					MN_TSC
>3a81c3	54 53 43 00			            .null "TSC"
.3a81c7					MN_TCD
>3a81c7	54 43 44 00			            .null "TCD"
.3a81cb					MN_TDC
>3a81cb	54 44 43 00			            .null "TDC"
.3a81cf					MN_TXY
>3a81cf	54 58 59 00			            .null "TXY"
.3a81d3					MN_TYX
>3a81d3	54 59 58 00			            .null "TYX"
.3a81d7					MN_STP
>3a81d7	53 54 50 00			            .null "STP"
.3a81db					MN_XCE
>3a81db	58 43 45 00			            .null "XCE"
.3a81df					MN_COP
>3a81df	43 4f 50 00			            .null "COP"
.3a81e3					MN_JSL
>3a81e3	4a 53 4c 00			            .null "JSL"
.3a81e7					MN_WDM
>3a81e7	57 44 4d 00			            .null "WDM"
.3a81eb					MN_PER
>3a81eb	50 45 52 00			            .null "PER"
.3a81ef					MN_BRL
>3a81ef	42 52 4c 00			            .null "BRL"
.3a81f3					MN_REP
>3a81f3	52 45 50 00			            .null "REP"
.3a81f7					MN_SEP
>3a81f7	53 45 50 00			            .null "SEP"
.3a81fb					MN_MVP
>3a81fb	4d 56 50 00			            .null "MVP"
.3a81ff					MN_MVN
>3a81ff	4d 56 4e 00			            .null "MVN"
.3a8203					MN_PEI
>3a8203	50 45 49 00			            .null "PEI"
.3a8207					MN_PEA
>3a8207	50 45 41 00			            .null "PEA"
.3a820b					MN_JML
>3a820b	4a 4d 4c 00			            .null "JML"
>3a820f	00 00				            .byte 0, 0
>3a8211	f7 80 9f 80 df 81 9f 80		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>3a8219	7f 81 9f 80 bf 80 9f 80
>3a8221	07 81 9f 80 bf 80 9f 81		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a8229	7f 81 9f 80 bf 80 9f 80
>3a8231	5f 81 9f 80 9f 80 9f 80		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>3a8239	83 81 9f 80 bf 80 9f 80
>3a8241	27 81 9f 80 db 80 bf 81		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a8249	83 81 9f 80 bf 80 9f 80
>3a8251	fb 80 a3 80 e3 81 a3 80		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>3a8259	df 80 a3 80 c3 80 a3 80
>3a8261	0b 81 a3 80 c3 80 a3 81		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a8269	df 80 a3 80 c3 80 a3 80
>3a8271	63 81 a3 80 a3 80 a3 80		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>3a8279	df 80 a3 80 c3 80 a3 80
>3a8281	2b 81 a3 80 d7 80 c3 81		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a8289	df 80 a3 80 c3 80 a3 80
>3a8291	ff 80 a7 80 e7 81 a7 80		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>3a8299	fb 81 a7 80 c7 80 a7 80
>3a82a1	0f 81 a7 80 c7 80 a7 81		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a82a9	e3 80 a7 80 c7 80 a7 80
>3a82b1	67 81 a7 80 a7 80 a7 80		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>3a82b9	ff 81 a7 80 c7 80 a7 80
>3a82c1	2f 81 a7 80 8f 81 c7 81		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a82c9	0b 82 a7 80 c7 80 a7 80
>3a82d1	03 81 ab 80 eb 81 ab 80		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>3a82d9	87 81 ab 80 cb 80 ab 80
>3a82e1	13 81 ab 80 cb 80 ab 81		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a82e9	e3 80 ab 80 cb 80 ab 80
>3a82f1	6b 81 ab 80 ab 80 ab 80		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>3a82f9	87 81 ab 80 cb 80 ab 80
>3a8301	33 81 ab 80 93 81 cb 81		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a8309	e3 80 ab 80 cb 80 ab 80
>3a8311	8b 81 af 80 ef 81 af 80		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>3a8319	e7 80 af 80 cf 80 af 80
>3a8321	17 81 df 80 47 81 af 81		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>3a8329	e7 80 af 80 cf 80 af 80
>3a8331	6f 81 af 80 af 80 af 80		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>3a8339	e7 80 af 80 cf 80 af 80
>3a8341	37 81 af 80 4b 81 cf 81		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>3a8349	87 81 af 80 87 81 af 80
>3a8351	eb 80 b3 80 d3 80 b3 80		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>3a8359	eb 80 b3 80 d3 80 b3 80
>3a8361	1b 81 b3 80 4f 81 b3 81		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a8369	eb 80 b3 80 d3 80 b3 80
>3a8371	73 81 b3 80 b3 80 b3 80		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>3a8379	eb 80 b3 80 d3 80 b3 80
>3a8381	3b 81 b3 80 53 81 d3 81		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a8389	eb 80 b3 80 d3 80 b3 80
>3a8391	ef 80 b7 80 f3 81 b7 80		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>3a8399	ef 80 b7 80 d7 80 b7 80
>3a83a1	1f 81 b7 80 57 81 b7 81		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a83a9	ef 80 b7 80 d7 80 b7 80
>3a83b1	77 81 b7 80 b7 80 b7 80		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>3a83b9	03 82 b7 80 d7 80 b7 80
>3a83c1	3f 81 b7 80 97 81 d7 81		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a83c9	0b 82 b7 80 d7 80 b7 80
>3a83d1	f3 80 bb 80 f7 81 bb 80		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>3a83d9	f3 80 bb 80 db 80 bb 80
>3a83e1	23 81 bb 80 5b 81 bb 81		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a83e9	f3 80 bb 80 db 80 bb 80
>3a83f1	7b 81 bb 80 bb 80 bb 80		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>3a83f9	07 82 bb 80 db 80 bb 80
>3a8401	43 81 bb 80 9b 81 db 81		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a8409	fb 80 bb 80 db 80 bb 80
>3a8411	00 00				                .word 0
>3a8413	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>3a8417	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a841b	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a841f	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8423	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>3a8427	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a842b	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a842f	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8433	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>3a8437	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a843b	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a843f	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8443	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>3a8447	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a844b	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a844f	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8453	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>3a8457	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a845b	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a845f	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8463	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>3a8467	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a846b	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a846f	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>3a8473	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>3a8477	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a847b	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a847f	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8483	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>3a8487	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a848b	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a848f	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8493	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>3a8497	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a849b	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a849f	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a84a3	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>3a84a7	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a84ab	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a84af	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a84b3	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>3a84b7	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a84bb	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a84bf	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a84c3	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>3a84c7	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a84cb	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a84cf	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>3a84d3	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>3a84d7	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a84db	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a84df	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a84e3	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>3a84e7	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a84eb	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a84ef	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a84f3	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>3a84f7	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>3a84fb	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a84ff	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8503	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>3a8507	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a850b	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a850f	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8513	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>3a851b	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.3a852b					ADDR_PATTERNS
>3a852b	41 00				            .null "A"
>3a852d	08				            .byte ADDR_ACC
>3a852e	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>3a8536	58 00
>3a8538	0e				            .byte ADDR_ABS_X_LONG
>3a8539	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>3a8541	0b				            .byte ADDR_ABS_LONG
>3a8542	64 64 64 64 2c 58 00		            .null "dddd,X"
>3a8549	07				            .byte ADDR_ABS_X
>3a854a	64 64 64 64 2c 59 00		            .null "dddd,Y"
>3a8551	06				            .byte ADDR_ABS_Y
>3a8552	64 64 64 64 00			            .null "dddd"
>3a8557	03				            .byte ADDR_ABS
>3a8558	64 64 2c 58 00			            .null "dd,X"
>3a855d	05				            .byte ADDR_DP_X
>3a855e	64 64 2c 59 00			            .null "dd,Y"
>3a8563	11				            .byte ADDR_DP_Y
>3a8564	64 64 2c 53 00			            .null "dd,S"
>3a8569	09				            .byte ADDR_SP_R
>3a856a	64 64 00			            .null "dd"
>3a856d	01				            .byte ADDR_DP
>3a856e	23 64 64 64 64 00		            .null "#dddd"
>3a8574	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>3a8575	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>3a857d	14				            .byte ADDR_XYC
>3a857e	23 64 64 00			            .null "#dd"
>3a8582	02				            .byte ADDR_IMM
>3a8583	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>3a858b	00
>3a858c	0c				            .byte ADDR_SP_R_Y
>3a858d	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>3a8595	00
>3a8596	10				            .byte ADDR_ABS_X_ID
>3a8597	28 64 64 64 64 29 00		            .null "(dddd)"
>3a859e	10				            .byte ADDR_ABS_X_ID
>3a859f	28 64 64 2c 58 29 00		            .null "(dd,X)"
>3a85a6	00				            .byte ADDR_DP_IND_X
>3a85a7	28 64 64 29 2c 59 00		            .null "(dd),Y"
>3a85ae	04				            .byte ADDR_DP_IND_Y
>3a85af	28 64 64 29 00			            .null "(dd)"
>3a85b4	0f				            .byte ADDR_DP_IND
>3a85b5	5b 64 64 64 64 5d 00		            .null "[dddd]"
>3a85bc	17				            .byte ADDR_ABS_IND_LONG
>3a85bd	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>3a85c4	0d				            .byte ADDR_DP_Y_LONG
>3a85c5	5b 64 64 5d 00			            .null "[dd]"
>3a85ca	0a				            .byte ADDR_DP_LONG
>3a85cb	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.3a85cd					M_INC_CURSOR
.3a85cd	08		php		                PHP
.3a85ce	c2 20		rep #$20	            REP #$20
.3a85d0	48		pha		                PHA
.3a85d1	18		clc		                CLC
.3a85d2	af 7a 08 00	lda $00087a	                LDA MCURSOR
.3a85d6	69 01 00	adc #$0001	                ADC #1
.3a85d9	8f 7a 08 00	sta $00087a	                STA MCURSOR
.3a85dd	e2 20		sep #$20	            SEP #$20
.3a85df	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.3a85e3	69 00		adc #$00	                ADC #0
.3a85e5	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.3a85e9	c2 20		rep #$20	            REP #$20
.3a85eb	68		pla		                PLA
.3a85ec	28		plp		                PLP
.3a85ed	6b		rtl		                RTL
.3a85ee					MPRINTB
.3a85ee	08		php		                PHP
.3a85ef	c2 10		rep #$10	            REP #$10
.3a85f1	e2 20		sep #$20	            SEP #$20
.3a85f3	da		phx		                PHX
.3a85f4	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.3a85f7	0a		asl a		loop            ASL A           ; Shift MSB to C
.3a85f8	b0 08		bcs $3a8602	                BCS is_one
.3a85fa	48		pha		                PHA             ; Save value to print
.3a85fb	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.3a85fd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8600	80 06		bra $3a8608	                BRA continue
.3a8602	48		pha		is_one          PHA             ; Save value to print
.3a8603	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.3a8605	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8608	68		pla		continue        PLA
.3a8609	ca		dex		                DEX             ; Count down the bits to shift
.3a860a	d0 eb		bne $3a85f7	                BNE loop        ; And try the next one if there is one
.3a860c	fa		plx		                PLX             ; Otherwise, return
.3a860d	28		plp		                PLP
.3a860e	6b		rtl		                RTL
.3a860f					MSKIPWS
.3a860f	08		php		            PHP
.3a8610	c2 20		rep #$20	            REP #$20
.3a8612	48		pha		            PHA
.3a8613	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8616	5b		tcd		            TCD
.3a8617	68		pla		            PLA
.3a8618	28		plp		            PLP
.3a8619	e2 20		sep #$20	            SEP #$20
.3a861b	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.3a861d	f0 0a		beq $3a8629	                BEQ done            ; If NULL, we're done
.3a861f	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.3a8621	d0 06		bne $3a8629	                BNE done            ; No: we're done
.3a8623	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR    ; Yes, try the next one
.3a8627	80 f2		bra $3a861b	                BRA loop
.3a8629	6b		rtl		done            RTL
.3a862a					MPARSESTR
.3a862a	08		php		                PHP
.3a862b	08		php		            PHP
.3a862c	c2 20		rep #$20	            REP #$20
.3a862e	48		pha		            PHA
.3a862f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8632	5b		tcd		            TCD
.3a8633	68		pla		            PLA
.3a8634	28		plp		            PLP
.3a8635	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR                ; Point to the first character of the name
.3a8639	22 0f 86 3a	jsl $3a860f	                JSL MSKIPWS                     ; Skip white space
.3a863d	c2 30		rep #$30	            REP #$30
.3a863f	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a8641	c2 20		rep #$20	            REP #$20
.3a8643	29 ff 00	and #$00ff	                AND #$00FF
.3a8646	0a		asl a		                ASL A                           ; multiply it by forfour
.3a8647	0a		asl a		                ASL A
.3a8648	aa		tax		                TAX                             ; ... to get the index to the argument
.3a8649	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.3a864b	95 0d		sta $0855,x	                STA MARG1,X
.3a864d	a5 34		lda $087c	                LDA MCURSOR+2
.3a864f	95 0f		sta $0857,x	                STA MARG1+2,X
.3a8651	e2 20		sep #$20	            SEP #$20
.3a8653	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.3a8655	f0 14		beq $3a866b	                BEQ done                        ; If NULL... treat it as a closed argument
.3a8657	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.3a8659	f0 06		beq $3a8661	                BEQ close_string
.3a865b	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a865f	80 f2		bra $3a8653	                BRA loop
.3a8661	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.3a8663	87 32		sta [$087a]	                STA [MCURSOR]
.3a8665	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR                ; And point to the next byte
.3a8669	e6 31		inc $0879	                INC MARG_LEN
.3a866b	28		plp		done            PLP
.3a866c	6b		rtl		                RTL
.3a866d					MPARSEARG
.3a866d	08		php		            PHP
.3a866e	c2 20		rep #$20	            REP #$20
.3a8670	48		pha		            PHA
.3a8671	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8674	5b		tcd		            TCD
.3a8675	68		pla		            PLA
.3a8676	28		plp		            PLP
.3a8677	e2 20		sep #$20	            SEP #$20
.3a8679	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.3a867b	c2 20		rep #$20	            REP #$20
.3a867d	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.3a867f	64 52		stz $089a	                STZ MPARSEDNUM+2
.3a8681					pa_loop
.3a8681	e2 20		sep #$20	            SEP #$20
.3a8683	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.3a8685	c9 3a		cmp #$3a	                CMP #":"
.3a8687	f0 0d		beq $3a8696	                BEQ pa_next_char                ; Ignore any colons
.3a8689	20 60 04	jsr $3a0460	            JSR ISHEX
.3a868c	90 0e		bcc $3a869c	                BCC finished_arg                ; No? We're done with this argument
.3a868e	22 05 7b 3a	jsl $3a7b05	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.3a8692	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.3a8694	85 4a		sta $0892	                STA MTEMP
.3a8696	22 cd 85 3a	jsl $3a85cd	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.3a869a	80 e5		bra $3a8681	                BRA pa_loop
.3a869c	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.3a869e	f0 16		beq $3a86b6	                BEQ done                        ; No: we're done
.3a86a0	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a86a2	c2 20		rep #$20	            REP #$20
.3a86a4	29 ff 00	and #$00ff	                AND #$00FF
.3a86a7	0a		asl a		                ASL A                           ; multiply it by forfour
.3a86a8	0a		asl a		                ASL A
.3a86a9	aa		tax		                TAX                             ; ... to get the index to the argument
.3a86aa	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.3a86ac	95 0d		sta $0855,x	                STA MARG1,X
.3a86ae	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a86b0	95 0f		sta $0857,x	                STA MARG1+2,X
.3a86b2	e2 20		sep #$20	            SEP #$20
.3a86b4	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.3a86b6	6b		rtl		done            RTL
.3a86b7					MPARSEALLARG
.3a86b7	e2 20		sep #$20	            SEP #$20
.3a86b9	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.3a86bb	22 0f 86 3a	jsl $3a860f	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.3a86bf	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.3a86c1	f0 21		beq $3a86e4	                BEQ done                        ; If it is NULL, we're done
.3a86c3	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.3a86c5	d0 06		bne $3a86cd	                BNE regular_arg
.3a86c7	22 2a 86 3a	jsl $3a862a	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.3a86cb	80 0a		bra $3a86d7	                BRA check_rest
.3a86cd	22 6d 86 3a	jsl $3a866d	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.3a86d1	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.3a86d3	c9 09		cmp #$09	                CMP #9
.3a86d5	b0 0d		bcs $3a86e4	                BGE done                        ; If >=9, then we're done
.3a86d7	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.3a86d9	f0 09		beq $3a86e4	                BEQ done                        ; If EOL: we're done
.3a86db	c9 20		cmp #$20	                CMP #' '
.3a86dd	f0 dc		beq $3a86bb	                BEQ parse_arg                   ; If space: try to process another argument
.3a86df	20 60 04	jsr $3a0460	            JSR ISHEX
.3a86e2	b0 d7		bcs $3a86bb	                BCS parse_arg                   ; If hex digit: try to process another argument
.3a86e4	6b		rtl		done            RTL
.3a86e5					IMPARSE
.3a86e5	08		php		                PHP
.3a86e6	0b		phd		                PHD
.3a86e7	08		php		            PHP
.3a86e8	c2 20		rep #$20	            REP #$20
.3a86ea	48		pha		            PHA
.3a86eb	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a86ee	5b		tcd		            TCD
.3a86ef	68		pla		            PLA
.3a86f0	28		plp		            PLP
.3a86f1	c2 10		rep #$10	            REP #$10
.3a86f3	e2 20		sep #$20	            SEP #$20
.3a86f5	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.3a86f8	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.3a86fa	ca		dex		                DEX
.3a86fb	d0 fb		bne $3a86f8	                BNE clear_command
.3a86fd	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.3a86ff	85 02		sta $084a	                STA MCMDADDR+2
.3a8701	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.3a8703	c2 20		rep #$20	            REP #$20
.3a8705	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.3a8708	85 00		sta $0848	                STA MCMDADDR
.3a870a	85 32		sta $087a	                STA MCURSOR
.3a870c	e2 20		sep #$20	            SEP #$20
.3a870e	22 0f 86 3a	jsl $3a860f	                JSL MSKIPWS                     ; Skip to the first letter of the command
.3a8712	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.3a8714	f0 38		beq $3a874e	                BEQ done                        ; Yes: there's no command here
.3a8716	c2 20		rep #$20	            REP #$20
.3a8718	a5 32		lda $087a	                LDA MCURSOR
.3a871a	85 08		sta $0850	                STA MCMD
.3a871c	e2 20		sep #$20	            SEP #$20
.3a871e	a5 34		lda $087c	                LDA MCURSOR+2
.3a8720	85 0a		sta $0852	                STA MCMD+2
.3a8722	a2 01 00	ldx #$0001	                LDX #1
.3a8725	22 cd 85 3a	jsl $3a85cd	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.3a8729	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.3a872b	d0 06		bne $3a8733	                BNE cmd_space                   ; If not NULL: check for a space
.3a872d	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.3a872f	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.3a8731	80 1b		bra $3a874e	                BRA done                        ; ... And return
.3a8733	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.3a8735	f0 03		beq $3a873a	                BEQ found_cmd                   ; Yes: save the length
.3a8737	e8		inx		                INX                             ; No: go to the next character
.3a8738	80 eb		bra $3a8725	                BRA cmd_loop
.3a873a	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.3a873c	a9 00		lda #$00	                LDA #0
.3a873e	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.3a8740	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR                ; And skip to the next character
.3a8744	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.3a8746	c9 41		cmp #$41	                CMP #'A'
.3a8748	f0 07		beq $3a8751	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.3a874a	22 b7 86 3a	jsl $3a86b7	                JSL MPARSEALLARG
.3a874e	2b		pld		done            PLD
.3a874f	28		plp		                PLP
.3a8750	6b		rtl		                RTL
.3a8751	22 0f 86 3a	jsl $3a860f	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.3a8755	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8757	f0 f5		beq $3a874e	                BEQ done                        ; Exit if we got the end-of-line
.3a8759	22 6d 86 3a	jsl $3a866d	                JSL MPARSEARG                   ; Parse the first argument as the target address
.3a875d	22 0f 86 3a	jsl $3a860f	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.3a8761	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8763	f0 e9		beq $3a874e	                BEQ done                        ; Exit if we got the end-of-line
.3a8765	c2 20		rep #$20	            REP #$20
.3a8767	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.3a8769	85 11		sta $0859	                STA MARG2
.3a876b	e2 20		sep #$20	            SEP #$20
.3a876d	a5 34		lda $087c	                LDA MCURSOR+2
.3a876f	85 13		sta $085b	                STA MARG2+2
.3a8771	22 cd 85 3a	jsl $3a85cd	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.3a8775	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8777	f0 26		beq $3a879f	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.3a8779	c9 20		cmp #$20	                CMP #' '
.3a877b	d0 f4		bne $3a8771	                BNE asm_find_sp
.3a877d	a9 00		lda #$00	                LDA #0
.3a877f	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.3a8781	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.3a8783	22 cd 85 3a	jsl $3a85cd	                JSL M_INC_CURSOR
.3a8787	22 0f 86 3a	jsl $3a860f	                JSL MSKIPWS                     ; Skip to the addressing mode
.3a878b	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a878d	f0 bf		beq $3a874e	                BEQ done                        ; If EOL: we're done
.3a878f	c2 20		rep #$20	            REP #$20
.3a8791	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.3a8793	85 15		sta $085d	                STA MARG3
.3a8795	e2 20		sep #$20	            SEP #$20
.3a8797	a5 34		lda $087c	                LDA MCURSOR+2
.3a8799	85 17		sta $085f	                STA MARG3+2
.3a879b	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.3a879d	80 af		bra $3a874e	                BRA done                        ; and return
.3a879f	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.3a87a1	80 ab		bra $3a874e	                BRA done                        ; And quit
.3a87a3					IMLOAD
.3a87a3	08		php		                PHP
.3a87a4	c2 10		rep #$10	            REP #$10
.3a87a6	e2 20		sep #$20	            SEP #$20
.3a87a8	a5 31		lda $0879	                LDA MARG_LEN
.3a87aa	d0 0f		bne $3a87bb	                BNE get_arguments
.3a87ac	a2 99 88	ldx #$8899	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.3a87af	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a87b1	48		pha		                PHA
.3a87b2	ab		plb		                PLB
.3a87b3	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a87b6	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a87b9	80 61		bra $3a881c	                BRA done
.3a87bb					get_arguments
.3a87bb	c2 20		rep #$20	            REP #$20
.3a87bd	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a87bf	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a87c3	a5 0f		lda $0857	                LDA MARG1+2
.3a87c5	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a87c9	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a87cc	e2 20		sep #$20	            SEP #$20
.3a87ce	a5 31		lda $0879	                LDA MARG_LEN
.3a87d0	c9 01		cmp #$01	                CMP #1
.3a87d2	d0 0f		bne $3a87e3	                BNE get_dest
.3a87d4	c2 20		rep #$20	            REP #$20
.3a87d6	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.3a87d9	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.3a87dd	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a87e1	80 0e		bra $3a87f1	                BRA try_load
.3a87e3					get_dest
.3a87e3	c2 20		rep #$20	            REP #$20
.3a87e5	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.3a87e7	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a87eb	a5 13		lda $085b	                LDA MARG2+2
.3a87ed	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a87f1	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.3a87f5	b0 25		bcs $3a881c	                BCS done
.3a87f7					error
.3a87f7	e2 20		sep #$20	            SEP #$20
.3a87f9	a2 bf 88	ldx #$88bf	                LDX #<>MCANTLOAD                ; Print bad arguments error
.3a87fc	a9 3a		lda #$3a	                LDA #`MCANTLOAD
.3a87fe	48		pha		                PHA
.3a87ff	ab		plb		                PLB
.3a8800	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a8803	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a8807	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a880a	a9 20		lda #$20	                LDA #' '
.3a880c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a880f	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a8813	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a8816	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a8819	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a881c	28		plp		done            PLP
.3a881d	6b		rtl		                RTL
.3a881e					IMSAVE
.3a881e	8b		phb		                PHB
.3a881f	08		php		                PHP
.3a8820	c2 10		rep #$10	            REP #$10
.3a8822	e2 20		sep #$20	            SEP #$20
.3a8824	a5 31		lda $0879	                LDA MARG_LEN
.3a8826	c9 03		cmp #$03	                CMP #3
.3a8828	f0 0f		beq $3a8839	                BEQ get_arguments
.3a882a	a2 99 88	ldx #$8899	                LDX #<>MERRARGS                 ; Print bad arguments error
.3a882d	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a882f	48		pha		                PHA
.3a8830	ab		plb		                PLB
.3a8831	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a8834	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a8837	80 54		bra $3a888d	                BRA done
.3a8839					get_arguments
.3a8839	c2 20		rep #$20	            REP #$20
.3a883b	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a883d	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a8841	a5 0f		lda $0857	                LDA MARG1+2
.3a8843	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a8847	20 8c 69	jsr $3a698c	            JSR SETFILEDESC
.3a884a	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.3a884c	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a8850	a5 13		lda $085b	                LDA MARG2+2
.3a8852	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a8856	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.3a8858	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a885c	a5 17		lda $085f	                LDA MARG3+2
.3a885e	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a8862	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.3a8866	b0 25		bcs $3a888d	                BCS done
.3a8868					error
.3a8868	e2 20		sep #$20	            SEP #$20
.3a886a	a2 a9 88	ldx #$88a9	                LDX #<>MCANTSAVE                ; Print bad arguments error
.3a886d	a9 3a		lda #$3a	                LDA #`MCANTSAVE
.3a886f	48		pha		                PHA
.3a8870	ab		plb		                PLB
.3a8871	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a8874	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a8878	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a887b	a9 20		lda #$20	                LDA #' '
.3a887d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8880	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a8884	20 e2 03	jsr $3a03e2	            JSR PRHEXB
.3a8887	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a888a	20 2b 03	jsr $3a032b	            JSR PRINTCR
.3a888d	28		plp		done            PLP
.3a888e	ab		plb		                PLB
.3a888f	6b		rtl		                RTL
.3a8890	5c 0f 27 3a	jmp $3a270f	IMEXIT          JML INTERACT
.3a8894	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.3a8895	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.3a8896	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.3a8897	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.3a8898	00		brk #		IMDOS           BRK ; Execute DOS command
.3a8899					MMESSAGES
>3a8899	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>3a88a1	6d 65 6e 74 73 0d 0d 00
>3a88a9	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>3a88b1	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>3a88bf	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>3a88c7	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>3a88d5	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>3a88dd	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>3a88ed	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>3a88fd	56 4d 58 44 49 5a 43 0d 00
>3a8906	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>3a890e	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.3a8919	18		clc		START       CLC                 ; Go to native mode
.3a891a	fb		xce		            XCE
.3a891b	08		php		            PHP
.3a891c	c2 20		rep #$20	            REP #$20
.3a891e	48		pha		            PHA
.3a891f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a8922	5b		tcd		            TCD
.3a8923	68		pla		            PLA
.3a8924	28		plp		            PLP
.3a8925	08		php		            PHP
.3a8926	e2 20		sep #$20	            SEP #$20
.3a8928	48		pha		            PHA
.3a8929	a9 00		lda #$00	            LDA #BASIC_BANK
.3a892b	48		pha		            PHA
.3a892c	ab		plb		            PLB
.3a892d	68		pla		            PLA
.3a892e	28		plp		            PLP
.3a892f	c2 30		rep #$30	            REP #$30
.3a8931	20 58 89	jsr $3a8958	            JSR INITBASIC
.3a8934	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.3a8937	1b		tcs		            TCS
.3a8938	08		php		            PHP
.3a8939	e2 20		sep #$20	            SEP #$20
.3a893b	48		pha		            PHA
.3a893c	a9 3a		lda #$3a	            LDA #`GREET
.3a893e	48		pha		            PHA
.3a893f	ab		plb		            PLB
.3a8940	68		pla		            PLA
.3a8941	28		plp		            PLP
.3a8942	a2 71 d2	ldx #$d271	            LDX #<>GREET
.3a8945	20 b8 03	jsr $3a03b8	            JSR PRINTS
.3a8948	08		php		            PHP
.3a8949	e2 20		sep #$20	            SEP #$20
.3a894b	48		pha		            PHA
.3a894c	a9 00		lda #$00	            LDA #BASIC_BANK
.3a894e	48		pha		            PHA
.3a894f	ab		plb		            PLB
.3a8950	68		pla		            PLA
.3a8951	28		plp		            PLP
.3a8952	4c 0f 27	jmp $3a270f	            JMP INTERACT        ; Start accepting input from the user
.3a8955	4c 55 89	jmp $3a8955	WAIT        JMP WAIT
.3a8958					INITBASIC
.3a8958	08		php		            PHP
.3a8959	20 c3 02	jsr $3a02c3	            JSR INITIO
.3a895c	20 fb 4e	jsr $3a4efb	            JSR CMD_NEW
.3a895f	28		plp		            PLP
.3a8960	60		rts		            RTS
>3ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>3ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>3ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+374"
>3ad28e	6c 70 68 61 2b 33 37 34

;******  Return to file: src\basic816.s

>3ad296	0d 00				            .byte 13,0

;******  End of listing
